\documentclass[12pt]{report}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{natbib}%Bibtex
\usepackage{float}
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{booktabs}
\usepackage{tabto}

\input{../ltx/setupComments}

\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.
%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
\edcommsfalse
\begin{document}

\pagenumbering{roman} %% Roman numerals before actual document starts
\begin{titlepage}\begin{center}
\thispagestyle{empty} %% No page no. on title

\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Software Requirement Specification 
	
	\edinsert{JG}{Version 1}

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill

We acknowledge that this document uses material from the Volere Requirements
Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
Limited.

\vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 9th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history

\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 26 / 09 / 2015 & Initial skeleton version \\\hline
\end{tabular}
\end{center}\end{table}

\tableofcontents
\listoffigures
\listoftables

\newpage
\pagenumbering{arabic} %% Arabic numerals in actual document

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 1: ???                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\edchange{JG}
{\chapter{Introduction}\label{ch:Intro}}
{\chapter{Project Drivers}\label{ch:Drivers}}

\edchange{JG}
{\section{Project Description}\label{sec:Intro}}
{\section{The Purpose of the Project}\label{sec:Purpose}}
\edcomm{JG}{any comments I made, is a suggestion and its up to you which way 
you prefer to write it. thanks for getting this to us early, I'm sorry we're so 
unorganized}
%% 1a. The User Business or Background of the Project Effort
A large part of designing software systems is requirements engineering. One
of the greatest challenges of requirements engineering is translating from
business requirements to a functional specification. Business requirements are
informal, with the intention of being easily understood by humans; however,
functional specifications are written in formal language to unambiguously capture attributes of the 
information system. Typically, this translation
of business requirements to a formal specification is done by a requirements
engineer, which can be prone to human error.

Ampersand is a tool which aims to address this problem in a different way; by
translating business requirements written in natural language into a formal
specification by means of a ``compilation process'' (\cite{derFun}). 
\edcomm{JG}{Maybe we should cut out how entirely, because there's a design 
specification -- and solely focus on what? thoughts?}%
\edcomm{YT}{The significance of Ampersand has to do with how it solves the
  problem, or how it works. To speak to the purpose of the project means to
  explain why the Ampersand solution is good and why we are spending our time
  making it better. The rubric has a section titled 'General System
  Description', so we need to say something about it}%
%% NB: Put a tex comment at
%% the end of the line after your 'in-line' comments, or latex inserts extra
%% whitespace when rendering with comments off.
Even though the business requirements and formal specification are written in
entirely different languages, the ``compiler guarantees compliance between the
two'' (\cite[2]{derFun}). 

Ampersand also provides engineers with a variety of aids which
help them to design products that fulfill all of the needs of their clients and
the end-users (Figure~\ref{fig:figure1}); including data models, service catalogs and their
specifications. Requirements engineering is perhaps most important in
safety-critical systems; to this end, Ampersand generates modeling aids and
specifications which are provably correct (\cite{derFun}). 

\begin{figure}
  \centering
    \includegraphics[width=0.7\textwidth]{../figures/ampersand_artifacts}
\caption{Ampersand produces a set of artifacts based on user's requirements.}~\label{fig:figure1}
\end{figure}

%% 1b. Goals of the Project 
Ampersand has proven reliable in practical situations, and there have been
efforts to teach this approach to business analysts. A large portion of the
Ampersand system is already in place; the primary focus of this project is to
augment Ampersand with increased capabilities for automation.

For example, consider a system for ordering products online. Ampersand takes, as
an input, statements of business requirements like
\edcomm{JG}{Good example, could we put something in here about restrictions of 
of the real world?}%
\edcomm{YT}{Business requirements *are* real world requirements. Do you mean something safety-related?
This example isn't the best, I know, but I deliberately chose a simple example}%
\edcomm{YS}{The example is easy to understand. I think we should keep it.} 
\edcomm{YS}{I'm not too sure if the haskell implementation needs to be a part of the introduction.
Rubrics indicate the following critera - - - - %%%%%%%%%%%%%%%%%
 delineate purpose, specify intended audience), system scope, definitions, acronyms,
abbreviations, references, system overview, roadmap of report - - - -
%%%%%%%%%%%%%%%%%%%%%%%
I believe we miss definition of EFA and ECA since it is being used a lot in the document
}%
\edcomm{YT}{Haskell isn't mentioned at all the intro, ECA is mentioned but is also defined
(it is really quite simple, we don't define it mathematically, just in natural language, so 
it shouldn't be incomprehensible).}%
\begin{quotation}
\noindent{\emph{Every order must have a customer and a list of products; and the total price on
the order must equal the sum of the prices of the products.}}
\end{quotation}
\edcomm{YS}{Attempt at defining ECA}%
\edcomm{YS}{Should we remove some of the haskell code and define the scope of our project in terms of conserving these data rules instead? There's a good chance Dan hasn't read our new problem statement so he doesn't necessarily have a clear idea of Ampersand. Suggestions?}\edcomm{YT}{There is no Haskell code!}\edcomm{YS}{Sorry, i meant the pre-post conditions pairs, I guess we'll let that stay.}%
These are translated into, among other things, formal rules concerning how the
information system must react to changes in its state. Ampersand describes these rules as
a set of Event-Condition-Action Rules (referred to as the ECA rules hereafter)
that specify when an event takes place under a given condition, what Action the software must take. 
The information system may contain a function for manipulating orders. (Ampersand can also generate
prototype software models, including functions types like these, from business
requirements - but this is not the topic of our contribution). For example,

\begin{verbatim}
addToOrder : ( o : Ref Order, t : Product )
\end{verbatim}
\noindent{where \verb|Ref x| represents the type of references to values of type
\verb|x|; \verb|Order| and \verb|Product| the types of orders and products, respectively.  }

Ampersand can generate pre- and post-conditions for this function, based on the
business requirements. This constitutes a formal specification of the
information system. For example, the above function may have the following specification:

\begin{verbatim}
{ PRE: o.totalCost = t0 } 
addToOrder(o,t) = ...
{ POST: o.totalCost = t0 + t.cost } 
\end{verbatim}

It is proven \edcomm{YT}{This is 'proven' because someone told me we have a
  proof/presentation of the algorithm, but not its implementation. Can anyone
  find this? We absolutely need a reference to this.} \edcomm{JG}{Can you give 
  me more context as to what is proven? I found an article on ampersand 
  subsets, I pushed it; look for "subsets" by Joosten(both)}%
\edcomm{YT}{There is no file in the repository with the word 'subset' in it?}%
that for the subset of processes which Ampersand can support, there is an
algorithm which will generate the necessary code to satisfy the post-conditions
(ie, formal specifications) of each function. However, Ampersand does not yet
implement this algorithm. Currently, a user of Ampersand must manually indicate
how each violation must be corrected.

In the previous example, the implementation of the
function could be as follows: 

\begin{verbatim}
{ PRE: o.totalCost = t0 } 
addToOrder(o,t) = 
  o.orders.append(t);
  o.totalCost = o.totalCost + t.cost;
{ POST: o.totalCost = t0 + t.cost } 
\end{verbatim}

The first line includes the item in the order, and the second line fixes the
violation of the post-condition which would occur without it. Currently this
second line would have to be hand-written by the programmer, but the
afformentioned \edcomm{YT}{Should have a name to refer to the algorithm
  somehow?} algorithm can derive it from the business rules. The main
contribution of this project will be to implement the algorithm which generates
the code to fix violations.

\section{The Stakeholders}\label{sec:Stakeholders}
%% From the template:
%% For each type of stakeholder, provide the following information:
%% ● Stakeholder identification (some combination of role/job title, person name, and organization name)
%% ● Knowledge that the project needs from that stakeholder
%% ● The degree of involvement necessary for that stakeholder/knowledge combination
%% ● The degree of influence for that stakeholder/knowledge combination
%% ● Agreement on how to address conflicts between stakeholders who have an interest in the same knowledge
%% This doesn't really seem to fit a list format.. And the majority of these things apply
%% mainly to Ampersand - everyone else only uses Ampersand, the developers of Ampersand
%% themselves also need our code to fit into their project, so they have the majority of the say
%% in how things are done. Namely:
%%    A list of the decisions for which the client will be responsible
%% Most 'decisions' will be made by them. 
%% TODO: Write this section. 

\edcomm{YT}{These are the only real stakeholders I can think of...}
\edcomm{JG}{you're right, I can't name names for end users so we might have to cut everything but 
the designers out, or find a way to use the multiple rules the professors have and play in 
dailylife to shovel the other subsections into the first one and strip the subsection titles. I'm 
not sure what to do here  }
\subsection{Ampersand Designers}\label{subsec:Ampersand}
Ampersand designers are Dr. Stef Joosten and Dr. Sebastian Joosten, who in
addition to supervising the development of EFA (``Event-Condition-Action'' rules
for Ampersand, see \ref{sec:Naming}) are also Ampersand
contributers. Dr. Stef Joosten is the designer of the Ampersand method which
have been successfully implemented in various public sectors. The interest
stemming from these three individuals are not only professional but also
personal. Ampersand has been nurtured by a great deal of patience and
dedication. The designers of EFA by extension are Ampersand contributors and
are affected by its outcome, the piece of Ampersand we will build is a necessary
component required for completion of undergraduate and is designed to test the
capabilities of an undergraduate team.  These individuals are the foundation of
the belief system by which Ampersand is built. The Ampersand model is built on
the belief that technology is highly incorporated in the use of business and
affects the life of every individual.  It is the belief that information system
can and will be designed and built at an affordable price and perfectly
compliant with the functionalities that users desire. This perspective treats
information systems as a commodity of the real world that can be traded,
altered, and used by any individual who is willing to learn how to use it.
\subsection{Requirements engineers}\label{subsec:BusReq}
Requirement engineers are responsible of translating business 
requirements into project specifications. Ampersand provides requirement 
engineers with the freedom to explore their creativity rather than be tried 
down by technical minutes. The ability to delegate time consuming tasks such as 
manually checking over technical specifications would increase the efficiency 
of the task at hand as well as decrease the number of hours required for 
completion. An added benefit which engineers receive is the ability to confirm 
that the system they have designed matching the specifications given to them by 
the client. EFA provides the ability to ensure no contradictions are found 
within the design by automatically fixing inconsistency that may arise. 
\subsection{Architects \& Functional Specification Designers}
System architects, similar to functional specification designers are 
responsible for various designs which affect procedure and processes in a place 
of business. Ampersand has the ability to confirm that the design provided by 
the Architect matches any building regulations that must be meet. Regardless of 
whether the specification is for safety or aesthetics, the product must meet the 
client's requirements and minimal legal regulations. Ampersand is able to 
compose rules and regulations for data which fully incorporates both without 
contradiction. The addition of EFA allows Ampersand to automate correction  
on data which may contradict rules specified for a project. Architects and 
functional specification designers will be able to take advantage of the 
numerous resources Ampersand can provide such as automatic generation of 
databases within prototypes along with tables and relational schema's. 
Furthermore, there is a full range of graphics that stakeholders can choose 
from in order to provide visual display of their design which user may find 
more friendly and easy to understand. 
\subsection{Process Innovators}
Process innovators covers a broad range of individuals that would not commonly 
be considered stakeholders. This broad category includes anyone who provides 
input for business processes which includes both sides of a business agreement, 
in addition to individuals who play a role in seeing the completion of a 
business process. Ampersand allows continuous input as a living system and has 
the ability to reorganize requirements when new constraints are added, and 
EFA has the ability to assure the correctness of system information relative 
to the requirements it has been given. With EFA's ability to verify 
inconsistencies and automate their correction, changes to design and 
restrictions due to unforeseen circumstances can be added without a system 
overhaul. The efficiency in which Ampersand can provide has the potential to 
dramatically decrease flaws that commonly litter information system.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 2: Project Constraints %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Project Constraints}\label{ch:Constraints}
The main constraint of this project is time; this is limited to the 8 month 
period in which we have to build it. It is difficult to perfect an internal 
construction without a large system in such a short amount of time. But time 
restraint is an obstacle which all projects face, because it is not limitless. 
Another major constraint that most project face that this project does not 
require is the financial constraint where projects become difficult to maintain 
and often halt in their progress due to monetary constraints. The lack of 
monetary constraints due to the open source software opens up a broad base of 
opportunities for future improvements and limitless contributions from the 
community.
\section{Mandated Constraints}\label{sec:Constraints}

%%%%
%% 4.1 Solution constraints. 
%% We don't have that many, so 'solution constraints' isn't really appropriate.
\subsection{Project philosophy}

Ampersand is an existing software project with a very sizable code base. The
cost of maintaining poorly-written code can be very high and can outweigh the
benefit of the contribution. In order for our code to eventually be merged into
Ampersand, it must be maintainable: it must be written according to coding
practices of Ampersand; it must be well documented, so it can be easily
understood by other programmers. 

Similarly, our code must not introduce any errors or performance regressions
into Ampersand. Our code must satisfy existing tests and additional tests should
be written for the new algorithm being implemented. Writing maintainable and
well-documented code will help with this goal as well.

These motivations are very important to Ampersand and are considered primary
goals alongside the obvious goal of producing code implementing the desired
feature.

%%3b.
\subsection{Implementation environment}
\subsubsection*{Haskell}
The Ampersand code base is written almost entirely in Haskell. Part of the
prototype software is written in PHP and Javascript %Ref???  
but we likely do not have to interact with this code base. Our code contribution
must be entirely in Haskell.

\subsubsection*{Haskell software}
Ampersand is designed to be used with the Glasgow Haskell Compiler (from here on, GHC) %%REF
and the associated Cabal build system (see \verb|ampersand.cabal| from \cite{ampSource}). 
Ampersand also uses many open source Haskell packages, all available on the
Hackage package archive. 
If we are to introduce dependencies on additional packages,
  these must be well-justified and negotiated with the Ampersand developers.


\subsubsection*{GitHub}
The Ampersand code base currently lives on GitHub. Our code contributions must
also be on GitHub; this will facilitate easy integration of our code into
Ampersand. This is especially useful if only parts of our code eventually become
integrated into Ampersand - GitHub facilitates this especially. 
\edcomm{YS}{Do we want to tell them that our code might not be integrated in Ampersand?
I think we should abstract this information to make our configuration look more significant.}%

\subsubsection*{Graphviz}
Graphiv is open source graph visualization software, which has the ability to
visually represent information in the form of charts and graphs. It contains
various designs from which the user is able to select. This is used to take
descriptions of graphs in simple text and create diagrams. Ampersand generates
reports about the input system using graphs and charts, so this is one of the
basic components required to run Ampersand.

\subsubsection*{XAMPP}
Ampersand generates prototype websites based on business requirements; to run
these, some web server software is needed. XAMPP stands for cross \big( i.e., X
\big) platform Apache distribution containing MySQL, PHP and Perl. XAMPP \cite{xampp} is the
most convenient way to set up a working database for Ampersand and access .php
pages. 

\edcomm{YT}{Be liberal with what you include in this section, but if it is a
  'technology' then put it in the previous section. Any acronyms, or words that
  the layman probably won't know, need to be here.}%
\section{Naming Conventions and Terminology}\label{sec:Naming} 
\begin{description}
\item[ECA] Stands for Event-Condition Action. The rule structure used for data
  bases and commonly used in market ready business rule engines. ECA rules are
  used in Ampersand to describe how a database should be modified in response to
  a system constraint becoming untrue. Event-Condition Action rules have
  the following structure (\cite[8--9]{RBD}):
\begin{verbatim}
when <some event has happened> 
and if <some condition is fulfilled> 
    do <this activity>
\end{verbatim} %TODO{JG}: bold or italicize words in definitions
\edcomm{JG}{Please keep this in alphabetical order, or order it by chapter or something, but it 
needs to be in an order of some kind}
\item [ADL] Stands for ``A Description Language'' (\cite[13]{derFun}). From a
given set of formally defined business requirements, Ampersand generates a
functional specification consisting of a data model, a service catalog, a
formal specification of the services, and a function point analysis. An ADL
script acts as an input for Ampersand. An ADL file consists of a plain ASCII
text file.
\item [Ampersand] Ampersand is the name of this project. It is used to refer to
both the method of generating functional specification from formalized
business requirements, and the software tool which implements this method.
\item [Business requirements] Requirements which exist due to some real world constraints;
ie, financial, logistic, physical or safety constraints. 
\item [Business rules] See \emph{Business Requirements}.
\item [EFA] Stands for ``ECA (see above) for Ampersand''. This term is used to refer to 
  the contribution of this project. 
\item [Functional specification] A \emph{formal} document which details the operation,
  capabilities, and appearance of a software system. 

\item [Natural language] Language written in a manner similair to that of human communication; 
  language intended to be interpreted and understood by humans, as opposed to machines. 
\item [Requirements engineering] The process of translating business
requirements into a functional specification. 
 

\edcomm{YS}{ADL is probably not "A data Language".}
\edcomm{YT}{I swear to god I read "A data Language" somewhere... maybe I was
  delirious from lack of sleep... In any case, we should eventually find a
  reference for ``ADL'', whatever it is...}
\edcomm{JG}{this is in Joosten's article "Deriving Functional Specifications from Business 
Requirements with Ampersand", ADL is a tool that accompanies Ampersand (which is a method); ADL 
generates a functional specification consisting of a data model, service catalogue, a formal 
specification of the services, and a function point analysis
	
	It (ADL) translates business rules  back into the natural language, and provides feed back to 
	the requirments engineer for validating his work. (Also becareful with how you use the word 
	validation vs. verification, these terms are distinguished in Rule based design and we dont 
	want to contradict ourselves/our supervisors by using them interchangably)
	
	ADL translates the entire set of requirements to design artifacts that are needed in subsequent 
	software design processes (p.2)
	
	They also specify the difference between requiement and specification: where specification is 
	used to prescribe properties of a system to be built; and requirement describes an explicit or 
	implicit need need of users}
\edcomm{YT}{Stef's article describes ADL as 'an accompanying tool' but also as
  the 'language which is input to Ampersand'. This is confusing and I feel like
  the former definition is not that useful so I decided to omit it. Just refer
  to 'Ampersand' as both the tool which is written in Haskell and this method of
  generating functional consraints from business requirements. To this end, I
  added a definiton of 'Ampersand'. But thanks for the reference to 'A
  description language'}
\edcomm{JG}{I'm.. so confused lol the more we do this the more lost Ive become as to what is what 
and how we're going to do what we're suppose to do -- I can't even tell if Ampersand is a system, 
model or tool.. or all three? }
\end{description}

%TODO{JG}: add Expression as a data type? Find a better way of describing 
%Expression without implementation details

%% This section is strange and we may have to replace it with something else...
\section{Relevant Facts and Assumptions}\label{sec:Assumptions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Chapter 3 -- Functional requirements %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Functional Requirements}\label{ch:Functional}
%% This section is probably a good place to give a description of ampersand. 
\section{The Scope of the Work}\label{sec:ScopeOfWork}

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=\textwidth]{../figures/business_process}
\caption{Business process diagram representing the role of Ampersand in the
  software design cycle}~\label{fig:BusinessProcess}
\end{center}
\end{figure}

\edcomm{YT}{The template has a bunch of stuff for this section. But I think this
  diagram is a good summary. Let me know what you guys think. }%

Figure \ref{fig:BusinessProcess} is a simplified view of the software design
cycle, intended to highlight the role of Ampersand in this cycle. This view
omits many of the uses of the design artifcats generated by Ampersand; instead
it focuses mainly on the primary purpose, which is to help create a finished
software system. 

The contribution of this project is denoted with dashed lines. Note that it is
isolated to a process completely internal to Ampersand. It should not affect the
interface to Ampersand.

%% http://tex.stackexchange.com/questions/165793/how-to-make-a-table-on-more-then-one-page-by-using-the-table-environment
%% Make this table ultra wide so it doesn't take 10 pages...
\begin{tabularx}{1.2\textwidth}{lcX}
\caption{Description of entities present in figure \ref{fig:BusinessProcess}}\\
\toprule
\textbf{Entity} & \textbf{Type} & \textbf{Description} \\[6pt] 
\midrule
\endhead

Real World & Actor & Everything outside of the software system \\[6pt]
Requirements engineers & Actor & \\[6pt]
Ampersand system & Actor & The Ampersand software tool (\ref{sec:Naming}) and
  all of its associated resources. \\[6pt]
Software engineers & Actor & \\[6pt]
ADL File        & Object        & The input to Ampersand, see section \ref{sec:Naming} \\[6pt] 
Real world constraints  & Object & Driving force for software system \\[6pt] 
Finished product  & Object & The finished software system, including supporting documentation and training/services  \\[6pt] 
Business requirements & Object & Important constraints seperated into logical units, see section \ref{sec:Naming} \\[6pt] 
Internal representation & Object & The internal representation on which all
  computations are done; this is never exposed to the outside world directly \\[6pt]
Prototypes & Object & Resource generated by Ampersand \\[6pt]
Data models & Object & Resource generated by Ampersand \\[6pt]
Design documents & Object & Resource generated by Ampersand \\[6pt]
Functional specification & Object & Resource generated by Ampersand \\[6pt]
Distribute product & Process & Physical deployment of software and services \\[6pt]
Reevaluate constraints & Process & Constraints deemed not valid and must be reevaluated \\[6pt]
Interpret constraints & Process & Turn constraints into business requirements \\[6pt]
Formalize & Process & Rewrite something in formal language, usually from natural language \\[6pt]
Reevaluate requirements & Process & Requirements deemed not valid and must be reevaluated \\[6pt]
Verify and compile & Process & Verification consists of typechecking (see \ref{sec:Naming}) \\[6pt]
Automatically fix violations & Process & Insert the necessary code so that
  generated code will not violated business constraints \\[6pt]
Write software & Process & \\[6pt]
Product  fulfills requirements? & Decision & Is the product deemed sufficient or accepted? \\[6pt]
Software matches specification? & Decision & Does the software meet all of the
  requirements set forth by the formal specification? \\[6pt]
Design is feasible? & Decision & Does the software engineer think that the
  design can be implemented in the desired timeframe? \\[6pt]

\bottomrule 
\end{tabularx}

\section{The Scope of the Product}\label{sec:ScopeOfProduct}
\edcomm{JG}{Scope = work that needs to be done to delivery a product}
EFA require formal proofs and documentation that are provable in addition to its implementation; 
the implementation requires the final product to be able to implement an algorithm in Haskell that 
restores rules made by the user (i.e., invariants) and correct any data which have violated these 
rules. A secondary component of this project is the implementation of ECA (Event-Condition 
Action) Rules used for reactive rule-based systems which has the ability to discover and 
systematically repond to triggers for events in a timely manner. 
%TODO{JG}:citeBerstel p.184
\edcomm{YT}{Who is Berstel? Is this reference in our repo?}
Currently, implementation and architecture of ECA rules systems are intensively studied in Active 
Database Management Systems. %TODO{JG}: cite Berstel p. 202
There are various problems that may arise during implementation of the ECA rules translation, 
what those problems may be are unforseeable at this stage of development. Although there may be an 
algorithm for this implementation, we have no been able to find it much less an example of its 
implementation.


\section{Functional Requirements}\label{sec:Functional}
%%TODO: Formatting, elaboration? What else goes here?
%\Subse
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.8\textwidth]{../figures/functional}
	\caption{Diagram of how EFA fits into Ampersand}~\label{fig:figure2}
\end{figure}
%TODO{JG}: Make diagram of EFA
Our functional requirements can be summarized as follows. Our implementation must
\begin{itemize}
\item provably implement the desired algorithm.
\item accept its input in the existing ADL file format.
\item produce an output compatible with the existing pipeline. 
\item be a pure function; it should not have side effects.  
\item not introduce appreciable performance degredation. 
\item provide diagnostic information about the algorithm to
the user, if the user asks for such information.
\end{itemize}
\edcomm{JG}{To YT: I'm sorry I used bullet points, but I needed more before writting this out and 
its 4:30 in the morning, I'm not sure you're available}
\edcomm{YT}{This seems to be a good use of bullet points, because we elaborate
  on our functional requirements below. The above is just a summary.}

\subsubsection*{Explanation of functional requirements template}
%%%%%%%%%%%%%%%%%%%%
\edcomm{JG}{maybe this note should go into glossary or something?}%
\edcomm{YT}{This seems like a good spot. Could you give a touch up this part a
  bit? The first thing ranges from 1 to 5 but there are four named
  'levels'. This is logical inconsistency that will make this document very
  confusing.}%
Customer Satisfaction/Dissatisfaction: 1 to 5 (low to high) \newline
Conflicts: 
	\begin {itemize} 
	\item[$\rightarrow$] none: no existing conflict
	\item[$\rightarrow$] minor: does not affect functionality and can be remodeled to fit into 
	current system 
	\item[$\rightarrow$] medium: requires immediate attention, but can be resolved
	\item[$\rightarrow$] major: severe system conflict with Ampersand and requires alternative 
	implementation
	\end{itemize} 
Priority: 1 to 5 \big(low to high \big)
	\begin{itemize}
	\item[$\rightarrow$] 1 is the lowest, and it can be left out if conflicting with a higher 
	priority 
	item
	\item[$\rightarrow$] 5 is the highest, and it is not something that can be compromised or 
	replaced at any point during product development
	\end{itemize}



\subsection{User Requirement}
\edcomm{YS}{Second Approach}
\edcomm{JG}{Are we choosing or combining?}

{\setlength{\tabcolsep}{12pt} %% Default is 6
\begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
Requirement & U1 \\ 
\midrule
\endhead
Description  & Users of Ampersand shall be able to insert and 
modify ECA rules at any time.  
\\	Rationale & To allow user to change the requirements in accordance to the changing needs.
\\	Originator & Users of Ampersand
\\	Fit Criterion & The Data in the database preserves these rules and maintains consistency.   
\\	Customer Satisfaction & 3 
\\	Priority & 4
\\	Supporting Materials & --- 
\vspace{12pt}
\end{tabularx}
}

\subsection{Product and System Requirement}

{\setlength{\tabcolsep}{12pt} %% Default is 6
\begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
Requirement & S1 \\ 
\midrule
\endhead
Description  & Cohesion of new product into existing system by using Haskell  
\\	Rationale & Necessary for EFA to be added to source code 
\\	Originator & Client/Designers 
\\	Fit Criterion & Able to compile using GHC or Ampersand --haskell function  
\\	Customer Satisfaction & 5 - Highest
\\	Priority & 5 - Highest
\\	Supporting Materials & Ampersand Documentation (Rule Based Design) 
\vspace{12pt}
\end{tabularx}
}


{\setlength{\tabcolsep}{12pt} %% Default is 6
\begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
Requirement & S2 \\ 
\midrule
\endhead
	Description  & Able to recognize and parse input 
	\\	Rationale & Necessary for ECA rules to be added, system needs input 
	\\	Originator & Client/Designers 
	\\	Fit Criterion & Able to take input and passes it out as correct type 
	\\	Customer Satisfaction & 5 - Highest
	\\	Priority & 5 - Highest
	\\	Supporting Materials & Ampersand Documentation (Rule Based Design) 
\vspace{12pt}
\end{tabularx}
}



{\setlength{\tabcolsep}{12pt} %% Default is 6
\begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
Requirement & S3 \\ 
\midrule
\endhead
	Description  & Able to translate input into ECA rules 
	\\	Rationale & Major portion of project and EFA is useless without 
	\\	Originator & Client/Designers 
	\\	Fit Criterion & Outputs ECA rules in proper format for F-Spec (i.e., SQL 
	translator) 
	\\	Customer Satisfaction & 5 - Highest 
	\\	Priority & 5 - Highest 
	\\	Supporting Materials & Rule Based Design; ECA for Web Development %% TODO ref to this?
\vspace{12pt}
\end{tabularx}
}


\chapter{Non-functional Requirements}\label{ch:NonFunc}
Non-functional requirements are fundamental to the success of any product on the market. This type 
of requirement is especially important to this project as it heavily relates the needs of the 
clients to the changes that need to be made to the final product before it is ready for the public. 
The human element guides the principals introduced in non-functional requirements, and for this 
project, it is motivated by a simple perspective. Tools should make a user’s job easier to do, and 
for that to happen the user must be able to under how to use it. 
\edcomm{JG}{How do I pull the tree up to the first page of non-functional?? *facepalm* 
\vspace{-finity} doesnt work}
\edcomm{YT}{LaTeX floats have 'position modifiers'. Generally you should use
  !htb, this works in over 99 percent of case in my experience. Full details of floats and their positioning here:
  https://en.wikibooks.org/wiki/LaTeX/Floats,_Figures_and_Captions }
\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.8\textwidth]{../figures/NONFUNCTIONAL}
	\caption{Tree of non-functional requirements as it relates to EFA}~\label{fig:figure2}
\end{figure}
\section{Usability and Humanity Requirements}\label{sec:Usability}
\paragraph*{}
EFA is built as an internal structure of Ampersand and does not have a graphical interface for 
users. Ampersand uses the command prompt to compile user prototypes which includes various 
graphical representations and webpages. It is very unlikely that users will be able to distinguish 
EFA from Ampersand, it would be similar to someone attempting to distinguish a person’s hand as 
a separate entity from that person. EFA may not look very personable, or user friendly, but it 
will hopefully relieve some frustration and make the user feel more at ease with their design 
because if things do not line up, there is something that can automatically fix it for them. It 
would be another thing users would not have to worry about when designing a new system, this 
feeling of ease could extend to smooth the interactions between the designer and the client as it 
goes through various cycles of overhaul. The user will be notified of any changes that have been 
made to their design and from there Ampersand provides options of how much of the changes the user 
would like to keep, fix themselves, or add to a repository of changes to keep in mind for future 
instances. Thus EFA can return corrections according to what the user specifies.

This product shall be used by any individual who is willing to dedicate the time to learning the 
basics of the Ampersand model and wishes to design an information system. The time it take to learn 
Ampersand is truly up to the user, a normal individual may take anywhere from a week to a month. 
While an engineer who has a strong background in mathematical logic or minor experience in 
programming will be able to use Ampersand efficiently within a week. The most pronounced problem 
concerning Ampersand’s usability is that it’s limited to two languages: English and Dutch. Those 
who are not fluent in neither of these languages will have great difficulty learning the Ampersand 
system.

However, since Ampersand is a successor of CC, \cite[p.10]{RBD}
and similarly it could be used to create consensus between groups of stakeholders with strong 
diverging opinions on the same matter. Once the prototype is generated, it can be presented to 
different individuals who may wish to conduct their own investigation concerning the best course of 
action. After the creation of the prototype, common users are able to manipulate various aspects of 
a project due to an autofill feature. 
\begin{figure}
	\centering
	\includegraphics[width=1.0\textwidth]{../figures/Ampersandmodel}
	\caption{An example of what Ampersand users see when they compile a prototype, each tab and 
	figure they have created can be modified.}~\label{fig:figure3}
\end{figure}

\section{Understandability}
\paragraph*{}
What EFA does is simple to understand, it fixes logical inconsistencies with minimal if any 
input from the user. It looks for contradictions and violations, an overly simplistic but accurate 
example would be: a chair is red, a chair is blue, and there is only one chair. That chair cannot 
be blue and red simultaneously, to fix the problem either another chair is added or one of the 
colour conditions is eliminated. What is eliminated may be based on what is more important for the 
system and the user. In the previous example, if it is most important that there is only one chair, 
then one of the colours statements is erased. Otherwise, EFA could add a new chair, now ever if 
adding a new chair decreases the efficiency of the system because it must keep track of two chairs 
now. It may pick a chair colour depending on another criteria that is not directly part of this 
problem. Such as if most individuals who may use the chair prefer it to be red rather than blue. 
That may be an external condition that Ampersand has been programmed to keep in mind. 
\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{../figures/blueorredchair}
	\caption{Simplistic diagram of decision making process, for full example of decision making 
	process see. Figure 5.}~\label{fig:figure4}
\end{figure}

\section{Performance Requirements}\label{sec:Performance}
\paragraph*{}
Ampersand can efficiently process a large amount of information in a short amount of time, the 
process that EFA requires will be added onto Ampersand’s process time. The duration of time it 
would take to verify data inconsistencies would depend on the complexity of the system design and 
the number of corrections it may take to update the system to a valid prototype according to 
specification. The current upper bound is expected at 120 seconds, or 2 minutes, the correction 
process is terminated if exceeds beyond this threshold for simple Ampersand models. The prototypes 
termed ‘simple models’ are tasks that can be accomplished by an individual within a short amount of 
time, such as selecting the best actor/actress to play lead according to experience and audience 
appeal. Simple models are able to take into consideration not only the task at hand but the context 
and environment to which the task must be completed in. Performance is measured on speed, but also 
on validation of limitations set forth by the user; it will not matter how quickly EFA can do 
something if it does it incorrectly and creates more work for the user. Currently, the 
quantification of the desired accuracy of the results produced is unknown, as EFA is in its 
initial stages. Furthermore, the allowable time between failures is unknown and untested.

EFA can be a great tool, but in case of failure, in the unlikely event that errors are 
propagated through the system and no one through any cycle of development catch it. If the designer 
puts full faith in EFA it could be catastrophic, especially if mistakes are not caught and 
products proceed into the production stage. However, Ampersand possess an internal structure to 
detect inconsistencies and allows for manual correction. EFA although important is not the last 
line of defense, this secondary system greatly minimizes the chances of complete failure. The 
likely if EFA completely fails, is that the secondary system detects errors and compels users to 
manually correct data (\cite[153]{RBD}). 

\begin{figure}
	\centering
	\includegraphics[width=0.5\textwidth]{../figures/Ampersanddecision}
	\caption{This is an example of Ampersand's complete decision process. Source : Rule Based 
	Design}~\label{fig:figure5}
\end{figure}
\section{Operational and Environmental Requirements}\label{sec:Operational}
\paragraph*{}
It is not feasible to predict an accurate workload capacity for EFA for its state, however, 
EFA is made to handle Ampersand loads interactively and is not designed to accumulate stored 
data but rather return the user a modified version of the input they submitted. EFA is meant to 
operate locally within Ampersand, there no limit to the number of users that can use this product. 
Extensive maintenance is not required, although minor adjustments and additions may be necessary 
for further improvement. As Ampersand grows in popularity, it will not be necessary for EFA to 
grow in proportion to Ampersand to remain useful. Due to this it is difficult to determine the 
longevity of this project, as it could remain until the client determines the current model is no 
longer useful. 

Any system that is capable of running Ampersand is automatically compatible with EFA, currently 
those system are limited to Windows OS 7 and up. There are very few physical conditions required to 
maintain EFA and they are the basic conditions required to keep most computer system running. 
This includes minimal moisture, and temperatures no lower than 35 $^{\circ}$ F or 1.7 
$^{\circ}$ C 
as computer hardware of change by flexing 
\edcomm{JG}{Is this common knowledge or does this need a citation?} and 
temperatures preferably no higher than 90 (degree Farenheight) or 32.2 (degree celcius)

\section{Maintainability and Support Requirements}\label{sec:Support}
\paragraph*{}
Maintenance is a key requirement from our clients as non-maintainable code takes far too long to 
decipher and upgrade. The code is required to be well documented and easy to understand so that any 
programmer who wishes to make additions or expand upon what is already there, can do so easily 
without struggle. Well documented code creates a sense of cohesion among individual parties 
participating on the same project. In order to meet the maintainability, EFA must all 
requirements, such that each specification is traceable back to the motivation for its existence 
and the purpose it drives (\cite[2]{derFun}).
Although there are various groups, such as Dr. Joosten and his team who are available to assist 
individuals and businesses with any part of Ampersand, our team believes that given a specific 
enough error message, an individual may not require outside assistance. Moreover, EFA will be 
accompanied with documentation that will have various examples for the user to explore. 
Part of the reason that non-functional requirements as essential to EFA concerns the 
requirements for interfacing with Adjacent Systems. Thus features concerning how implementation is 
done which is normally based on the choice of the designers is a functional requirement when it 
comes to EFA 
  

\section{Security and Integrity Requirements}\label{sec:Security}
\edcomm{JG}{this section includes access requirements: who is authorized to access the product. 
Since its open source, anyone can access or change it, it just wont be part of the official source 
code? We're not dealing with sensitive information (there's no confidentiality breach possible..) I 
mean we could name system function name, and user roles but thats a rather short two sentences
	
	There also specificiation of  requried integrity of databases; this is partially applicable, it 
	applies to Ampersand and how it requires a local database but EFA doesn't.. however, it is 
	part of Ampersand. 
	
	We dont have privacy issues.. do we? 
	Audit requirements --- specification of what the product has to do (work?)
	---- we might need audit requirements I mean we could say that if we fed it standard rules it 
	should be able to recognize, translate and fix easily. like if A (subset) B and B (subset C) 
	then A (subset) C. If a is need for b to function, and b is needed by c to function, then by 
	<insert property name> a is required for c.
	
	Immunity requirements: we dont.. really have security, so immunity is confusing.
	
	
}
\paragraph*{}
As an open source project any individual who clones the Ampersand Github has access to source code 
and can manipulate it as they wish. Irrelevant of what changes the user makes locally, it does not 
effect the Github respository, as only developers of Ampersand \big(i.e., our client \big) has 
permission to change source code in the respository. Access to the database and software which 
supports the various functions of Ampersand are run locally and subjected to the security system 
the user has in place on his or her work station.

\section{Validation and Verification Requirements}\label{sec:Verification}

\edcomm{JG}{ We can distinguish validation from verfication here, like Joosten did, and link how 
validation is required for verification and validation must be done by the user.
		As Joosten specifies that validation is only something that the user can do.. however, does 
		EFA in theory validate the state of the system by fixing inconsistent data? 
		
		Someone help a brother out?What's below cant be all there is}
\paragraph*{}
Validation and verification are important parts of non-functional requirements used to test the 
quality of the final product. Validation is a human activity and requires user input; the rules for 
the software system to follow are provided by the user, and only the user can judge if the rules 
are correct for the system that they are attempting to create. The validation that EFA offers is 
a logical test to confirm that all data sets do not violate the rules that the system follow for 
the model to properly mimic realistic conditions. 

Verification test the accuracy of EFA, and how well it can replicate what the use has in mind 
according to an ECA rule system. Verification is an automated process that confirms correctness 
of the project in accordance to previously validated rules. Furthermore, verification confirms the 
success of ECA rule adoption, and is able to quantify the level of success or failure 
encountered by EFA (\cite{RBD}). 
%TODO{JG}: cite Rule Design (section on verification and validation); then confirm that we can meet 
%these principles or else we need to redefine what these terms are in our project
\section{Legal Requirements}\label{sec:Legal}
The implementation must eventually be included in Ampersand, which is licensed
under GPL3. To comply with this license, all of the implementation code must be
either written by us so we may license it under GPL, or must already be licensed
under GPL, or a compatible license, by its original author. We do not plan to
use existing code, other than as a reference.
\edcomm{YS}{Rephrase this one, I wanted to put forward the idea}%
\edcomm{YT}{I rephrased it more concretely: we have to follow the license agreement of
Ampersand, which appears to be GPL3. That means all the code we include must
either be our own so we can place it under that license, or must already be
under GPL. I don't see any reason we couldn't take code from somewhere if it was
GPL. }%
\chapter{Project Issues}\label{ch:issues}
\section{Open Issues}\label{sec:issues}
N/A\edcomm{YS}{Since we're not concerned with any problem or issues associated with Ampersand.}%
\section{Off-the-Shelf Solutions}\label{sec:solutions}
No off the shelf solutions exist for this project.
\section{New Problems}\label{sec:NewProblems}
N/A\edcomm{YS}{Since we're not concerned with any problem or issues associated with Ampersand.}%
\section{Tasks}\label{sec:Tasks}
\begin{itemize}
\item Analyze and the existing software code base and do an impact analysis of our project on the existing software.
\item Propose a solution to the supervisor and product owner.
\item Implement the solution and provide the  annotated source code to the supervisor and the product owner for a review.
\item Incorporate any changes suggested by them and create a pull request in the main Ampersand repository upon successful completion of the task.
\end{itemize}
\edcomm{YS}{Add in any significant task you feel is worth mentioning}%
\section{Migration to the New Product}\label{sec:Migration}
\paragraph*{}
Upon final review by the client and intensive testing, if the client is
satisfied by the quality of code and its maintainability, the implementation
will be made part of the production stream.  This process is quite simple due to
the nature of the project; the core development team of Ampersand is quite
small, and the project is hosted on GitHub; so our migration will consist of
submitting a pull request to the Ampersand repository.
\section{Risks}\label{sec:Risks}
\begin{itemize}
\item The new code must not introduce any 
errors or performance regressions
into Ampersand.
\item The code must satisfy existing tests and 
additional tests written for the new algorithm being implemented.
\end{itemize}

\section{Costs}\label{sec:Costs}
\paragraph*{}
Currently the Ampersand software system is open source and maintained by Tarski
Systems.  All the software subsystems used in Ampersand are also open
source. There will no change in cost as a result of our implementation. The
client (Tarski Systems) will be responsible for managing the cost of
maintenance of the software in the future. All software used in the development
of EFA (GHC, LaTeX, etc.) are open source as well; there is no cost
requirement for any component used.
\section{User Documentation and Training}\label{sec:UserDoc}
\paragraph*{}
 User documentation will accompany EFA which will give a brief explaination concerning 
how EFA works and how users can use EFA to maximize their efficiency. EFA requires minimal 
input from user, but each possible input will be explained thoroughly and various examples will be 
provided in a step by step tutorial to help familiarze the user with EFA. Furthermore, a 
practice simulation will be in place for the user. The test will include a well documented default 
script which the user can compile to try out different priority options. The manual will include 
pictures as a type of visual guide concerning what the screen should look like from beginning to 
end. The documentation will likely be part of the Ampersand documentation, but for the purposes of 
this project, it will be submitted independently. 

\section{Waiting Room}\label{sec:Waiting}
\section{Ideas for Solutions}\label{sec:Solutions}


\bibliographystyle{alpha}
\bibliography{SRS}
\end{document}










