\documentclass[12pt]{report}
\usepackage{nopageno}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}

\input{../ltx/setupComments}

\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}\begin{center}
\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Software Requirement Specification 
	
	\edinsert{JG}{Version 1}

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill

We acknowledge that this document uses material from the Volere Requirements
Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
Limited.

\vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 9th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history
\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 26 / 09 / 2015 & Initial skeleton version \\\hline
\end{tabular}
\end{center}\end{table}

\tableofcontents
\listoffigures
\listoftables

%% \clearpage

%% Chapter 1: ?? 
\edchange{JG}
{\chapter{Introduction}\label{ch:Intro}}
{\chapter{Project Drivers}\label{ch:Drivers}}

\edchange{JG}
{\section{Project Description}\label{sec:Intro}}
{\section{The Purpose of the Project}\label{sec:Purpose}}

%% 1a. The User Business or Background of the Project Effort
A large part of designing software systems is requirements engineering. One
of the greatest challenges of requirements engineering is translating from
business requirements to a functional specification. Business requirements are
informal, with the intention of being easily understood by humans; however,
functional specifications are written in formal language to properly capture the
attributes of the information system unambiguously. Typically, this translation
of business requirements to a formal specification is done by a requirements
engineer; this can be an error prone process. 

Ampersand is a tool which aims to address this problem in a different way; by
translating business requirements written in natural language into a formal
specification by means of a compilation process. %TODO:ref.
Even though the business requirements and formal specification are written in
entirely different languages, the ``compiler guarantees compliance between the two''. %Ref

Ampersand also provides engineers with a variety of aids which
help them to design products that fulfill all of the needs of their clients and
the end-users; including data models, service cataogues and their
specifications. Requirements engineering is perhaps most important in
safety-critical systems; to this end, Ampersand generates modelling aids and
specifications which are provably correct. %Ref

%% 1b. Goals of the Project 
Ampersand has proven reliable in practical situations, and there have been
efforts to teach this approach to business analysts. A large portion of the
Ampersand system is already in place; the primary focus of this project is to
augment Ampersand with increased capabilities for automation. 

For example, consider a system for ordering products online. Ampersand takes as
an input statements of business requirements like

\begin{quotation}
\noindent{\emph{Every order must have a customer and a list of products; and the total price on
the order must equal the sum of the prices of the products.}}
\end{quotation}

These are translated into, among other things, formal rules concerning how the
information system must react to changes in its state. The information system
may contain a function for manipulating orders. (Ampersand can also generate
prototype software models, including functions types like these, from business
requirements - but this is not the topic of our contribution). For example,

\begin{verbatim}
addToOrder : ( o : Ref Order, t : Product )
\end{verbatim}
\noindent{where \verb|Ref x| represenets the type of references to values of type
\verb|x|; \verb|Order| and \verb|Product| the types of orders and products, respectively.  }

Ampersand can generate pre- and post-conditions for this function, based on the
business requirements. This constitutes a formal specification of the
information system. For example, the above function may have the following specification:

\begin{verbatim}
{ PRE: o.totalCost = t0 } 
addToOrder(o,t): ...
{ POST: o.totalCost = t0 + t.cost } 
\end{verbatim}

It is proven \edcomm{YT}{This is 'proven' because someone told me we have a
  proof/presentation of the algorithm, but not its implementation. Can anyone
  find this? We absolutely need a reference to this.} that for the subset of
processes which Ampersand can support, there is an algorithm which will generate
the necessary code to satisfy the post-conditions (ie, formal specifications) of
each function. However, Ampersand does not yet implement this
algorithm. Currently, a user of Ampersand must manually indicate how each
violation must be corrected.

In the previous example, the implementation of the
function could be as follows: 

\begin{verbatim}
{ PRE: o.totalCost = t0 } 
addToOrder(o,t): 
  o.orders.append(t);
  o.totalCost = o.totalCost + t.cost;
{ POST: o.totalCost = t0 + t.cost } 
\end{verbatim}

The first line includes the item in the order, and the second line fixes the
violation of the post-condition which would occur without it. Currently this
second line would have to be hand-written by the programmer, but the
afformentioned \edcomm{YT}{Should have a name to refer to the algorithm
  somehow?} algorithm can derive it from the business rules. The main
contribution of this project will be to implement the algorithm which generates
the code to fix violations.

\section{The Stakeholders}\label{sec:Stakeholders}
%% From the template:
%% For each type of stakeholder, provide the following information:
%% ● Stakeholder identification (some combination of role/job title, person name, and organization name)
%% ● Knowledge that the project needs from that stakeholder
%% ● The degree of involvement necessary for that stakeholder/knowledge combination
%% ● The degree of influence for that stakeholder/knowledge combination
%% ● Agreement on how to address conflicts between stakeholders who have an interest in the same knowledge
%% This doesn't really seem to fit a list format.. And the majority of these things apply
%% mainly to Ampersand - everyone else only uses Ampersand, the developers of Ampersand
%% themselves also need our code to fit into their project, so they have the majority of the say
%% in how things are done. Namely:
%%    A list of the decisions for which the client will be responsible
%% Most 'decisions' will be made by them. 
%% TODO: Write this section. 

\edcomm{YT}{These are the only real stakeholders I can think of...}
\subsection{Ampersand}\label{subsec:Ampersand}
\subsection{Requirements engineers}\label{subsec:BusReq}
\subsection{Software engineers}\label{subsec:SftwReq}

%% Chapter 2: Project Constraints 
\chapter{Project Constraints}\label{ch:Constraints}
\section{Mandated Constraints}\label{sec:Constraints}

%%%%
%% 4.1 Solution constraints. 
%% We don't have that many, so 'solution constraints' isn't really appropriate.
\subsection{Project philosophy}

Ampersand is an existing software project with a very sizable code base. The
cost of maintaining poorly-written code can be very high and can outweigh the
benefit of the contribution. In order for our code to eventually be merged into
Ampersand, it must be maintable: it must be written according to coding
practices of Ampersand; it must be well documented, so it can be easily
understood by other programmers. 

Similarly, our code must not introduce any errors or performance regressions
into Ampersand. Our code must satisfy existing tests and additional tests should
be written for the new algorithm being implemented. Writing maintainable and
well-documented code will help with this goal as well.


%%3b.
\subsection{Implementation environment}
\subsubsection*{Haskell}
The Ampersand code base is written almost entirely in Haskell. Part of the
prototype software is written in php and javascript %Ref???  but we likely do
not have to interact with this code base. Our code contribution must be entirely
in Haskell.

\subsubsection*{Haskell software}
Ampersand is designed to be used with the Glasgow Haskell Compiler (from here on, GHC) %%REF
and the associated cabal build system. %%Ref
Ampersand also uses many open source Haskell packages, all available on the
Hackage package archive. %% Ref. 
We may not use additional packages. %% Or can we? Maybe if we really needed
                                    %% something, we could ask. But probably not...


\subsubsection*{GitHub}
The Ampersand code base currently lives on GitHub. Our code contributions must
also be on GitHub; this will facilitate easy integration of our code into
Ampersand. This is especially useful if only parts of our code eventually become
integrated into Ampersand - GitHub facilitates this especially. 

\section{Naming Conventions and Terminology}\label{sec:Naming} 
\section{Relevant Facts and Assumptions}\label{sec:Assumptions}

\chapter{Functional Requirements}\label{ch:Functional}
\section{The Scope of the Work}\label{sec:ScopeOfWork}
\section{Business Data Model and Data Dictionary}\label{sec:DataModel}
\section{The Scope of the Product}\label{sec:ScopeOfProduct}
\section{Functional Requirements}\label{sec:Functional}
\chapter{Non-functional Requirements}\label{ch:NonFunc}
\section{Look and Feel Requirements}\label{sec:LookAndFeel} 
\section{Usability and Humanity Requirements}\label{sec:Usability}
\section{Performance Requirements}\label{sec:Performance}
\section{Operational and Environmental Requirements}\label{sec:Operational}
\section{Maintainability and Support Requirements}\label{sec:Support}
\section{Security Requirements}\label{sec:Security}
\section{Cultural Requirements}\label{sec:Cultural}
\section{Legal Requirements}\label{sec:Legal}

\chapter{Project Issues}\label{ch:issues}
\section{Open Issues}\label{sec:issues}
\section{Off-the-Shelf Solutions}\label{sec:solutions}
\section{New Problems}\label{sec:NewProblems}
\section{Tasks}\label{sec:Tasks}
\section{Migration to the New Product}\label{sec:Migration}
\section{Risks}\label{sec:Risks}
\section{Costs}\label{sec:Costs}
\section{User Documentation and Training}\label{sec:UserDoc}
\section{Waiting Room}\label{sec:Waiting}
\section{Ideas for Solutions}\label{sec:Solutions}

\end{document}










