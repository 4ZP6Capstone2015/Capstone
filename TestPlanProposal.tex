\documentclass[12pt]{article}
\usepackage{nopageno}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
%\usepackage{../ltx/edcomms}

%\input{../ltx/setupComments}

\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
%1. Compile a relatively simple but relatively complex ADL script (how about this one?). Don't explain the script yet. Just show the relative simplicity, and that it is a plaintext file.
%2. Explain the system being modeled using the prototype which is generated. Show that real-world constraints are respected by the model (ie, violations from the aforementioned model should cause an error message to be printed).
%3. Briefly explain the other design artifacts generated.
%4. Demo the type system. Explain a bit about it, then compile a few ADL files which have type errors (see ampersand-models/Tests/ShouldFail). Explain the errors if we have to. We want to explain the type system with very simple scripts.
%5. Explain the original ADL file we compiled. Go through line by line and explain what everything means. ADL is a simple declarative languages, we have to say what it is actually declaring (I don't even know this .. some elements of ADL are a mystery to me). To do this, we will need to explain relation algebra, or at least some of it.
%6. Show another ADL file with ExecEngine rules, and show its prototype and how ExecEngine behaves. Explain why ExecEngine is a terrible hack. State that our contribution replaces ExecEngine; and it works completely automatically (ie, user not required to write sql). 
%%
\begin{document}
\title{CS4ZP6 Test Plan \\ Ampersand Tarski Event-Condition-Action 
Rules \\ \vspace{-1ex}} 
\author{\normalsize{Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}}
\date{\normalsize\today \vspace{-3ex}}
\thispagestyle{empty}
\maketitle
\paragraph{}
The focus of the test plan will be to demonstrate the current state of 
Ampersand model prior to the addition of our project and to provide an overview 
of where our project fits into the Ampersand system. Ampersand in its current state is able 
to compile an ADL script and generate a working prototype and supporting artifacts on successful compilation of code.
\newline
\indent We will first compile a simple ADL script in Ampersand to generate a working
information system. At this point, once we've a working information system generated from Ampersand,
it will be easy to understand how the ADL script translates to a model and how by creating violations in the ADL script we can generate errors. After this we'll partly go over the other supporting artifacts generated from Ampersand, lik
Once the audience is aware of the capabilities of Ampersand, we'll be reviewing 
the ADL script to establish that the ADL script is just plain text written in Natural Language that
 describes the system to be.
 We'll explain how the real world constraints are reflected in the ADL script and the information system produced by running that script. Further some violations will be inserted in the ADL script to generate error messages to show what type of violations Ampersand is capable of handling. Once the user is familiar with Ampersand and the artifacts it generates we'll get into the ``how'' of  Ampersand; explaining the ADL script we used. 
 
 At this point the audience will have a good understanding of what Ampersand does, what type of artifacts it is capable of producing and the syntax and semantics of the ADL file. With all the prerequisites in place, we will go ahead and explain where our project (EFA) fits in, into the Ampersand system and how our contribution will change the behavior of Ampersand. The purpose of our project is to automate handling of data violations, we'll explain what these violations are, how the current system reacts to these violations and how our project will change the way Ampersand will handle these violations.
 
\newline
\indent The purpose of the EFA project is to automate the correction of a 
particular 
class of violations that restores invariants with in the Ampersand system. 
These violations come from the misuse of PAClauses (Process Algebra Clauses); 
PAClauses are datatypes formed from ECA (Event-Condition Action) rules used to 
represent the structure of an active database system. In Ampersand, these ECA 
rules are decomposed to their most basic forms which we call, Atoms. Atoms are 
the simplest possible form a rule can take before losing its meaning. From 
here, a Haskell program (i.e., EFA) will automate the correction of violations 
by detecting contradictions between Atoms imposed on datasets. For example, one 
Atom can state that all entities in its set must be blue, another Atom states 
that all entities in its set must be red. The intersection between these two 
Atoms is red AND blue, if the user inserts something in the intersection of red 
and blue that is not red and blue, it is a violation of both atoms. A quick fix 
to restore both rules would be to remove the entity that is not red or blue 
from the intersection of the red and blue set. 
\newline
\indent EFA is in its initial stages of development, and at this time it is 
difficult 
to provide a rigorous guide as to how this project will proceed. The first step 
was to figure out the particular classes of violations and the most 
conventional ways they are triggered. From there the developers of Ampersand 
have provided a partial algorithm for how individual violations can be 
restored. Foreseeable issues include not having a complete algorithm to 
implement on complex system such as Ampersand, in addition to figuring out how 
to fix violations that may cycle within itself.

\end{document}










