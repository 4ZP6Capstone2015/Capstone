<?php
// module Generics.php generated by Generate.hs
// Ampersand v3.2.0[master:4b6fc5c*], build time: 06-Nov-15 20:29:59 Ame


$versionInfo = 'Ampersand v3.2.0[master:4b6fc5c*], build time: 06-Nov-15 20:29:59 Ame';

$contextName = 'ProjectAdministration';

$dbName =  isset($isValidationSession) && $isValidationSession ? 'ampersand_temporaryeditvalidationdb' : 'ampersand_projectadministration';
// If this script is called with $isValidationSession == true, use the temporary db name instead of the normal one.

$signalTableName = '__all_signals__';

$isDev = false;

$autoRefreshInterval = '0';

$allDBstructQueries =
  array ( 'CREATE TABLE "__SessionTimeout__"
            ( "SESSION" VARCHAR(255) UNIQUE NOT NULL
            , "lastAccess" BIGINT NOT NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , 'CREATE TABLE "__History__"
            ( "Seconds" VARCHAR(255) DEFAULT NULL
            , "Date" VARCHAR(255) DEFAULT NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , 'INSERT INTO "__History__" ("Seconds","Date")
            VALUES (UNIX_TIMESTAMP(NOW(6)), NOW(6))'
        , 'CREATE TABLE "__all_signals__"
            ( "conjId" VARCHAR(255) NOT NULL
            , "src" VARCHAR(255) NOT NULL
            , "tgt" VARCHAR(255) NOT NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ---------------------------------------------
           -- Plug Project
           -- 
           -- fields:
           -- I[Project]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- projectName  [UNI,TOT]
           -- projectStatus  [UNI]
           -- projectDescription  [UNI]
           -- projectStartDate  [UNI]
           -- projectStarted  [SYM,ASY,UNI,INJ]
           -- ---------------------------------------------
           CREATE TABLE "Project"
            ( "Project" VARCHAR(255)  DEFAULT NULL
            , "tgt_projectName" VARCHAR(255)  DEFAULT NULL
            , "tgt_projectStatus" VARCHAR(255)  DEFAULT NULL
            , "tgt_projectDescription" TEXT  DEFAULT NULL
            , "tgt_projectStartDate" DATE  DEFAULT NULL
            , "tgt_projectStarted" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("Project")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ------------------------------------------------
           -- Plug Assignment
           -- 
           -- fields:
           -- I[Assignment]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- project  [UNI,TOT]
           -- assignee  [UNI,TOT]
           -- pplStartDate  [UNI]
           -- pplStarted  [SYM,ASY,UNI,INJ]
           -- ------------------------------------------------
           CREATE TABLE "Assignment"
            ( "Assignment" VARCHAR(255)  DEFAULT NULL
            , "tgt_project" VARCHAR(255)  DEFAULT NULL
            , "tgt_assignee" VARCHAR(255)  DEFAULT NULL
            , "tgt_pplStartDate" DATE  DEFAULT NULL
            , "tgt_pplStarted" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("Assignment")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- --------------------------------------------
           -- Plug Person
           -- 
           -- fields:
           -- I[Person]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- personName  [UNI]
           -- personStatus  [UNI]
           -- personEmail  [UNI,TOT]
           -- --------------------------------------------
           CREATE TABLE "Person"
            ( "Person" VARCHAR(255)  DEFAULT NULL
            , "tgt_personName" VARCHAR(255)  DEFAULT NULL
            , "tgt_personStatus" VARCHAR(255)  DEFAULT NULL
            , "tgt_personEmail" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("Person")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ---------------------------------------------
           -- Plug SESSION
           -- 
           -- fields:
           -- I[SESSION]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- ---------------------------------------------
           CREATE TABLE "SESSION"
            ( "SESSION" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("SESSION")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- --------------------------------------------------
           -- Plug PersonStatus
           -- 
           -- fields:
           -- I[PersonStatus]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- --------------------------------------------------
           CREATE TABLE "PersonStatus"
            ( "PersonStatus" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("PersonStatus")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ------------------------------------------------
           -- Plug PersonName
           -- 
           -- fields:
           -- I[PersonName]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- ------------------------------------------------
           CREATE TABLE "PersonName"
            ( "PersonName" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("PersonName")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ------------------------------------------
           -- Plug Date
           -- 
           -- fields:
           -- I[Date]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- ------------------------------------------
           CREATE TABLE "Date"
            ( "Date" DATE  DEFAULT NULL
            , PRIMARY KEY ("Date")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- -------------------------------------------------
           -- Plug Description
           -- 
           -- fields:
           -- I[Description]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- -------------------------------------------------
           CREATE TABLE "Description"
            ( "Description" TEXT  DEFAULT NULL
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ---------------------------------------------------
           -- Plug ProjectStatus
           -- 
           -- fields:
           -- I[ProjectStatus]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- ---------------------------------------------------
           CREATE TABLE "ProjectStatus"
            ( "ProjectStatus" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("ProjectStatus")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- -------------------------------------------
           -- Plug Email
           -- 
           -- fields:
           -- I[Email]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- -------------------------------------------
           CREATE TABLE "Email"
            ( "Email" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("Email")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- -------------------------------------------------
           -- Plug ProjectName
           -- 
           -- fields:
           -- I[ProjectName]  [UNI,TOT,INJ,SUR,SYM,ASY,TRN,RFX]
           -- -------------------------------------------------
           CREATE TABLE "ProjectName"
            ( "ProjectName" VARCHAR(255)  DEFAULT NULL
            , PRIMARY KEY ("ProjectName")
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- ------------------------
           -- Plug pl
           -- 
           -- fields:
           -- I[Project] /\\ pl;pl~  []
           -- pl  []
           -- ------------------------
           CREATE TABLE "pl"
            ( "Project" VARCHAR(255)  DEFAULT NULL
            , "Person" VARCHAR(255)  DEFAULT NULL
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- --------------------------------
           -- Plug member
           -- 
           -- fields:
           -- I[Project] /\\ member;member~  []
           -- member  []
           -- --------------------------------
           CREATE TABLE "member"
            ( "Project" VARCHAR(255)  DEFAULT NULL
            , "Person" VARCHAR(255)  DEFAULT NULL
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , '-- -------------------------------------
           -- Plug workswith
           -- 
           -- fields:
           -- I[Person] /\\ workswith;workswith~  []
           -- workswith  []
           -- -------------------------------------
           CREATE TABLE "workswith"
            ( "SrcPerson" VARCHAR(255)  DEFAULT NULL
            , "TgtPerson" VARCHAR(255)  DEFAULT NULL
            , "ts_insert" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            , "ts_update" TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NULL
            ) ENGINE=InnoDB DEFAULT CHARACTER SET UTF8 COLLATE UTF8_BIN'
        , 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE'
        );

$allDefPopQueries =
  array ( 'INSERT INTO "__all_signals__"
              ("conjId", "src", "tgt")
           VALUES (\'conj_0\', \'\\\'p10001\\\'\', \'\\\'p10002\\\'\')
                , (\'conj_0\', \'\\\'p10001\\\'\', \'\\\'p10003\\\'\')
                , (\'conj_0\', \'\\\'p10001\\\'\', \'\\\'p10004\\\'\')
                , (\'conj_0\', \'\\\'p10001\\\'\', \'\\\'p10005\\\'\')
                , (\'conj_0\', \'\\\'p10001\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_0\', \'\\\'p10002\\\'\', \'\\\'p10001\\\'\')
                , (\'conj_0\', \'\\\'p10002\\\'\', \'\\\'p10003\\\'\')
                , (\'conj_0\', \'\\\'p10002\\\'\', \'\\\'p10005\\\'\')
                , (\'conj_0\', \'\\\'p10002\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_0\', \'\\\'p10003\\\'\', \'\\\'p10001\\\'\')
                , (\'conj_0\', \'\\\'p10003\\\'\', \'\\\'p10002\\\'\')
                , (\'conj_0\', \'\\\'p10003\\\'\', \'\\\'p10004\\\'\')
                , (\'conj_0\', \'\\\'p10003\\\'\', \'\\\'p10005\\\'\')
                , (\'conj_0\', \'\\\'p10003\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_0\', \'\\\'p10004\\\'\', \'\\\'p10001\\\'\')
                , (\'conj_0\', \'\\\'p10004\\\'\', \'\\\'p10003\\\'\')
                , (\'conj_0\', \'\\\'p10004\\\'\', \'\\\'p10005\\\'\')
                , (\'conj_0\', \'\\\'p10004\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_0\', \'\\\'p10005\\\'\', \'\\\'p10001\\\'\')
                , (\'conj_0\', \'\\\'p10005\\\'\', \'\\\'p10002\\\'\')
                , (\'conj_0\', \'\\\'p10005\\\'\', \'\\\'p10003\\\'\')
                , (\'conj_0\', \'\\\'p10005\\\'\', \'\\\'p10004\\\'\')
                , (\'conj_0\', \'\\\'p10005\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_0\', \'\\\'p10006\\\'\', \'\\\'p10008\\\'\')
                , (\'conj_0\', \'\\\'p10006\\\'\', \'\\\'p10009\\\'\')
                , (\'conj_0\', \'\\\'p10006\\\'\', \'\\\'p10010\\\'\')
                , (\'conj_0\', \'\\\'p10008\\\'\', \'\\\'p10006\\\'\')
                , (\'conj_0\', \'\\\'p10008\\\'\', \'\\\'p10009\\\'\')
                , (\'conj_0\', \'\\\'p10008\\\'\', \'\\\'p10010\\\'\')
                , (\'conj_0\', \'\\\'p10009\\\'\', \'\\\'p10006\\\'\')
                , (\'conj_0\', \'\\\'p10009\\\'\', \'\\\'p10008\\\'\')
                , (\'conj_0\', \'\\\'p10009\\\'\', \'\\\'p10010\\\'\')
                , (\'conj_0\', \'\\\'p10010\\\'\', \'\\\'p10006\\\'\')
                , (\'conj_0\', \'\\\'p10010\\\'\', \'\\\'p10008\\\'\')
                , (\'conj_0\', \'\\\'p10010\\\'\', \'\\\'p10009\\\'\')
                , (\'conj_0\', \'\\\'p10012\\\'\', \'\\\'p10001\\\'\')
                , (\'conj_0\', \'\\\'p10012\\\'\', \'\\\'p10002\\\'\')
                , (\'conj_0\', \'\\\'p10012\\\'\', \'\\\'p10003\\\'\')
                , (\'conj_0\', \'\\\'p10012\\\'\', \'\\\'p10004\\\'\')
                , (\'conj_0\', \'\\\'p10012\\\'\', \'\\\'p10005\\\'\')
                , (\'conj_16\', \'\\\'1970.13\\\'\', \'\\\'p10008\\\'\')
                , (\'conj_16\', \'\\\'2013.01\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_16\', \'\\\'2014.01\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_16\', \'\\\'2014.03\\\'\', \'\\\'p10012\\\'\')
                , (\'conj_16\', \'\\\'2014.04\\\'\', \'\\\'p10011\\\'\')
                , (\'conj_16\', \'\\\'2014.05\\\'\', \'\\\'p10007\\\'\')'
        , 'INSERT INTO "Project"
              ("Project", "tgt_projectName", "tgt_projectStatus", "tgt_projectDescription", "tgt_projectStartDate", "tgt_projectStarted")
           VALUES (\'2013.01\', \'Alfa board\', \'completed\', \'Create an Alpha board for the customer\', \'2013-12-31\', \'2013.01\')
                , (\'2014.01\', \'Beta board\', \'under way\', \'further development of the board to Beta\', \'2014-02-15\', \'2014.01\')
                , (\'2014.03\', \'Release board\', NULL, \'Make board production-ready\', \'2014-07-15\', NULL)
                , (\'2014.04\', \'Odysseus\', NULL, \'Research how to destroy Troje.\', NULL, NULL)
                , (\'2014.05\', \'Argos\', NULL, \'get the Golden Fleece\', NULL, \'2014.05\')
                , (\'1970.13\', \'Apollo 13\', \'Succes\', \'Joosten, get us back to earth please!\', \'1970-04-17\', \'1970.13\')'
        , 'INSERT INTO "Person"
              ("Person", "tgt_personName", "tgt_personStatus", "tgt_personEmail")
           VALUES (\'p10001\', \'A. Arends\', \'has left the company\', \'arends@example.com\')
                , (\'p10002\', \'B. Billekens\', NULL, \'billekens@example.com\')
                , (\'p10003\', \'C. Curly\', \'maternity leave\', \'curly@example.com\')
                , (\'p10004\', \'D. Diskstation\', \'has left the company\', \'diskstation@example.com\')
                , (\'p10005\', \'E. Evernote\', NULL, \'evernote@example.com\')
                , (\'p10006\', \'F. Haise\', NULL, \'jlovell@example.com\')
                , (\'p10007\', \'J. Ason\', NULL, \'j.ason@example.com\')
                , (\'p10008\', \'J. Lovell\', NULL, \'l.lovell@example.com\')
                , (\'p10009\', \'J. Swigert\', NULL, \'j.swigert@example.com\')
                , (\'p10010\', \'K. Mattingly\', NULL, \'k.mattingly@example.com\')
                , (\'p10011\', \'O. Dysseus\', \'is on sabbatical until 4th of July\', \'o.dysseus@example.com\')
                , (\'p10012\', \'P. Leider\', NULL, \'pleider@example.com\')'
        , 'INSERT INTO "PersonStatus"
              ("PersonStatus")
           VALUES (\'has left the company\')
                , (\'maternity leave\')
                , (\'is on sabbatical until 4th of July\')'
        , 'INSERT INTO "PersonName"
              ("PersonName")
           VALUES (\'A. Arends\')
                , (\'B. Billekens\')
                , (\'C. Curly\')
                , (\'D. Diskstation\')
                , (\'E. Evernote\')
                , (\'F. Haise\')
                , (\'J. Ason\')
                , (\'J. Lovell\')
                , (\'J. Swigert\')
                , (\'K. Mattingly\')
                , (\'O. Dysseus\')
                , (\'P. Leider\')'
        , 'INSERT INTO "Date"
              ("Date")
           VALUES (\'2013-12-31\')
                , (\'2014-02-15\')
                , (\'2014-07-15\')
                , (\'1970-04-17\')'
        , 'INSERT INTO "Description"
              ("Description")
           VALUES (\'Create an Alpha board for the customer\')
                , (\'further development of the board to Beta\')
                , (\'Make board production-ready\')
                , (\'Research how to destroy Troje.\')
                , (\'get the Golden Fleece\')
                , (\'Joosten, get us back to earth please!\')'
        , 'INSERT INTO "ProjectStatus"
              ("ProjectStatus")
           VALUES (\'completed\')
                , (\'under way\')
                , (\'Succes\')'
        , 'INSERT INTO "Email"
              ("Email")
           VALUES (\'arends@example.com\')
                , (\'billekens@example.com\')
                , (\'curly@example.com\')
                , (\'diskstation@example.com\')
                , (\'evernote@example.com\')
                , (\'jlovell@example.com\')
                , (\'j.ason@example.com\')
                , (\'l.lovell@example.com\')
                , (\'j.swigert@example.com\')
                , (\'k.mattingly@example.com\')
                , (\'o.dysseus@example.com\')
                , (\'pleider@example.com\')'
        , 'INSERT INTO "ProjectName"
              ("ProjectName")
           VALUES (\'Alfa board\')
                , (\'Beta board\')
                , (\'Release board\')
                , (\'Odysseus\')
                , (\'Argos\')
                , (\'Apollo 13\')'
        , 'INSERT INTO "pl"
              ("Project", "Person")
           VALUES (\'1970.13\', \'p10008\')
                , (\'2013.01\', \'p10012\')
                , (\'2014.01\', \'p10012\')
                , (\'2014.03\', \'p10012\')
                , (\'2014.04\', \'p10011\')
                , (\'2014.05\', \'p10007\')'
        , 'INSERT INTO "member"
              ("Project", "Person")
           VALUES (\'1970.13\', \'p10010\')
                , (\'1970.13\', \'p10006\')
                , (\'1970.13\', \'p10009\')
                , (\'2013.01\', \'p10003\')
                , (\'2013.01\', \'p10002\')
                , (\'2013.01\', \'p10001\')
                , (\'2014.01\', \'p10005\')
                , (\'2014.01\', \'p10004\')
                , (\'2014.01\', \'p10003\')
                , (\'2014.01\', \'p10001\')
                , (\'2014.03\', \'p10005\')
                , (\'2014.03\', \'p10003\')
                , (\'2014.03\', \'p10002\')'
        );

$allSpecializations = // transitive, so including specializations of specializations
  array
    ();

$allRelations =
  array
    ( 'rel_projectName_Project_ProjectName' => array ( 'name'       => 'projectName', 'srcConcept' => 'Project', 'tgtConcept' => 'ProjectName', 'table'      => 'Project', 'srcCol'     => 'Project', 'tgtCol'     => 'tgt_projectName', 'affectedInvConjunctIds' => array ('conj_14', 'conj_25'), 'affectedSigConjunctIds' => array ())
    , 'rel_projectStatus_Project_ProjectStatus' => array ( 'name'       => 'projectStatus', 'srcConcept' => 'Project', 'tgtConcept' => 'ProjectStatus', 'table'      => 'Project', 'srcCol'     => 'Project', 'tgtCol'     => 'tgt_projectStatus', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_projectDescription_Project_Description' => array ( 'name'       => 'projectDescription', 'srcConcept' => 'Project', 'tgtConcept' => 'Description', 'table'      => 'Project', 'srcCol'     => 'Project', 'tgtCol'     => 'tgt_projectDescription', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_projectStartDate_Project_Date' => array ( 'name'       => 'projectStartDate', 'srcConcept' => 'Project', 'tgtConcept' => 'Date', 'table'      => 'Project', 'srcCol'     => 'Project', 'tgtCol'     => 'tgt_projectStartDate', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_projectStarted_Project_Project' => array ( 'name'       => 'projectStarted', 'srcConcept' => 'Project', 'tgtConcept' => 'Project', 'table'      => 'Project', 'srcCol'     => 'Project', 'tgtCol'     => 'tgt_projectStarted', 'affectedInvConjunctIds' => array ('conj_19'), 'affectedSigConjunctIds' => array ())
    , 'rel_pl_Project_Person' => array ( 'name'       => 'pl', 'srcConcept' => 'Project', 'tgtConcept' => 'Person', 'table'      => 'pl', 'srcCol'     => 'Project', 'tgtCol'     => 'Person', 'affectedInvConjunctIds' => array ('conj_17'), 'affectedSigConjunctIds' => array ('conj_0', 'conj_16', 'conj_17', 'conj_20', 'conj_24', 'conj_6'))
    , 'rel_member_Project_Person' => array ( 'name'       => 'member', 'srcConcept' => 'Project', 'tgtConcept' => 'Person', 'table'      => 'member', 'srcCol'     => 'Project', 'tgtCol'     => 'Person', 'affectedInvConjunctIds' => array ('conj_17'), 'affectedSigConjunctIds' => array ('conj_0', 'conj_17', 'conj_20', 'conj_6'))
    , 'rel_personName_Person_PersonName' => array ( 'name'       => 'personName', 'srcConcept' => 'Person', 'tgtConcept' => 'PersonName', 'table'      => 'Person', 'srcCol'     => 'Person', 'tgtCol'     => 'tgt_personName', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_personStatus_Person_PersonStatus' => array ( 'name'       => 'personStatus', 'srcConcept' => 'Person', 'tgtConcept' => 'PersonStatus', 'table'      => 'Person', 'srcCol'     => 'Person', 'tgtCol'     => 'tgt_personStatus', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_personEmail_Person_Email' => array ( 'name'       => 'personEmail', 'srcConcept' => 'Person', 'tgtConcept' => 'Email', 'table'      => 'Person', 'srcCol'     => 'Person', 'tgtCol'     => 'tgt_personEmail', 'affectedInvConjunctIds' => array ('conj_12', 'conj_23'), 'affectedSigConjunctIds' => array ())
    , 'rel_workswith_Person_Person' => array ( 'name'       => 'workswith', 'srcConcept' => 'Person', 'tgtConcept' => 'Person', 'table'      => 'workswith', 'srcCol'     => 'SrcPerson', 'tgtCol'     => 'TgtPerson', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ('conj_0', 'conj_20'))
    , 'rel_project_Assignment_Project' => array ( 'name'       => 'project', 'srcConcept' => 'Assignment', 'tgtConcept' => 'Project', 'table'      => 'Assignment', 'srcCol'     => 'Assignment', 'tgtCol'     => 'tgt_project', 'affectedInvConjunctIds' => array ('conj_22'), 'affectedSigConjunctIds' => array ('conj_16', 'conj_6'))
    , 'rel_assignee_Assignment_Person' => array ( 'name'       => 'assignee', 'srcConcept' => 'Assignment', 'tgtConcept' => 'Person', 'table'      => 'Assignment', 'srcCol'     => 'Assignment', 'tgtCol'     => 'tgt_assignee', 'affectedInvConjunctIds' => array ('conj_21'), 'affectedSigConjunctIds' => array ('conj_16', 'conj_6'))
    , 'rel_pplStartDate_Assignment_Date' => array ( 'name'       => 'pplStartDate', 'srcConcept' => 'Assignment', 'tgtConcept' => 'Date', 'table'      => 'Assignment', 'srcCol'     => 'Assignment', 'tgtCol'     => 'tgt_pplStartDate', 'affectedInvConjunctIds' => array (), 'affectedSigConjunctIds' => array ())
    , 'rel_pplStarted_Assignment_Assignment' => array ( 'name'       => 'pplStarted', 'srcConcept' => 'Assignment', 'tgtConcept' => 'Assignment', 'table'      => 'Assignment', 'srcCol'     => 'Assignment', 'tgtCol'     => 'tgt_pplStarted', 'affectedInvConjunctIds' => array ('conj_18'), 'affectedSigConjunctIds' => array ())
    );

$allConcepts = array
  ( 'Project' => array
      ( 'affectedInvConjunctIds' => array ('conj_14', 'conj_17', 'conj_19', 'conj_22', 'conj_25', 'conj_27')
      , 'affectedSigConjunctIds' => array ('conj_0', 'conj_16', 'conj_17', 'conj_20', 'conj_24', 'conj_6')
      , 'conceptTables' => array
         ( array ( 'table' => 'Project', 'cols' => array ('Project') )
         )
      , 'type' => 'OBJECT'
      , 'specializations' => array ()
      , 'defaultViewId'   => 'Projects'
      )
  , 'ProjectName' => array
      ( 'affectedInvConjunctIds' => array ('conj_14', 'conj_25')
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'ProjectName', 'cols' => array ('ProjectName') )
         )
      , 'type' => 'ALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'Person' => array
      ( 'affectedInvConjunctIds' => array ('conj_12', 'conj_17', 'conj_21', 'conj_23')
      , 'affectedSigConjunctIds' => array ('conj_0', 'conj_16', 'conj_17', 'conj_20', 'conj_24', 'conj_6')
      , 'conceptTables' => array
         ( array ( 'table' => 'Person', 'cols' => array ('Person') )
         )
      , 'type' => 'OBJECT'
      , 'specializations' => array ()
      , 'defaultViewId'   => 'People'
      )
  , 'Email' => array
      ( 'affectedInvConjunctIds' => array ('conj_12', 'conj_23')
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'Email', 'cols' => array ('Email') )
         )
      , 'type' => 'ALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'Assignment' => array
      ( 'affectedInvConjunctIds' => array ('conj_18', 'conj_21', 'conj_22', 'conj_26')
      , 'affectedSigConjunctIds' => array ('conj_16', 'conj_6')
      , 'conceptTables' => array
         ( array ( 'table' => 'Assignment', 'cols' => array ('Assignment') )
         )
      , 'type' => 'OBJECT'
      , 'specializations' => array ()
      )
  , 'ProjectStatus' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'ProjectStatus', 'cols' => array ('ProjectStatus') )
         )
      , 'type' => 'ALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'Description' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'Description', 'cols' => array ('Description') )
         )
      , 'type' => 'BIGALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'Date' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'Date', 'cols' => array ('Date') )
         )
      , 'type' => 'DATE'
      , 'specializations' => array ()
      )
  , 'PersonName' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'PersonName', 'cols' => array ('PersonName') )
         )
      , 'type' => 'ALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'PersonStatus' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'PersonStatus', 'cols' => array ('PersonStatus') )
         )
      , 'type' => 'ALPHANUMERIC'
      , 'specializations' => array ()
      )
  , 'ONE' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ()
      , 'type' => 'TYPEOFONE'
      , 'specializations' => array ()
      )
  , 'SESSION' => array
      ( 'affectedInvConjunctIds' => array ()
      , 'affectedSigConjunctIds' => array ()
      , 'conceptTables' => array
         ( array ( 'table' => 'SESSION', 'cols' => array ('SESSION') )
         )
      , 'type' => 'OBJECT'
      , 'specializations' => array ()
      )
  );

$tableColumnInfo =
  array
    ( 'Project' =>
        array
          ( 'Project' => array ( 'concept' => 'Project', 'unique' => true, 'null' => false)
          , 'tgt_projectName' => array ( 'concept' => 'ProjectName', 'unique' => false, 'null' => true)
          , 'tgt_projectStatus' => array ( 'concept' => 'ProjectStatus', 'unique' => false, 'null' => true)
          , 'tgt_projectDescription' => array ( 'concept' => 'Description', 'unique' => false, 'null' => true)
          , 'tgt_projectStartDate' => array ( 'concept' => 'Date', 'unique' => false, 'null' => true)
          , 'tgt_projectStarted' => array ( 'concept' => 'Project', 'unique' => true, 'null' => true)
          )
    , 'Assignment' =>
        array
          ( 'Assignment' => array ( 'concept' => 'Assignment', 'unique' => true, 'null' => false)
          , 'tgt_project' => array ( 'concept' => 'Project', 'unique' => false, 'null' => true)
          , 'tgt_assignee' => array ( 'concept' => 'Person', 'unique' => false, 'null' => true)
          , 'tgt_pplStartDate' => array ( 'concept' => 'Date', 'unique' => false, 'null' => true)
          , 'tgt_pplStarted' => array ( 'concept' => 'Assignment', 'unique' => true, 'null' => true)
          )
    , 'Person' =>
        array
          ( 'Person' => array ( 'concept' => 'Person', 'unique' => true, 'null' => false)
          , 'tgt_personName' => array ( 'concept' => 'PersonName', 'unique' => false, 'null' => true)
          , 'tgt_personStatus' => array ( 'concept' => 'PersonStatus', 'unique' => false, 'null' => true)
          , 'tgt_personEmail' => array ( 'concept' => 'Email', 'unique' => false, 'null' => true)
          )
    , 'SESSION' =>
        array
          ( 'SESSION' => array ( 'concept' => 'SESSION', 'unique' => true, 'null' => false)
          )
    , 'PersonStatus' =>
        array
          ( 'PersonStatus' => array ( 'concept' => 'PersonStatus', 'unique' => true, 'null' => false)
          )
    , 'PersonName' =>
        array
          ( 'PersonName' => array ( 'concept' => 'PersonName', 'unique' => true, 'null' => false)
          )
    , 'Date' =>
        array
          ( 'Date' => array ( 'concept' => 'Date', 'unique' => true, 'null' => false)
          )
    , 'Description' =>
        array
          ( 'Description' => array ( 'concept' => 'Description', 'unique' => true, 'null' => false)
          )
    , 'ProjectStatus' =>
        array
          ( 'ProjectStatus' => array ( 'concept' => 'ProjectStatus', 'unique' => true, 'null' => false)
          )
    , 'Email' =>
        array
          ( 'Email' => array ( 'concept' => 'Email', 'unique' => true, 'null' => false)
          )
    , 'ProjectName' =>
        array
          ( 'ProjectName' => array ( 'concept' => 'ProjectName', 'unique' => true, 'null' => false)
          )
    , 'pl' =>
        array
          ( 'Project' => array ( 'concept' => 'Project', 'unique' => false, 'null' => false)
          , 'Person' => array ( 'concept' => 'Person', 'unique' => false, 'null' => false)
          )
    , 'member' =>
        array
          ( 'Project' => array ( 'concept' => 'Project', 'unique' => false, 'null' => false)
          , 'Person' => array ( 'concept' => 'Person', 'unique' => false, 'null' => false)
          )
    , 'workswith' =>
        array
          ( 'SrcPerson' => array ( 'concept' => 'Person', 'unique' => false, 'null' => false)
          , 'TgtPerson' => array ( 'concept' => 'Person', 'unique' => false, 'null' => false)
          )
    );

$allRules =
  array
    ( 'ASY pplStarted::Assignment*Assignment' =>
        array ( 'name'          => 'ASY pplStarted::Assignment*Assignment'
              , 'ruleAdl'       => 'pplStarted~ /\\ pplStarted |- I[Assignment]'
              , 'origin'        => 'line 61:1, file ProjectAdministration.adl'
              , 'meaning'       => 'pplStarted[Assignment] is antisymmetric'
              , 'message'       => 'pplStarted[Assignment] is not antisymmetric'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_18')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'ASY projectStarted::Project*Project' =>
        array ( 'name'          => 'ASY projectStarted::Project*Project'
              , 'ruleAdl'       => 'projectStarted~ /\\ projectStarted |- I[Project]'
              , 'origin'        => 'line 39:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStarted[Project] is antisymmetric'
              , 'message'       => 'projectStarted[Project] is not antisymmetric'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_19')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Create Assignment' =>
        array ( 'name'          => 'Create Assignment'
              , 'ruleAdl'       => 'pl |- project~;assignee'
              , 'origin'        => 'line 114:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_16')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'NewStruct;Assignment')
                    , array ( 'segmentType' => 'Text', 'Text' => ';project;Assignment;_NEW;Project;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Project'
                            , 'expSQL' =>
                                '/* I[Project] */
                                 select
                                 distinct
                                        "Project" as src, "Project" as tgt
                                 from "Project"
                                 where "Project" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';assignee;Assignment;_NEW;Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';pplStartDate;Assignment;_NEW;Date;{php}date(DATE_ISO8601)')
                    )
              )
    , 'Delete Assignment' =>
        array ( 'name'          => 'Delete Assignment'
              , 'ruleAdl'       => 'project~;assignee |- pl \\/ member'
              , 'origin'        => 'line 123:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_6')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'DelAtom;Assignment;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Project'
                            , 'expSQL' =>
                                '/* I[Project] */
                                 select
                                 distinct
                                        "Project" as src, "Project" as tgt
                                 from "Project"
                                 where "Project" IS NOT NULL'
                            )
                    )
              )
    , 'Every project must have a projectleader' =>
        array ( 'name'          => 'Every project must have a projectleader'
              , 'ruleAdl'       => 'I[Project] |- pl;pl~'
              , 'origin'        => 'line 86:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => 'Every project must have a projectleader'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_24')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'Project \'')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Project'
                            , 'expSQL' =>
                                '/* I[Project] */
                                 select
                                 distinct
                                        "Project" as src, "Project" as tgt
                                 from "Project"
                                 where "Project" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => '\' does not have a projectleader')
                    )
              )
    , 'INJ pplStarted::Assignment*Assignment' =>
        array ( 'name'          => 'INJ pplStarted::Assignment*Assignment'
              , 'ruleAdl'       => 'pplStarted;pplStarted~ |- I[Assignment]'
              , 'origin'        => 'line 61:1, file ProjectAdministration.adl'
              , 'meaning'       => 'pplStarted[Assignment\\*Assignment] is injective'
              , 'message'       => 'pplStarted[Assignment\\*Assignment] is not injective'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_13')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'INJ projectStarted::Project*Project' =>
        array ( 'name'          => 'INJ projectStarted::Project*Project'
              , 'ruleAdl'       => 'projectStarted;projectStarted~ |- I[Project]'
              , 'origin'        => 'line 39:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStarted[Project\\*Project] is injective'
              , 'message'       => 'projectStarted[Project\\*Project] is not injective'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_15')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'People are identifiable by their email-address' =>
        array ( 'name'          => 'People are identifiable by their email-address'
              , 'ruleAdl'       => 'personEmail;personEmail~ |- I[Person]'
              , 'origin'        => 'line 76:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_12')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Project leaders are not considered members of the projects they lead.' =>
        array ( 'name'          => 'Project leaders are not considered members of the projects they lead.'
              , 'ruleAdl'       => 'pl |- -member'
              , 'origin'        => 'line 80:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_17')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Projectleaders are not members of a team' =>
        array ( 'name'          => 'Projectleaders are not members of a team'
              , 'ruleAdl'       => 'pl |- -member'
              , 'origin'        => 'line 94:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_17')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'DelPair;member;Project;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Project'
                            , 'expSQL' =>
                                '/* I[Project] */
                                 select
                                 distinct
                                        "Project" as src, "Project" as tgt
                                 from "Project"
                                 where "Project" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    )
              )
    , 'Projects are identifiable by their names' =>
        array ( 'name'          => 'Projects are identifiable by their names'
              , 'ruleAdl'       => 'projectName;projectName~ |- I[Project]'
              , 'origin'        => 'line 72:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_14')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM pplStarted::Assignment*Assignment' =>
        array ( 'name'          => 'SYM pplStarted::Assignment*Assignment'
              , 'ruleAdl'       => 'pplStarted = pplStarted~'
              , 'origin'        => 'line 61:1, file ProjectAdministration.adl'
              , 'meaning'       => 'pplStarted[Assignment] is symmetric'
              , 'message'       => 'pplStarted[Assignment] is not symmetric'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_26')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'SYM projectStarted::Project*Project' =>
        array ( 'name'          => 'SYM projectStarted::Project*Project'
              , 'ruleAdl'       => 'projectStarted = projectStarted~'
              , 'origin'        => 'line 39:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStarted[Project] is symmetric'
              , 'message'       => 'projectStarted[Project] is not symmetric'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_27')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT assignee::Assignment*Person' =>
        array ( 'name'          => 'TOT assignee::Assignment*Person'
              , 'ruleAdl'       => 'I[Assignment] |- assignee;assignee~'
              , 'origin'        => 'line 57:1, file ProjectAdministration.adl'
              , 'meaning'       => 'assignee[Assignment\\*Person] is total'
              , 'message'       => 'assignee[Assignment\\*Person] is not total'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_21')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT personEmail::Person*Email' =>
        array ( 'name'          => 'TOT personEmail::Person*Email'
              , 'ruleAdl'       => 'I[Person] |- personEmail;personEmail~'
              , 'origin'        => 'line 50:1, file ProjectAdministration.adl'
              , 'meaning'       => 'personEmail[Person\\*Email] is total'
              , 'message'       => 'personEmail[Person\\*Email] is not total'
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_23')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT project::Assignment*Project' =>
        array ( 'name'          => 'TOT project::Assignment*Project'
              , 'ruleAdl'       => 'I[Assignment] |- project;project~'
              , 'origin'        => 'line 55:1, file ProjectAdministration.adl'
              , 'meaning'       => 'project[Assignment\\*Project] is total'
              , 'message'       => 'project[Assignment\\*Project] is not total'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_22')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'TOT projectName::Project*ProjectName' =>
        array ( 'name'          => 'TOT projectName::Project*ProjectName'
              , 'ruleAdl'       => 'I[Project] |- projectName;projectName~'
              , 'origin'        => 'line 31:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectName[Project\\*ProjectName] is total'
              , 'message'       => 'projectName[Project\\*ProjectName] is not total'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_25')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI assignee::Assignment*Person' =>
        array ( 'name'          => 'UNI assignee::Assignment*Person'
              , 'ruleAdl'       => 'assignee~;assignee |- I[Person]'
              , 'origin'        => 'line 57:1, file ProjectAdministration.adl'
              , 'meaning'       => 'assignee[Assignment\\*Person] is univalent'
              , 'message'       => 'assignee[Assignment\\*Person] is not univalent'
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_1')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI personEmail::Person*Email' =>
        array ( 'name'          => 'UNI personEmail::Person*Email'
              , 'ruleAdl'       => 'personEmail~;personEmail |- I[Email]'
              , 'origin'        => 'line 50:1, file ProjectAdministration.adl'
              , 'meaning'       => 'personEmail[Person\\*Email] is univalent'
              , 'message'       => 'personEmail[Person\\*Email] is not univalent'
              , 'srcConcept'    => 'Email'
              , 'tgtConcept'    => 'Email'
              , 'conjunctIds'   => array ('conj_2')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI personName::Person*PersonName' =>
        array ( 'name'          => 'UNI personName::Person*PersonName'
              , 'ruleAdl'       => 'personName~;personName |- I[PersonName]'
              , 'origin'        => 'line 46:1, file ProjectAdministration.adl'
              , 'meaning'       => 'personName[Person\\*PersonName] is univalent'
              , 'message'       => 'personName[Person\\*PersonName] is not univalent'
              , 'srcConcept'    => 'PersonName'
              , 'tgtConcept'    => 'PersonName'
              , 'conjunctIds'   => array ('conj_3')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI personStatus::Person*PersonStatus' =>
        array ( 'name'          => 'UNI personStatus::Person*PersonStatus'
              , 'ruleAdl'       => 'personStatus~;personStatus |- I[PersonStatus]'
              , 'origin'        => 'line 48:1, file ProjectAdministration.adl'
              , 'meaning'       => 'personStatus[Person\\*PersonStatus] is univalent'
              , 'message'       => 'personStatus[Person\\*PersonStatus] is not univalent'
              , 'srcConcept'    => 'PersonStatus'
              , 'tgtConcept'    => 'PersonStatus'
              , 'conjunctIds'   => array ('conj_4')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI pplStartDate::Assignment*Date' =>
        array ( 'name'          => 'UNI pplStartDate::Assignment*Date'
              , 'ruleAdl'       => 'pplStartDate~;pplStartDate |- I[Date]'
              , 'origin'        => 'line 59:1, file ProjectAdministration.adl'
              , 'meaning'       => 'pplStartDate[Assignment\\*Date] is univalent'
              , 'message'       => 'pplStartDate[Assignment\\*Date] is not univalent'
              , 'srcConcept'    => 'Date'
              , 'tgtConcept'    => 'Date'
              , 'conjunctIds'   => array ('conj_5')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI pplStarted::Assignment*Assignment' =>
        array ( 'name'          => 'UNI pplStarted::Assignment*Assignment'
              , 'ruleAdl'       => 'pplStarted~;pplStarted |- I[Assignment]'
              , 'origin'        => 'line 61:1, file ProjectAdministration.adl'
              , 'meaning'       => 'pplStarted[Assignment\\*Assignment] is univalent'
              , 'message'       => 'pplStarted[Assignment\\*Assignment] is not univalent'
              , 'srcConcept'    => 'Assignment'
              , 'tgtConcept'    => 'Assignment'
              , 'conjunctIds'   => array ('conj_13')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI project::Assignment*Project' =>
        array ( 'name'          => 'UNI project::Assignment*Project'
              , 'ruleAdl'       => 'project~;project |- I[Project]'
              , 'origin'        => 'line 55:1, file ProjectAdministration.adl'
              , 'meaning'       => 'project[Assignment\\*Project] is univalent'
              , 'message'       => 'project[Assignment\\*Project] is not univalent'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_7')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI projectDescription::Project*Description' =>
        array ( 'name'          => 'UNI projectDescription::Project*Description'
              , 'ruleAdl'       => 'projectDescription~;projectDescription |- I[Description]'
              , 'origin'        => 'line 35:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectDescription[Project\\*Description] is univalent'
              , 'message'       => 'projectDescription[Project\\*Description] is not univalent'
              , 'srcConcept'    => 'Description'
              , 'tgtConcept'    => 'Description'
              , 'conjunctIds'   => array ('conj_8')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI projectName::Project*ProjectName' =>
        array ( 'name'          => 'UNI projectName::Project*ProjectName'
              , 'ruleAdl'       => 'projectName~;projectName |- I[ProjectName]'
              , 'origin'        => 'line 31:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectName[Project\\*ProjectName] is univalent'
              , 'message'       => 'projectName[Project\\*ProjectName] is not univalent'
              , 'srcConcept'    => 'ProjectName'
              , 'tgtConcept'    => 'ProjectName'
              , 'conjunctIds'   => array ('conj_9')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI projectStartDate::Project*Date' =>
        array ( 'name'          => 'UNI projectStartDate::Project*Date'
              , 'ruleAdl'       => 'projectStartDate~;projectStartDate |- I[Date]'
              , 'origin'        => 'line 37:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStartDate[Project\\*Date] is univalent'
              , 'message'       => 'projectStartDate[Project\\*Date] is not univalent'
              , 'srcConcept'    => 'Date'
              , 'tgtConcept'    => 'Date'
              , 'conjunctIds'   => array ('conj_10')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI projectStarted::Project*Project' =>
        array ( 'name'          => 'UNI projectStarted::Project*Project'
              , 'ruleAdl'       => 'projectStarted~;projectStarted |- I[Project]'
              , 'origin'        => 'line 39:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStarted[Project\\*Project] is univalent'
              , 'message'       => 'projectStarted[Project\\*Project] is not univalent'
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'conjunctIds'   => array ('conj_15')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'UNI projectStatus::Project*ProjectStatus' =>
        array ( 'name'          => 'UNI projectStatus::Project*ProjectStatus'
              , 'ruleAdl'       => 'projectStatus~;projectStatus |- I[ProjectStatus]'
              , 'origin'        => 'line 33:1, file ProjectAdministration.adl'
              , 'meaning'       => 'projectStatus[Project\\*ProjectStatus] is univalent'
              , 'message'       => 'projectStatus[Project\\*ProjectStatus] is not univalent'
              , 'srcConcept'    => 'ProjectStatus'
              , 'tgtConcept'    => 'ProjectStatus'
              , 'conjunctIds'   => array ('conj_11')
              , 'pairView'      =>
                  array
                    ()
              )
    , 'Works with (depopulate)' =>
        array ( 'name'          => 'Works with (depopulate)'
              , 'ruleAdl'       => 'workswith |- (pl \\/ member)~;(pl \\/ member) - I[Person]'
              , 'origin'        => 'line 108:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_20')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'DelPair;workswith;Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    )
              )
    , 'Works with (populate)' =>
        array ( 'name'          => 'Works with (populate)'
              , 'ruleAdl'       => '(pl \\/ member)~;(pl \\/ member) - I[Person] |- workswith'
              , 'origin'        => 'line 101:1, file ProjectAdministration.adl'
              , 'meaning'       => ''
              , 'message'       => ''
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'conjunctIds'   => array ('conj_0')
              , 'pairView'      =>
                  array
                    ( array ( 'segmentType' => 'Text', 'Text' => 'InsPair;workswith;Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Src'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    , array ( 'segmentType' => 'Text', 'Text' => ';Person;')
                    , array ( 'segmentType' => 'Exp'
                            , 'srcOrTgt' => 'Tgt'
                            , 'expTgt' => 'Person'
                            , 'expSQL' =>
                                '/* I[Person] */
                                 select
                                 distinct
                                        "Person" as src, "Person" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL'
                            )
                    )
              )
    );

$allConjuncts =
  array
    ( 'conj_0' =>
        array ( 'signalRuleNames' => array ('Works with (populate)')
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) ((pl \\/ member)~;(pl \\/ member) - I[Person]) - workswith ([Person*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = (pl \\/ member)~;(pl \\/ member) - I[Person] ([Person*Person])
                                      <expr2> = workswith ([Person*Person])
                                       (pl \\/ member)~;(pl \\/ member) - I[Person] /\\ -workswith ([Person*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: EDif (l,r) (pl \\/ member)~;(pl \\/ member) - I[Person] ([Person*Person]) */
                                          /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = (pl \\/ member)~;(pl \\/ member) ([Person*Person])
                                      <expr2> = I[Person] ([Person*Person])
                                       (pl \\/ member)~;(pl \\/ member) /\\ -I[Person] ([Person*Person])
                                     */
                                          select
                                          distinct
                                                 t1.src as src, t1.tgt as tgt
                                          from (/* case: (ECps es), with two or more elements in es.(pl \\/ member)~;(pl \\/ member) */
                                                select
                                                distinct
                                                       fence0.src as src, fence1.tgt as tgt
                                                from (/* Flipped: EBrk (EUni (EDcD pl[Project*Person],EDcD member[Project*Person])) */
                                                      /* case: EUni (l,r)pl \\/ member ([Project*Person]) */
                                                      select
                                                      distinct
                                                             tgt as src, src as tgt
                                                      from (select distinct "Project" as src, "Person" as tgt from "pl"
                                                            union
                                                            select distinct "Project" as src, "Person" as tgt from "member")
                                                           as flipped)
                                                     as fence0,
                                                     (/* case: EUni (l,r)pl \\/ member ([Project*Person]) */
                                                      select distinct "Project" as src, "Person" as tgt from "pl"
                                                      union
                                                      select distinct "Project" as src, "Person" as tgt from "member")
                                                     as fence1
                                                where fence0.tgt = fence1.src)
                                               as t1
                                               left join (/* I[Person] */
                                                          select
                                                          distinct
                                                                 "Person" as src, "Person" as tgt
                                                          from "Person"
                                                          where "Person" IS NOT NULL)
                                                         as t2
                                               on t1.src = t2.src AND t1.tgt = t2.tgt
                                          where t2.src IS NULL OR t2.tgt IS NULL)
                                         as t1
                                         left join (select
                                                    distinct
                                                           "SrcPerson" as src, "TgtPerson" as tgt
                                                    from "workswith")
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_1' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) assignee~;assignee - I[Person] ([Person*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = assignee~;assignee ([Person*Person])
                                      <expr2> = I[Person] ([Person*Person])
                                       assignee~;assignee /\\ -I[Person] ([Person*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.assignee~;assignee */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD assignee[Assignment*Person] */
                                                select
                                                distinct
                                                       "tgt_assignee" as src, "Assignment" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Assignment" as src, "tgt_assignee" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Person] */
                                                    select
                                                    distinct
                                                           "Person" as src, "Person" as tgt
                                                    from "Person"
                                                    where "Person" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_2' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) personEmail~;personEmail - I[Email] ([Email*Email]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = personEmail~;personEmail ([Email*Email])
                                      <expr2> = I[Email] ([Email*Email])
                                       personEmail~;personEmail /\\ -I[Email] ([Email*Email])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.personEmail~;personEmail */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD personEmail[Person*Email] */
                                                select
                                                distinct
                                                       "tgt_personEmail" as src, "Person" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Person" as src, "tgt_personEmail" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Email] */
                                                    select
                                                    distinct
                                                           "Email" as src, "Email" as tgt
                                                    from "Email"
                                                    where "Email" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_3' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) personName~;personName - I[PersonName] ([PersonName*PersonName]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = personName~;personName ([PersonName*PersonName])
                                      <expr2> = I[PersonName] ([PersonName*PersonName])
                                       personName~;personName /\\ -I[PersonName] ([PersonName*PersonName])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.personName~;personName */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD personName[Person*PersonName] */
                                                select
                                                distinct
                                                       "tgt_personName" as src, "Person" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Person" as src, "tgt_personName" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[PersonName] */
                                                    select
                                                    distinct
                                                           "PersonName" as src, "PersonName" as tgt
                                                    from "PersonName"
                                                    where "PersonName" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_4' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) personStatus~;personStatus - I[PersonStatus] ([PersonStatus*PersonStatus]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = personStatus~;personStatus ([PersonStatus*PersonStatus])
                                      <expr2> = I[PersonStatus] ([PersonStatus*PersonStatus])
                                       personStatus~;personStatus /\\ -I[PersonStatus] ([PersonStatus*PersonStatus])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.personStatus~;personStatus */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD personStatus[Person*PersonStatus] */
                                                select
                                                distinct
                                                       "tgt_personStatus" as src, "Person" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personStatus" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Person" as src, "tgt_personStatus" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personStatus" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[PersonStatus] */
                                                    select
                                                    distinct
                                                           "PersonStatus" as src, "PersonStatus" as tgt
                                                    from "PersonStatus"
                                                    where "PersonStatus" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_5' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) pplStartDate~;pplStartDate - I[Date] ([Date*Date]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = pplStartDate~;pplStartDate ([Date*Date])
                                      <expr2> = I[Date] ([Date*Date])
                                       pplStartDate~;pplStartDate /\\ -I[Date] ([Date*Date])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.pplStartDate~;pplStartDate */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD pplStartDate[Assignment*Date] */
                                                select
                                                distinct
                                                       "tgt_pplStartDate" as src, "Assignment" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_pplStartDate" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Assignment" as src, "tgt_pplStartDate" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_pplStartDate" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Date] */
                                                    select
                                                    distinct
                                                           "Date" as src, "Date" as tgt
                                                    from "Date"
                                                    where "Date" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_6' =>
        array ( 'signalRuleNames' => array ('Delete Assignment')
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) (project~;assignee - pl) - member ([Project*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = project~;assignee - pl ([Project*Person])
                                      <expr2> = member ([Project*Person])
                                       project~;assignee - pl /\\ -member ([Project*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: EDif (l,r) project~;assignee - pl ([Project*Person]) */
                                          /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = project~;assignee ([Project*Person])
                                      <expr2> = pl ([Project*Person])
                                       project~;assignee /\\ -pl ([Project*Person])
                                     */
                                          select
                                          distinct
                                                 t1.src as src, t1.tgt as tgt
                                          from (/* case: (ECps es), with two or more elements in es.project~;assignee */
                                                select
                                                distinct
                                                       fence0.src as src, fence1.tgt as tgt
                                                from (/* Flipped: EDcD project[Assignment*Project] */
                                                      select
                                                      distinct
                                                             "tgt_project" as src, "Assignment" as tgt
                                                      from "Assignment"
                                                      where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                                     as fence0,
                                                     (select
                                                      distinct
                                                             "Assignment" as src, "tgt_assignee" as tgt
                                                      from "Assignment"
                                                      where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                                     as fence1
                                                where fence0.tgt = fence1.src)
                                               as t1
                                               left join (select
                                                          distinct
                                                                 "Project" as src, "Person" as tgt
                                                          from "pl")
                                                         as t2
                                               on t1.src = t2.src AND t1.tgt = t2.tgt
                                          where t2.src IS NULL OR t2.tgt IS NULL)
                                         as t1
                                         left join (select
                                                    distinct
                                                           "Project" as src, "Person" as tgt
                                                    from "member")
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_7' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) project~;project - I[Project] ([Project*Project]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = project~;project ([Project*Project])
                                      <expr2> = I[Project] ([Project*Project])
                                       project~;project /\\ -I[Project] ([Project*Project])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.project~;project */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD project[Assignment*Project] */
                                                select
                                                distinct
                                                       "tgt_project" as src, "Assignment" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Assignment" as src, "tgt_project" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Project] */
                                                    select
                                                    distinct
                                                           "Project" as src, "Project" as tgt
                                                    from "Project"
                                                    where "Project" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_8' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) projectDescription~;projectDescription - I[Description] ([Description*Description]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectDescription~;projectDescription ([Description*Description])
                                      <expr2> = I[Description] ([Description*Description])
                                       projectDescription~;projectDescription /\\ -I[Description] ([Description*Description])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectDescription~;projectDescription */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD projectDescription[Project*Description] */
                                                select
                                                distinct
                                                       "tgt_projectDescription" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectDescription" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Project" as src, "tgt_projectDescription" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectDescription" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Description] */
                                                    select
                                                    distinct
                                                           "Description" as src, "Description" as tgt
                                                    from "Description"
                                                    where "Description" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_9' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) projectName~;projectName - I[ProjectName] ([ProjectName*ProjectName]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectName~;projectName ([ProjectName*ProjectName])
                                      <expr2> = I[ProjectName] ([ProjectName*ProjectName])
                                       projectName~;projectName /\\ -I[ProjectName] ([ProjectName*ProjectName])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectName~;projectName */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD projectName[Project*ProjectName] */
                                                select
                                                distinct
                                                       "tgt_projectName" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Project" as src, "tgt_projectName" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[ProjectName] */
                                                    select
                                                    distinct
                                                           "ProjectName" as src, "ProjectName" as tgt
                                                    from "ProjectName"
                                                    where "ProjectName" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_10' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) projectStartDate~;projectStartDate - I[Date] ([Date*Date]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectStartDate~;projectStartDate ([Date*Date])
                                      <expr2> = I[Date] ([Date*Date])
                                       projectStartDate~;projectStartDate /\\ -I[Date] ([Date*Date])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectStartDate~;projectStartDate */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD projectStartDate[Project*Date] */
                                                select
                                                distinct
                                                       "tgt_projectStartDate" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStartDate" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Project" as src, "tgt_projectStartDate" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStartDate" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Date] */
                                                    select
                                                    distinct
                                                           "Date" as src, "Date" as tgt
                                                    from "Date"
                                                    where "Date" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_11' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) projectStatus~;projectStatus - I[ProjectStatus] ([ProjectStatus*ProjectStatus]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectStatus~;projectStatus ([ProjectStatus*ProjectStatus])
                                      <expr2> = I[ProjectStatus] ([ProjectStatus*ProjectStatus])
                                       projectStatus~;projectStatus /\\ -I[ProjectStatus] ([ProjectStatus*ProjectStatus])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectStatus~;projectStatus */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (/* Flipped: EDcD projectStatus[Project*ProjectStatus] */
                                                select
                                                distinct
                                                       "tgt_projectStatus" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStatus" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Project" as src, "tgt_projectStatus" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStatus" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[ProjectStatus] */
                                                    select
                                                    distinct
                                                           "ProjectStatus" as src, "ProjectStatus" as tgt
                                                    from "ProjectStatus"
                                                    where "ProjectStatus" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_12' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('People are identifiable by their email-address')
              , 'violationsSQL' => '/* case: EDif (l,r) personEmail;personEmail~ - I[Person] ([Person*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = personEmail;personEmail~ ([Person*Person])
                                      <expr2> = I[Person] ([Person*Person])
                                       personEmail;personEmail~ /\\ -I[Person] ([Person*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.personEmail;personEmail~ */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (select
                                                distinct
                                                       "Person" as src, "tgt_personEmail" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL)
                                               as fence0,
                                               (/* Flipped: EDcD personEmail[Person*Email] */
                                                select
                                                distinct
                                                       "tgt_personEmail" as src, "Person" as tgt
                                                from "Person"
                                                where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Person] */
                                                    select
                                                    distinct
                                                           "Person" as src, "Person" as tgt
                                                    from "Person"
                                                    where "Person" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_13' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) pplStarted;pplStarted - I[Assignment] ([Assignment*Assignment]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = pplStarted;pplStarted ([Assignment*Assignment])
                                      <expr2> = I[Assignment] ([Assignment*Assignment])
                                       pplStarted;pplStarted /\\ -I[Assignment] ([Assignment*Assignment])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.pplStarted;pplStarted */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (select
                                                distinct
                                                       "Assignment" as src, "tgt_pplStarted" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_pplStarted" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Assignment" as src, "tgt_pplStarted" as tgt
                                                from "Assignment"
                                                where "Assignment" IS NOT NULL AND "tgt_pplStarted" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Assignment] */
                                                    select
                                                    distinct
                                                           "Assignment" as src, "Assignment" as tgt
                                                    from "Assignment"
                                                    where "Assignment" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_14' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('Projects are identifiable by their names')
              , 'violationsSQL' => '/* case: EDif (l,r) projectName;projectName~ - I[Project] ([Project*Project]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectName;projectName~ ([Project*Project])
                                      <expr2> = I[Project] ([Project*Project])
                                       projectName;projectName~ /\\ -I[Project] ([Project*Project])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectName;projectName~ */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (select
                                                distinct
                                                       "Project" as src, "tgt_projectName" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL)
                                               as fence0,
                                               (/* Flipped: EDcD projectName[Project*ProjectName] */
                                                select
                                                distinct
                                                       "tgt_projectName" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Project] */
                                                    select
                                                    distinct
                                                           "Project" as src, "Project" as tgt
                                                    from "Project"
                                                    where "Project" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_15' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) projectStarted;projectStarted - I[Project] ([Project*Project]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectStarted;projectStarted ([Project*Project])
                                      <expr2> = I[Project] ([Project*Project])
                                       projectStarted;projectStarted /\\ -I[Project] ([Project*Project])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (/* case: (ECps es), with two or more elements in es.projectStarted;projectStarted */
                                          select
                                          distinct
                                                 fence0.src as src, fence1.tgt as tgt
                                          from (select
                                                distinct
                                                       "Project" as src, "tgt_projectStarted" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL)
                                               as fence0,
                                               (select
                                                distinct
                                                       "Project" as src, "tgt_projectStarted" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL)
                                               as fence1
                                          where fence0.tgt = fence1.src)
                                         as t1
                                         left join (/* I[Project] */
                                                    select
                                                    distinct
                                                           "Project" as src, "Project" as tgt
                                                    from "Project"
                                                    where "Project" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_16' =>
        array ( 'signalRuleNames' => array ('Create Assignment')
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) pl - project~;assignee ([Project*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = pl ([Project*Person])
                                      <expr2> = project~;assignee ([Project*Person])
                                       pl /\\ -(project~;assignee) ([Project*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (select distinct "Project" as src, "Person" as tgt from "pl")
                                         as t1
                                         left
                                         join (/* case: (ECps es), with two or more elements in es.project~;assignee */
                                               select
                                               distinct
                                                      fence0.src as src, fence1.tgt as tgt
                                               from (/* Flipped: EDcD project[Assignment*Project] */
                                                     select
                                                     distinct
                                                            "tgt_project" as src, "Assignment" as tgt
                                                     from "Assignment"
                                                     where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                                    as fence0,
                                                    (select
                                                     distinct
                                                            "Assignment" as src, "tgt_assignee" as tgt
                                                     from "Assignment"
                                                     where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                                    as fence1
                                               where fence0.tgt = fence1.src)
                                              as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_17' =>
        array ( 'signalRuleNames' => array ('Projectleaders are not members of a team')
              , 'invariantRuleNames' => array ('Project leaders are not considered members of the projects they lead.')
              , 'violationsSQL' => '/* case: (EIsc pl /\\ member ([Project*Person])
                                    EDcD pl[Project*Person]
                                    EDcD member[Project*Person]
                                     */
                                    select
                                    distinct
                                           src as src, tgt as tgt
                                    from (/* `intersect` does not work in MySQL, so this statement is generated: */
                                          select
                                          distinct
                                                 subIntersect0.src as src, subIntersect0.tgt as tgt
                                          from (select distinct "Project" as src, "Person" as tgt from "pl")
                                               as subIntersect0,
                                               (select distinct "Project" as src, "Person" as tgt from "member")
                                               as subIntersect1
                                          where subIntersect1.src = subIntersect0.src AND subIntersect1.tgt = subIntersect0.tgt)
                                         as someDummyNameBecauseMySQLNeedsOne'
              )
    , 'conj_18' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('ASY pplStarted::Assignment*Assignment')
              , 'violationsSQL' => '/* case: EDif (l,r) pplStarted - I[Assignment] ([Assignment*Assignment]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = pplStarted ([Assignment*Assignment])
                                      <expr2> = I[Assignment] ([Assignment*Assignment])
                                       pplStarted /\\ -I[Assignment] ([Assignment*Assignment])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (select
                                          distinct
                                                 "Assignment" as src, "tgt_pplStarted" as tgt
                                          from "Assignment"
                                          where "Assignment" IS NOT NULL AND "tgt_pplStarted" IS NOT NULL)
                                         as t1
                                         left join (/* I[Assignment] */
                                                    select
                                                    distinct
                                                           "Assignment" as src, "Assignment" as tgt
                                                    from "Assignment"
                                                    where "Assignment" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_19' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('ASY projectStarted::Project*Project')
              , 'violationsSQL' => '/* case: EDif (l,r) projectStarted - I[Project] ([Project*Project]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = projectStarted ([Project*Project])
                                      <expr2> = I[Project] ([Project*Project])
                                       projectStarted /\\ -I[Project] ([Project*Project])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (select
                                          distinct
                                                 "Project" as src, "tgt_projectStarted" as tgt
                                          from "Project"
                                          where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL)
                                         as t1
                                         left join (/* I[Project] */
                                                    select
                                                    distinct
                                                           "Project" as src, "Project" as tgt
                                                    from "Project"
                                                    where "Project" IS NOT NULL)
                                                   as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_20' =>
        array ( 'signalRuleNames' => array ('Works with (depopulate)')
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) workswith - ((pl \\/ member)~;(pl \\/ member) - I[Person]) ([Person*Person]) */
                                    /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = workswith ([Person*Person])
                                      <expr2> = (pl \\/ member)~;(pl \\/ member) - I[Person] ([Person*Person])
                                       workswith /\\ -((pl \\/ member)~;(pl \\/ member) - I[Person]) ([Person*Person])
                                     */
                                    select
                                    distinct
                                           t1.src as src, t1.tgt as tgt
                                    from (select
                                          distinct
                                                 "SrcPerson" as src, "TgtPerson" as tgt
                                          from "workswith")
                                         as t1
                                         left
                                         join (/* case: EDif (l,r) (pl \\/ member)~;(pl \\/ member) - I[Person] ([Person*Person]) */
                                               /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = (pl \\/ member)~;(pl \\/ member) ([Person*Person])
                                      <expr2> = I[Person] ([Person*Person])
                                       (pl \\/ member)~;(pl \\/ member) /\\ -I[Person] ([Person*Person])
                                     */
                                               select
                                               distinct
                                                      t1.src as src, t1.tgt as tgt
                                               from (/* case: (ECps es), with two or more elements in es.(pl \\/ member)~;(pl \\/ member) */
                                                     select
                                                     distinct
                                                            fence0.src as src, fence1.tgt as tgt
                                                     from (/* Flipped: EBrk (EUni (EDcD pl[Project*Person],EDcD member[Project*Person])) */
                                                           /* case: EUni (l,r)pl \\/ member ([Project*Person]) */
                                                           select
                                                           distinct
                                                                  tgt as src, src as tgt
                                                           from (select distinct "Project" as src, "Person" as tgt from "pl"
                                                                 union
                                                                 select distinct "Project" as src, "Person" as tgt from "member")
                                                                as flipped)
                                                          as fence0,
                                                          (/* case: EUni (l,r)pl \\/ member ([Project*Person]) */
                                                           select distinct "Project" as src, "Person" as tgt from "pl"
                                                           union
                                                           select distinct "Project" as src, "Person" as tgt from "member")
                                                          as fence1
                                                     where fence0.tgt = fence1.src)
                                                    as t1
                                                    left join (/* I[Person] */
                                                               select
                                                               distinct
                                                                      "Person" as src, "Person" as tgt
                                                               from "Person"
                                                               where "Person" IS NOT NULL)
                                                              as t2
                                                    on t1.src = t2.src AND t1.tgt = t2.tgt
                                               where t2.src IS NULL OR t2.tgt IS NULL)
                                              as t2
                                         on t1.src = t2.src AND t1.tgt = t2.tgt
                                    where t2.src IS NULL OR t2.tgt IS NULL'
              )
    , 'conj_21' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('TOT assignee::Assignment*Person')
              , 'violationsSQL' => '/* case: EDif (l,r) I[Assignment] - assignee;assignee~ ([Assignment*Assignment]) */
                                    /* Optimized case for: assignee[Assignment*Person] [TOT]. */
                                    /*    I[Assignment] /\\ -(assignee;assignee~) ([Assignment*Assignment]) */
                                    select
                                    distinct
                                           "Assignment" as src, "Assignment" as tgt
                                    from "Assignment" as notIns
                                    where "Assignment" not in (select src
                                                               from (select
                                                                     distinct
                                                                            "Assignment" as src, "tgt_assignee" as tgt
                                                                     from "Assignment"
                                                                     where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                                                    as src) AND "Assignment" IS NOT NULL'
              )
    , 'conj_22' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('TOT project::Assignment*Project')
              , 'violationsSQL' => '/* case: EDif (l,r) I[Assignment] - project;project~ ([Assignment*Assignment]) */
                                    /* Optimized case for: project[Assignment*Project] [TOT]. */
                                    /*    I[Assignment] /\\ -(project;project~) ([Assignment*Assignment]) */
                                    select
                                    distinct
                                           "Assignment" as src, "Assignment" as tgt
                                    from "Assignment" as notIns
                                    where "Assignment" not in (select src
                                                               from (select
                                                                     distinct
                                                                            "Assignment" as src, "tgt_project" as tgt
                                                                     from "Assignment"
                                                                     where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                                                    as src) AND "Assignment" IS NOT NULL'
              )
    , 'conj_23' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('TOT personEmail::Person*Email')
              , 'violationsSQL' => '/* case: EDif (l,r) I[Person] - personEmail;personEmail~ ([Person*Person]) */
                                    /* Optimized case for: personEmail[Person*Email] [TOT]. */
                                    /*    I[Person] /\\ -(personEmail;personEmail~) ([Person*Person]) */
                                    select
                                    distinct
                                           "Person" as src, "Person" as tgt
                                    from "Person" as notIns
                                    where "Person" not in (select src
                                                           from (select
                                                                 distinct
                                                                        "Person" as src, "tgt_personEmail" as tgt
                                                                 from "Person"
                                                                 where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL)
                                                                as src) AND "Person" IS NOT NULL'
              )
    , 'conj_24' =>
        array ( 'signalRuleNames' => array ('Every project must have a projectleader')
              , 'invariantRuleNames' => array ()
              , 'violationsSQL' => '/* case: EDif (l,r) I[Project] - pl;pl~ ([Project*Project]) */
                                    /* Optimized case for: pl[Project*Person] [TOT]. */
                                    /*    I[Project] /\\ -(pl;pl~) ([Project*Project]) */
                                    select
                                    distinct
                                           "Project" as src, "Project" as tgt
                                    from "Project" as notIns
                                    where "Project" not in (select src
                                                            from (select distinct "Project" as src, "Person" as tgt from "pl")
                                                                 as src) AND "Project" IS NOT NULL'
              )
    , 'conj_25' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('TOT projectName::Project*ProjectName')
              , 'violationsSQL' => '/* case: EDif (l,r) I[Project] - projectName;projectName~ ([Project*Project]) */
                                    /* Optimized case for: projectName[Project*ProjectName] [TOT]. */
                                    /*    I[Project] /\\ -(projectName;projectName~) ([Project*Project]) */
                                    select
                                    distinct
                                           "Project" as src, "Project" as tgt
                                    from "Project" as notIns
                                    where "Project" not in (select src
                                                            from (select
                                                                  distinct
                                                                         "Project" as src, "tgt_projectName" as tgt
                                                                  from "Project"
                                                                  where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL)
                                                                 as src) AND "Project" IS NOT NULL'
              )
    , 'conj_26' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('SYM pplStarted::Assignment*Assignment')
              , 'violationsSQL' => '/* this will quaranteed return 0 rows: */
                                    select
                                    distinct
                                           a as src, a as tgt
                                    from (/* Select nothing... */
                                          select 1 as a)
                                         as nothing
                                    where a <> 1'
              )
    , 'conj_27' =>
        array ( 'signalRuleNames' => array ()
              , 'invariantRuleNames' => array ('SYM projectStarted::Project*Project')
              , 'violationsSQL' => '/* this will quaranteed return 0 rows: */
                                    select
                                    distinct
                                           a as src, a as tgt
                                    from (/* Select nothing... */
                                          select 1 as a)
                                         as nothing
                                    where a <> 1'
              )
    );

$allRoles =
  array
    ( array ( 'id' => 1
            , 'name' => 'Planner'
            , 'ruleNames'  => array ('Every project must have a projectleader')
            , 'interfaces' => array ('Started projects', 'Unstarted projects', 'People', 'Project', 'Person')
            , 'editableConcepts' => array ('Project', 'PersonName', 'Email')
            )
    , array ( 'id' => 2
            , 'name' => 'ExecEngine'
            , 'ruleNames'  => array ('Projectleaders are not members of a team', 'Works with (populate)', 'Works with (depopulate)', 'Create Assignment', 'Delete Assignment')
            , 'interfaces' => array ('Started projects', 'Unstarted projects', 'People', 'Project', 'Person')
            , 'editableConcepts' => array ('Project', 'PersonName', 'Email')
            )
    );
$allServices =
  array
    ();

//$allViews is sorted from spec to gen such that the first match for a concept will be the most specific (e.g. see DatabaseUtils.getView()).
$allViews =
  array
    (   array ( 'label' => 'Projects'
              , 'concept' => 'Project'
              , 'isDefault' => true
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => 'seg_1' // view exp: projectName
                            , 'expSQL' =>
                                'select
                                 distinct
                                        "Project" as src, "tgt_projectName" as tgt
                                 from "Project"
                                 where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'People'
              , 'concept' => 'Person'
              , 'isDefault' => true
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => 'seg_1' // view exp: personName
                            , 'expSQL' =>
                                'select
                                 distinct
                                        "Person" as src, "tgt_personName" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL'
                            )
                    )
              )
    ,   array ( 'label' => 'PersonEmail'
              , 'concept' => 'Person'
              , 'isDefault' => false
              , 'segments' =>
                  array
                    ( array ( 'segmentType' => 'Exp'
                            , 'label' => 'email' // view exp: personEmail
                            , 'expSQL' =>
                                'select
                                 distinct
                                        "Person" as src, "tgt_personEmail" as tgt
                                 from "Person"
                                 where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL'
                            )
                    )
              )
    );

$allInterfaceObjects =
  array
    ( // Top-level interface Started projects for all roles:
      'Started_32_projects' => 
        array ( 'name'  => 'Started projects'
              , 'id'    => "Started_32_projects"
              , 'label' => 'Started projects'
              , 'viewId' => 'Projects'
              // Normalized interface expression (== expressionSQL): V[SESSION*Project];projectStarted
              , 'interfaceRoles' => array ()
              , 'invConjunctIds' => array ()
              , 'sigConjunctIds' => array ()
              , 'relation' => '' // this interface expression does not represent a declared relation
              , 'relationIsFlipped' => ''
              , 'srcConcept'    => 'SESSION'
              , 'tgtConcept'    => 'Project'
              , 'crudC'         => null
              , 'crudR'         => null
              , 'crudU'         => null
              , 'crudD'         => null
              , 'exprIsUni'     => false
              , 'exprIsTot'     => false
              , 'exprIsProp'    => false
              , 'exprIsIdent'   => false
              , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.V[SESSION*Project];projectStarted */
                                    select
                                    distinct
                                           fence0.src as src, fence1.tgt as tgt
                                    from (/* case: (EDcV (Sign s t))   V[ "[SESSION*Project]" ] */
                                          select
                                          distinct
                                                 fst."SESSION" as src, snd."Project" as tgt
                                          from "SESSION" as fst,
                                               "Project" as snd
                                          where fst."SESSION" IS NOT NULL AND snd."Project" IS NOT NULL)
                                         as fence0,
                                         (select
                                          distinct
                                                 "Project" as src, "tgt_projectStarted" as tgt
                                          from "Project"
                                          where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL)
                                         as fence1
                                    where fence0.tgt = fence1.src'
              // Box<SCOLS>
              , 'boxSubInterfaces' =>
                  array
                    ( array ( 'name'  => 'Projects'
                            , 'id'    => "Projects"
                            , 'label' => 'Projects'
                            , 'viewId' => 'Projects'
                            // Normalized interface expression (== expressionSQL): I[Project]
                            , 'relation' => '' // this interface expression does not represent a declared relation
                            , 'relationIsFlipped' => ''
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Project'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => true
                            , 'exprIsIdent'   => true
                            , 'expressionSQL' => '/* I[Project] */
                                                  select
                                                  distinct
                                                         "Project" as src, "Project" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Name'
                            , 'id'    => "Name"
                            , 'label' => 'Name'
                            // Normalized interface expression (== expressionSQL): projectName
                            , 'relation' => 'rel_projectName_Project_ProjectName' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'One'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'ProjectName'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectName" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Description'
                            , 'id'    => "Description"
                            , 'label' => 'Description'
                            // Normalized interface expression (== expressionSQL): projectDescription
                            , 'relation' => 'rel_projectDescription_Project_Description' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Description'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectDescription" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectDescription" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Projectleider'
                            , 'id'    => "Projectleider"
                            , 'label' => 'Projectleider'
                            , 'viewId' => 'People'
                            // Normalized interface expression (== expressionSQL): pl
                            , 'relation' => 'rel_pl_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select distinct "Project" as src, "Person" as tgt from "pl"'
                            // No subinterfaces
                            )
                    , array ( 'name'  => ' '
                            , 'id'    => "_32_"
                            , 'label' => ' '
                            , 'viewId' => 'PersonEmail'
                            // Normalized interface expression (== expressionSQL): pl
                            , 'relation' => 'rel_pl_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select distinct "Project" as src, "Person" as tgt from "pl"'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Start'
                            , 'id'    => "Start"
                            , 'label' => 'Start'
                            // Normalized interface expression (== expressionSQL): projectStartDate
                            , 'relation' => 'rel_projectStartDate_Project_Date' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Date'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectStartDate" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectStartDate" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Started'
                            , 'id'    => "Started"
                            , 'label' => 'Started'
                            , 'viewId' => 'Projects'
                            // Normalized interface expression (== expressionSQL): projectStarted
                            , 'relation' => 'rel_projectStarted_Project_Project' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Project'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => true
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectStarted" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL'
                            // No subinterfaces
                            )
                    )
              )
    , // Top-level interface Unstarted projects for all roles:
      'Unstarted_32_projects' => 
        array ( 'name'  => 'Unstarted projects'
              , 'id'    => "Unstarted_32_projects"
              , 'label' => 'Unstarted projects'
              , 'viewId' => 'Projects'
              // Normalized interface expression (== expressionSQL): V[SESSION*Project];(I[Project] - projectStarted)
              , 'interfaceRoles' => array ()
              , 'invConjunctIds' => array ('conj_19')
              , 'sigConjunctIds' => array ()
              , 'relation' => '' // this interface expression does not represent a declared relation
              , 'relationIsFlipped' => ''
              , 'srcConcept'    => 'SESSION'
              , 'tgtConcept'    => 'Project'
              , 'crudC'         => null
              , 'crudR'         => null
              , 'crudU'         => null
              , 'crudD'         => null
              , 'exprIsUni'     => false
              , 'exprIsTot'     => false
              , 'exprIsProp'    => false
              , 'exprIsIdent'   => false
              , 'expressionSQL' => '/* case: (ECps es), with two or more elements in es.V[SESSION*Project];(I[Project] - projectStarted) */
                                    select
                                    distinct
                                           fence0.src as src, fence1.tgt as tgt
                                    from (/* case: (EDcV (Sign s t))   V[ "[SESSION*Project]" ] */
                                          select
                                          distinct
                                                 fst."SESSION" as src, snd."Project" as tgt
                                          from "SESSION" as fst,
                                               "Project" as snd
                                          where fst."SESSION" IS NOT NULL AND snd."Project" IS NOT NULL)
                                         as fence0,
                                         (/* case: EDif (l,r) I[Project] - projectStarted ([Project*Project]) */
                                          /* Optimized case for: <expr1> intersect with the complement of <expr2>.
                                    where 
                                      <expr1> = I[Project] ([Project*Project])
                                      <expr2> = projectStarted ([Project*Project])
                                       I[Project] /\\ -projectStarted ([Project*Project])
                                     */
                                          select
                                          distinct
                                                 t1.src as src, t1.tgt as tgt
                                          from (/* I[Project] */
                                                select
                                                distinct
                                                       "Project" as src, "Project" as tgt
                                                from "Project"
                                                where "Project" IS NOT NULL)
                                               as t1
                                               left join (select
                                                          distinct
                                                                 "Project" as src, "tgt_projectStarted" as tgt
                                                          from "Project"
                                                          where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL)
                                                         as t2
                                               on t1.src = t2.src AND t1.tgt = t2.tgt
                                          where t2.src IS NULL OR t2.tgt IS NULL)
                                         as fence1
                                    where fence0.tgt = fence1.src'
              // Box<SCOLS>
              , 'boxSubInterfaces' =>
                  array
                    ( array ( 'name'  => 'Name'
                            , 'id'    => "Name"
                            , 'label' => 'Name'
                            // Normalized interface expression (== expressionSQL): projectName
                            , 'relation' => 'rel_projectName_Project_ProjectName' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'One'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'ProjectName'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectName" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Description'
                            , 'id'    => "Description"
                            , 'label' => 'Description'
                            // Normalized interface expression (== expressionSQL): projectDescription
                            , 'relation' => 'rel_projectDescription_Project_Description' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Description'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectDescription" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectDescription" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Projectleider'
                            , 'id'    => "Projectleider"
                            , 'label' => 'Projectleider'
                            , 'viewId' => 'People'
                            // Normalized interface expression (== expressionSQL): pl
                            , 'relation' => 'rel_pl_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select distinct "Project" as src, "Person" as tgt from "pl"'
                            // No subinterfaces
                            )
                    , array ( 'name'  => ' '
                            , 'id'    => "_32_"
                            , 'label' => ' '
                            , 'viewId' => 'PersonEmail'
                            // Normalized interface expression (== expressionSQL): pl
                            , 'relation' => 'rel_pl_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select distinct "Project" as src, "Person" as tgt from "pl"'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Started'
                            , 'id'    => "Started"
                            , 'label' => 'Started'
                            , 'viewId' => 'Projects'
                            // Normalized interface expression (== expressionSQL): projectStarted
                            , 'relation' => 'rel_projectStarted_Project_Project' // this interface represents a declared relation
                            , 'relationIsEditable' => true
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Project'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => true
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectStarted" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectStarted" IS NOT NULL'
                            // No subinterfaces
                            )
                    )
              )
    , // Top-level interface People for all roles:
      'People' => 
        array ( 'name'  => 'People'
              , 'id'    => "People"
              , 'label' => 'People'
              , 'viewId' => 'People'
              // Normalized interface expression (== expressionSQL): V[SESSION*Person]
              , 'interfaceRoles' => array ()
              , 'invConjunctIds' => array ('conj_17')
              , 'sigConjunctIds' => array ('conj_0', 'conj_6', 'conj_17', 'conj_20')
              , 'relation' => '' // this interface expression does not represent a declared relation
              , 'relationIsFlipped' => ''
              , 'srcConcept'    => 'SESSION'
              , 'tgtConcept'    => 'Person'
              , 'crudC'         => false
              , 'crudR'         => true
              , 'crudU'         => true
              , 'crudD'         => true
              , 'exprIsUni'     => false
              , 'exprIsTot'     => true
              , 'exprIsProp'    => false
              , 'exprIsIdent'   => false
              , 'expressionSQL' => '/* case: (EDcV (Sign s t))   V[ "[SESSION*Person]" ] */
                                    select
                                    distinct
                                           fst."SESSION" as src, snd."Person" as tgt
                                    from "SESSION" as fst,
                                         "Person" as snd
                                    where fst."SESSION" IS NOT NULL AND snd."Person" IS NOT NULL'
              // Box<COLS>
              , 'boxSubInterfaces' =>
                  array
                    ( array ( 'name'  => 'Person'
                            , 'id'    => "Person"
                            , 'label' => 'Person'
                            , 'viewId' => 'People'
                            // Normalized interface expression (== expressionSQL): I[Person]
                            , 'relation' => '' // this interface expression does not represent a declared relation
                            , 'relationIsFlipped' => ''
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => true
                            , 'exprIsIdent'   => true
                            , 'expressionSQL' => '/* I[Person] */
                                                  select
                                                  distinct
                                                         "Person" as src, "Person" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Name'
                            , 'id'    => "Name"
                            , 'label' => 'Name'
                            // Normalized interface expression (== expressionSQL): personName
                            , 'relation' => 'rel_personName_Person_PersonName' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'PersonName'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Person" as src, "tgt_personName" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Email'
                            , 'id'    => "Email"
                            , 'label' => 'Email'
                            // Normalized interface expression (== expressionSQL): personEmail
                            , 'relation' => 'rel_personEmail_Person_Email' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'One'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'Email'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Person" as src, "tgt_personEmail" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Projects'
                            , 'id'    => "Projects"
                            , 'label' => 'Projects'
                            , 'viewId' => 'Projects'
                            // Normalized interface expression (== expressionSQL): member~
                            , 'relation' => 'rel_member_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => true
                            , 'relationIsFlipped' => true
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'Project'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => '/* Flipped: EDcD member[Project*Person] */
                                                  select distinct "Person" as src, "Project" as tgt from "member"'
                            // No subinterfaces
                            )
                    )
              )
    , // Top-level interface Project for all roles:
      'Project' => 
        array ( 'name'  => 'Project'
              , 'id'    => "Project"
              , 'label' => 'Project'
              , 'viewId' => 'Projects'
              // Normalized interface expression (== expressionSQL): I[Project]
              , 'interfaceRoles' => array ()
              , 'invConjunctIds' => array ()
              , 'sigConjunctIds' => array ()
              , 'relation' => '' // this interface expression does not represent a declared relation
              , 'relationIsFlipped' => ''
              , 'srcConcept'    => 'Project'
              , 'tgtConcept'    => 'Project'
              , 'crudC'         => null
              , 'crudR'         => null
              , 'crudU'         => null
              , 'crudD'         => null
              , 'exprIsUni'     => true
              , 'exprIsTot'     => true
              , 'exprIsProp'    => true
              , 'exprIsIdent'   => true
              , 'expressionSQL' => '/* I[Project] */
                                    select
                                    distinct
                                           "Project" as src, "Project" as tgt
                                    from "Project"
                                    where "Project" IS NOT NULL'
              // Box<ROWS>
              , 'boxSubInterfaces' =>
                  array
                    ( array ( 'name'  => 'Name'
                            , 'id'    => "Name"
                            , 'label' => 'Name'
                            // Normalized interface expression (== expressionSQL): projectName
                            , 'relation' => 'rel_projectName_Project_ProjectName' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'One'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'ProjectName'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectName" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectName" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Current PL'
                            , 'id'    => "Current_32_PL"
                            , 'label' => 'Current PL'
                            , 'viewId' => 'People'
                            // Normalized interface expression (== expressionSQL): pl
                            , 'relation' => 'rel_pl_Project_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select distinct "Project" as src, "Person" as tgt from "pl"'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Description'
                            , 'id'    => "Description"
                            , 'label' => 'Description'
                            // Normalized interface expression (== expressionSQL): projectDescription
                            , 'relation' => 'rel_projectDescription_Project_Description' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Description'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Project" as src, "tgt_projectDescription" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL AND "tgt_projectDescription" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Administration'
                            , 'id'    => "Administration"
                            , 'label' => 'Administration'
                            , 'viewId' => 'Projects'
                            // Normalized interface expression (== expressionSQL): I[Project]
                            , 'relation' => '' // this interface expression does not represent a declared relation
                            , 'relationIsFlipped' => ''
                            , 'srcConcept'    => 'Project'
                            , 'tgtConcept'    => 'Project'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => true
                            , 'exprIsIdent'   => true
                            , 'expressionSQL' => '/* I[Project] */
                                                  select
                                                  distinct
                                                         "Project" as src, "Project" as tgt
                                                  from "Project"
                                                  where "Project" IS NOT NULL'
                            // Box<TABS>
                            , 'boxSubInterfaces' =>
                                array
                                  ( array ( 'name'  => 'Project leaders'
                                          , 'id'    => "Project_32_leaders"
                                          , 'label' => 'Project leaders'
                                          , 'viewId' => 'People'
                                          // Normalized interface expression (== expressionSQL): project~;assignee /\\ pl
                                          , 'relation' => '' // this interface expression does not represent a declared relation
                                          , 'relationIsFlipped' => ''
                                          , 'srcConcept'    => 'Project'
                                          , 'tgtConcept'    => 'Person'
                                          , 'crudC'         => null
                                          , 'crudR'         => null
                                          , 'crudU'         => null
                                          , 'crudD'         => null
                                          , 'exprIsUni'     => false
                                          , 'exprIsTot'     => false
                                          , 'exprIsProp'    => false
                                          , 'exprIsIdent'   => false
                                          , 'expressionSQL' => '/* case: (EIsc project~;assignee /\\ pl ([Project*Person])
                                                                ECps (EFlp (EDcD project[Assignment*Project]),EDcD assignee[Assignment*Person])
                                                                EDcD pl[Project*Person]
                                                                 */
                                                                select
                                                                distinct
                                                                       src as src, tgt as tgt
                                                                from (/* `intersect` does not work in MySQL, so this statement is generated: */
                                                                      select
                                                                      distinct
                                                                             subIntersect0.src as src, subIntersect0.tgt as tgt
                                                                      from (/* case: (ECps es), with two or more elements in es.project~;assignee */
                                                                            select
                                                                            distinct
                                                                                   fence0.src as src, fence1.tgt as tgt
                                                                            from (/* Flipped: EDcD project[Assignment*Project] */
                                                                                  select
                                                                                  distinct
                                                                                         "tgt_project" as src, "Assignment" as tgt
                                                                                  from "Assignment"
                                                                                  where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                                                                 as fence0,
                                                                                 (select
                                                                                  distinct
                                                                                         "Assignment" as src, "tgt_assignee" as tgt
                                                                                  from "Assignment"
                                                                                  where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                                                                 as fence1
                                                                            where fence0.tgt = fence1.src)
                                                                           as subIntersect0,
                                                                           (select distinct "Project" as src, "Person" as tgt from "pl")
                                                                           as subIntersect1
                                                                      where subIntersect1.src = subIntersect0.src AND subIntersect1.tgt = subIntersect0.tgt)
                                                                     as someDummyNameBecauseMySQLNeedsOne'
                                          // Box<COLS>
                                          , 'boxSubInterfaces' =>
                                              array
                                                ( array ( 'name'  => 'Name'
                                                        , 'id'    => "Name"
                                                        , 'label' => 'Name'
                                                        // Normalized interface expression (== expressionSQL): personName
                                                        , 'relation' => 'rel_personName_Person_PersonName' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'Zero'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'PersonName'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => false
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personName" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                , array ( 'name'  => 'Status'
                                                        , 'id'    => "Status"
                                                        , 'label' => 'Status'
                                                        // Normalized interface expression (== expressionSQL): personStatus
                                                        , 'relation' => 'rel_personStatus_Person_PersonStatus' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'Zero'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'PersonStatus'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => false
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personStatus" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personStatus" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                , array ( 'name'  => 'Email'
                                                        , 'id'    => "Email"
                                                        , 'label' => 'Email'
                                                        // Normalized interface expression (== expressionSQL): personEmail
                                                        , 'relation' => 'rel_personEmail_Person_Email' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'One'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'Email'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => true
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personEmail" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                )
                                          )
                                  , array ( 'name'  => 'Project members'
                                          , 'id'    => "Project_32_members"
                                          , 'label' => 'Project members'
                                          , 'viewId' => 'People'
                                          // Normalized interface expression (== expressionSQL): project~;assignee /\\ member
                                          , 'relation' => '' // this interface expression does not represent a declared relation
                                          , 'relationIsFlipped' => ''
                                          , 'srcConcept'    => 'Project'
                                          , 'tgtConcept'    => 'Person'
                                          , 'crudC'         => null
                                          , 'crudR'         => null
                                          , 'crudU'         => null
                                          , 'crudD'         => null
                                          , 'exprIsUni'     => false
                                          , 'exprIsTot'     => false
                                          , 'exprIsProp'    => false
                                          , 'exprIsIdent'   => false
                                          , 'expressionSQL' => '/* case: (EIsc project~;assignee /\\ member ([Project*Person])
                                                                ECps (EFlp (EDcD project[Assignment*Project]),EDcD assignee[Assignment*Person])
                                                                EDcD member[Project*Person]
                                                                 */
                                                                select
                                                                distinct
                                                                       src as src, tgt as tgt
                                                                from (/* `intersect` does not work in MySQL, so this statement is generated: */
                                                                      select
                                                                      distinct
                                                                             subIntersect0.src as src, subIntersect0.tgt as tgt
                                                                      from (/* case: (ECps es), with two or more elements in es.project~;assignee */
                                                                            select
                                                                            distinct
                                                                                   fence0.src as src, fence1.tgt as tgt
                                                                            from (/* Flipped: EDcD project[Assignment*Project] */
                                                                                  select
                                                                                  distinct
                                                                                         "tgt_project" as src, "Assignment" as tgt
                                                                                  from "Assignment"
                                                                                  where "Assignment" IS NOT NULL AND "tgt_project" IS NOT NULL)
                                                                                 as fence0,
                                                                                 (select
                                                                                  distinct
                                                                                         "Assignment" as src, "tgt_assignee" as tgt
                                                                                  from "Assignment"
                                                                                  where "Assignment" IS NOT NULL AND "tgt_assignee" IS NOT NULL)
                                                                                 as fence1
                                                                            where fence0.tgt = fence1.src)
                                                                           as subIntersect0,
                                                                           (select distinct "Project" as src, "Person" as tgt from "member")
                                                                           as subIntersect1
                                                                      where subIntersect1.src = subIntersect0.src AND subIntersect1.tgt = subIntersect0.tgt)
                                                                     as someDummyNameBecauseMySQLNeedsOne'
                                          // Box<COLS>
                                          , 'boxSubInterfaces' =>
                                              array
                                                ( array ( 'name'  => 'Name'
                                                        , 'id'    => "Name"
                                                        , 'label' => 'Name'
                                                        // Normalized interface expression (== expressionSQL): personName
                                                        , 'relation' => 'rel_personName_Person_PersonName' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'Zero'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'PersonName'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => false
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personName" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                , array ( 'name'  => 'Status'
                                                        , 'id'    => "Status"
                                                        , 'label' => 'Status'
                                                        // Normalized interface expression (== expressionSQL): personStatus
                                                        , 'relation' => 'rel_personStatus_Person_PersonStatus' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'Zero'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'PersonStatus'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => false
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personStatus" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personStatus" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                , array ( 'name'  => 'Email'
                                                        , 'id'    => "Email"
                                                        , 'label' => 'Email'
                                                        // Normalized interface expression (== expressionSQL): personEmail
                                                        , 'relation' => 'rel_personEmail_Person_Email' // this interface represents a declared relation
                                                        , 'relationIsEditable' => false
                                                        , 'relationIsFlipped' => false
                                                        , 'min' => 'One'
                                                        , 'max' => 'One'
                                                        , 'srcConcept'    => 'Person'
                                                        , 'tgtConcept'    => 'Email'
                                                        , 'crudC'         => null
                                                        , 'crudR'         => null
                                                        , 'crudU'         => null
                                                        , 'crudD'         => null
                                                        , 'exprIsUni'     => true
                                                        , 'exprIsTot'     => true
                                                        , 'exprIsProp'    => false
                                                        , 'exprIsIdent'   => false
                                                        , 'expressionSQL' => 'select
                                                                              distinct
                                                                                     "Person" as src, "tgt_personEmail" as tgt
                                                                              from "Person"
                                                                              where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL'
                                                        // No subinterfaces
                                                        )
                                                )
                                          )
                                  )
                            )
                    )
              )
    , // Top-level interface Person for all roles:
      'Person' => 
        array ( 'name'  => 'Person'
              , 'id'    => "Person"
              , 'label' => 'Person'
              , 'viewId' => 'People'
              // Normalized interface expression (== expressionSQL): I[Person]
              , 'interfaceRoles' => array ()
              , 'invConjunctIds' => array ('conj_12', 'conj_23')
              , 'sigConjunctIds' => array ()
              , 'relation' => '' // this interface expression does not represent a declared relation
              , 'relationIsFlipped' => ''
              , 'srcConcept'    => 'Person'
              , 'tgtConcept'    => 'Person'
              , 'crudC'         => null
              , 'crudR'         => null
              , 'crudU'         => null
              , 'crudD'         => null
              , 'exprIsUni'     => true
              , 'exprIsTot'     => true
              , 'exprIsProp'    => true
              , 'exprIsIdent'   => true
              , 'expressionSQL' => '/* I[Person] */
                                    select
                                    distinct
                                           "Person" as src, "Person" as tgt
                                    from "Person"
                                    where "Person" IS NOT NULL'
              // Box
              , 'boxSubInterfaces' =>
                  array
                    ( array ( 'name'  => 'Name'
                            , 'id'    => "Name"
                            , 'label' => 'Name'
                            // Normalized interface expression (== expressionSQL): personName
                            , 'relation' => 'rel_personName_Person_PersonName' // this interface represents a declared relation
                            , 'relationIsEditable' => true
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'PersonName'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Person" as src, "tgt_personName" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL AND "tgt_personName" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Status'
                            , 'id'    => "Status"
                            , 'label' => 'Status'
                            // Normalized interface expression (== expressionSQL): personStatus
                            , 'relation' => 'rel_personStatus_Person_PersonStatus' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'PersonStatus'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Person" as src, "tgt_personStatus" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL AND "tgt_personStatus" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Email'
                            , 'id'    => "Email"
                            , 'label' => 'Email'
                            // Normalized interface expression (== expressionSQL): personEmail
                            , 'relation' => 'rel_personEmail_Person_Email' // this interface represents a declared relation
                            , 'relationIsEditable' => true
                            , 'relationIsFlipped' => false
                            , 'min' => 'One'
                            , 'max' => 'One'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'Email'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => true
                            , 'exprIsTot'     => true
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "Person" as src, "tgt_personEmail" as tgt
                                                  from "Person"
                                                  where "Person" IS NOT NULL AND "tgt_personEmail" IS NOT NULL'
                            // No subinterfaces
                            )
                    , array ( 'name'  => 'Works with'
                            , 'id'    => "Works_32_with"
                            , 'label' => 'Works with'
                            , 'viewId' => 'People'
                            // Normalized interface expression (== expressionSQL): workswith
                            , 'relation' => 'rel_workswith_Person_Person' // this interface represents a declared relation
                            , 'relationIsEditable' => false
                            , 'relationIsFlipped' => false
                            , 'min' => 'Zero'
                            , 'max' => 'Many'
                            , 'srcConcept'    => 'Person'
                            , 'tgtConcept'    => 'Person'
                            , 'crudC'         => null
                            , 'crudR'         => null
                            , 'crudU'         => null
                            , 'crudD'         => null
                            , 'exprIsUni'     => false
                            , 'exprIsTot'     => false
                            , 'exprIsProp'    => false
                            , 'exprIsIdent'   => false
                            , 'expressionSQL' => 'select
                                                  distinct
                                                         "SrcPerson" as src, "TgtPerson" as tgt
                                                  from "workswith"'
                            // No subinterfaces
                            )
                    )
              )
    );
?>
