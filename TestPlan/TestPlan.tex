\documentclass[12pt]{report}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{natbib}%Bibtex
\usepackage{float}
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{booktabs}
\usepackage{tabto}
\usepackage{tocloft} %% This package prevents table of contents from generating a page break
\usepackage{caption}
\usepackage{listings}
\input{../ltx/setupComments}
\usepackage{geometry}
\usepackage{changepage}
\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

\newcolumntype{C}[1]{>{\centering}p{#1}} %% For use with tabularx
%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
\edcommsfalse
\begin{document}

\pagenumbering{roman} %% Roman numerals before actual document starts
\begin{titlepage}\begin{center}
\thispagestyle{empty} %% No page no. on title

\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Test Plan

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill 
%% 

%% We acknowledge that this document uses material from the Volere Requirements
%% Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
%% Limited.

%% \vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 30th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history

\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 27 / 10 / 2015 & Reorganized document \\\hline
Yuriy Toporovskyy & 27 / 10 / 2015 & Initial version - template \\\hline
\end{tabular}
\end{center}\end{table}

\newpage

\tableofcontents
%% \listoffigures 
%% \listoftables 

\newpage
\pagenumbering{arabic} %% Arabic numerals in actual document

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	1.) General Information 
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{General Information}\label{ch:General}

%1.1 Purpose/Summary
\section{Purpose}\label{sec:Purpose}
This document outlines the test plan for ECA for Ampersand, including our
general approach to testing, system test cases, and a specification of
methodology and constraints. This test plan specifically targets our
contribution to Ampersand, namely ECA -- elements of Ampersand, such as design
artifact generation, will not be tested. 

%% %1.3 Objectives
\section{Objectives}\label{sec:Objectives}
\subsubsection*{Preparation for testing}
The primary objective of this test plan is to collect all relevant information
in preperation of the actual testing process, in order to facilitate this process.

\subsubsection*{Communication}
This test plan intends to clearly communicate to all developers of ECA for Ampersand 
their intended role in the testing process. 

\subsubsection*{Motivation}
The testing approach is motivated by constraints and requirements outlined in the
Software Requirements Specification. This document seeks to clearly demonstrate
this motivation.

\subsubsection*{Environment}
This test plans outlines the resources, tools, and software required for the
testing process. This includes any resources needed to perform automated testing. 

\subsubsection*{Scope}
This test plan intends to better describe the scope of our contribution, ECA,
within Ampersand. 

%% %1.3  Definitions, Acronyms, and abbreviations 
\section{Acronyms, Abbreviations, and Symbols}\label{sec:Abbrev}

\begin{description}
\item[SRS] Software Requirements Specification. Document regarding requirements, constraints, and project objectives.
\item[ECA Rule] Event-Condition-Action Rule. A rule which describes how to
  handle a constraint violation in a database. See SRS for details.
\item[HUnit] A Haskell library for unit testing. See TODO: ref test tools
\item[QuickCheck] A Haskell library for running automated, randomized tests. See TODO: ref test tools
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	2.) Plan
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Plan}\label{ch:Plan}

\section{Software Description}\label{sec:SoftwareDesc}
Ampersand is a software tool which converts a formal specification of business
entities and rules, and compiles it into different design artifacts, as well as
a prototype web application.

This prototype implements the business logic in the original specification, in
the form of a relational database with a simple web-app front-end.

A particular class of relational database violations can be automatically
restored; the algorithm for computing the code to fix these violations is called
AMMBR \cite{amber}.  This class of violations is realized within Ampersand as
ECA rules -- our contribution to Ampersand will add support for ECA rules, in
both the Ampersand back-end and the generated prototype.

\section{Test Team}\label{sec:TestTeam}

The test team which will execute the strategy outline in this document is comprised of
\begin{itemize}
\item Yuriy Toporovskyy  
\item Yash Sapra        
\item Jaeden Guo         
\end{itemize}

\section{Test Schedule}\label{sec:TestSched}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Methods and constraints}\label{ch:Methods}
\section{Methodology}\label{sec:Methodology}
\section{Test tools}\label{sec:TestTools}

\subsection{Static Typing}\label{subsec:Static}
Programming languages can be classified by many criteria, one of which is their
type systems. One such classification is static versus dynamic typing. Our
implementation language, Haskell, has a static type system. Types will be
checked at compile-time, allow us to catch errors even before the code is run,
reducing the errors that need to be found and fixed using testing techniques. 

\edcomm{YT}{``Static analysis'' is the analysis of a program without running it,
  ie, analysis of the program text. We won't be doing any static analysis, I
  believe... QuickCheck is absolutely unrelated to static analysis.}
\subsection{Formal verification}\label{subsec:FormalVer}
A part of our project deals with generating source code annotated with the proof
of derivation of that source code, which will act as a correctness proof for the
system. In particular, when we generate code to restore a database violation
using ECA rules, then the generated code will have a proof associated with it,
which details how that code was derived from the original specification given by
the user.

\subsection{Random Testing}\label{subsec:RandTest}
Random testing allows us to easily run a very large number of tests without
writing them by hand, and also has the advantage of not producing biased test
cases, like a programmer is likely to do.

We will be using QuickCheck \todo{add reference hackage} for random testing. The existing Ampersand code base
using QuickCheck for testing, therefore, using QuickCheck has the added benefit
of easier integration with the existing Ampersand code base.

QuickCheck allows the programmers to provide a specification of the program, in
the form of properties. A property is essentially a boolean valued Haskell
function of any number of arguments. QuickCheck can test that these properties
hold in a large number of randomly generated cases. QuickCheck also takes great
care to produce a large variety of test cases, and generally produces good code
coverage.

\edcomm{YT}{Don't assume that this super obvious example will make sense... better to leave it out.}

%% \begin{lstlisting}
%% quickCheck (\s -> length (take5 s) == 5)
%% Falsifiable, after 0 tests:
%% ""
%% \end{lstlisting}

%% Here we test that the length of a list after implementing ``take 5'' should be 5 however this fails when the initial list is empty or has less than 5 elements.
\subsection{Unit Testing}\label{subsec:UnitTest}
Unit testing is comprised of feeding some data to the functions being tested and
compare the actual results returned to the expected resultd.
We will be using HUnit for unit testing of the new source code \edcomm{YT}{HUnit does
not do *automated* testing.}in Ampersand. HUnit is a library providing unit
testing capabilities in Haskell.  It is an adaption of JUnit to Haskell that
allows you to easily create, name, group tests, and execute them.

\section{Requirements}\label{sec:Reqs}
\subsection{Functional requirements}\label{subsec:FunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[F1] provably implement the desired algorithm.
\item[F2] accept its input in the existing ADL file format.
\item[F3] produce an output compatible with the existing pipeline. 
\item[F4] be a pure function; it should not have side effects.  
\item[F5] not introduce appreciable performance degradation. 
\item[F6] provide diagnostic information about the algorithm to
the user, if the user asks for such information.
\end{description}

\subsection{Non-Functional requirements}\label{subsec:NonFunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[N1] produce output which will be easily understood by the typical user,
  such as a requirements engineer, and will not be misleading or confusing.  
\item[N2] be composed of easily maintainable, well documented code.
\item[N3] compile and run in the environment currently used to develop
  Ampersand.
\item[N4] annotated generated code with proofs of correctness or derivations,
  where appropriate. 
\item[N5] automatically fix database violations in the mock database of the
  prototype. 
\end{description}

\section{Data recording}\label{sec:DataRec}
\section{Constraints}\label{sec:Constraints}
\section{Evaluation}\label{sec:Evaluation}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%	5.) System Test Description
%%
%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{System Test Descriptions}\label{ch:SystemTests}
\section{Black Box Test} \edcomm{JG}{Functional testing; should uncover errors that occur in implementing requirements or design specification; not concerned with how process work but with the results; focuses on functional requirements and normal behaviour; I think dynamic analysis should be incorporated here as it checks test cases against expected behaviour; exhaustive testing?; }
\subsection{Control}
\subsection{Inputs}
\subsection{Outputs}
\subsection{Procedures}
\section{White Box Test}\edcomm{JG}{Structural testing; uncovers errors during implementation of the program, concerned with how processig ocurs, evalutes whether the structure is sound, focuses on non-functional requirements for the system; focuses on abnormal or extreme behaviour; static testing should go here -- its a code walk through, we can get Kahl to walk through it in theory and see if he can read it and understand it -- if he can it is maintainable and that is our quality accessment}
\subsection{Control}
\subsection{Inputs}
\subsection{Outputs}
\subsection{Procedures}

\bibliographystyle{alpha}
\bibliography{TestPlan}

\end{document}
