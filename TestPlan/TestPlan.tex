\documentclass[12pt]{report}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{natbib}%Bibtex
\usepackage{float}
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{booktabs}
\usepackage{tabto}
\usepackage{tocloft} %% This package prevents table of contents from generating a page break
\usepackage{caption}
\usepackage{listings}
\input{../ltx/setupComments}
\usepackage{geometry}
\usepackage{changepage}
\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

\newcolumntype{C}[1]{>{\centering}p{#1}} %% For use with tabularx
%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
\edcommsfalse
\begin{document}

\pagenumbering{roman} %% Roman numerals before actual document starts
\begin{titlepage}\begin{center}
\thispagestyle{empty} %% No page no. on title

\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Test Plan

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill 
%% 

%% We acknowledge that this document uses material from the Volere Requirements
%% Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
%% Limited.

%% \vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 30th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history

\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 27 / 10 / 2015 & Reorganized document \\\hline
Yuriy Toporovskyy & 27 / 10 / 2015 & Initial version - template \\\hline
\end{tabular}
\end{center}\end{table}

\newpage

\tableofcontents
\listoffigures
\listoftables

\newpage
\pagenumbering{arabic} %% Arabic numerals in actual document

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	1.) General Information 
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{General Information}

%1.1 Purpose/Summary
\section{Purpose} 
This document outlines the test plan for ECA for Ampersand, including our
general approach to testing, system test cases, and a specification of
methodology and constraints. This test plan specifically targets our
contribution to Ampersand, namely ECA -- elements of Ampersand, such as design
artifact generation, will not be tested. 

%% %1.3 Objectives
\section{Objectives}
\subsubsection*{Preparation for testing}
The primary objective of this test plan is to collect all relevant information
in preperation of the actual testing process, in order to facilitate this process.

\subsubsection*{Communication}
This test plan intends to clearly communicate to all developers of ECA for Ampersand 
their intended role in the testing process. 

\subsubsection*{Motivation}
The testing approach is motivated by constraints and requirements outlined in the
Software Requirements Specification. This document seeks to clearly demonstrate
this motivation.

\subsubsection*{Environment}
This test plans outlines the resources, tools, and software required for the
testing process. This includes any resources needed to perform automated testing. 

\subsubsection*{Scope}
This test plan intends to better describe the scope of our contribution, ECA,
within Ampersand. 

%% %1.3  Definitions, Acronyms, and abbreviations 
\section{Acronyms, Abbreviations, and Symbols}

\begin{description}
\item[SRS] Software Requirements Specification. Document regarding requirements, constraints, and project objectives.
\item[ECA Rule] Event-Condition-Action Rule. A rule which describes how to
  handle a constraint violation in a database. See SRS for details.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	2.) Plan
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Plan}

\section{Software Description}
Ampersand is a software tool which converts a formal specification of business
entities and rules, and compiles it into different design artifacts, as well as
a prototype web application.

This prototype implements the business logic in the original specification, in
the form of a relational database with a simple web-app front-end.

A particular class of relational database violations can be automatically
restored; the algorithm for computing the code to fix these violations is called
AMMBR \cite{amber}.  This class of violations is realized within Ampersand as
ECA rules -- our contribution to Ampersand will add support for ECA rules, in
both the Ampersand back-end and the generated prototype.

\section{Test Team} 

The test team which will execute the strategy outline in this document is comprised of
\begin{itemize}
\item Yuriy Toporovskyy  
\item Yash Sapra        
\item Jaeden Guo         
\end{itemize}

\section{Test Schedule}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Methods and constraints}
\section{Methodology}
\section{Test tools}

\subsection{Static Typing}
Programming languages can be distinguished by their type systems. They can either be Dynamically typed or statically typed. The language for implementation of our project is \textbf{Haskell}. Having a ``static'' type system, types will be checked at compile-time. This will allow us to catch error even before the code is run, reducing the chances of inducing errors into the existing system.

\subsection{Static Analysis}
Static analysis  includes syntax checking and generating correctness proof in the form of pre and post condition. A part of our project deals with generating annotated source code that will act as a correctness proof for the system. The annotated source code will have the functions explained with the help of pre and post condition pairs along with invariants. The invariants will become a part of QuickCheck, a properties testing tool for Haskell, at a later stage of the project.

\textbf{QuickCheck} allows the programmers to provide a specification of the program, in the form of properties. The functions should satisfy these properties. QuickTest can test that these properties hold in a large number of randomly generated cases. Specifications are expressed in Haskell, using combinators defined in the QuickCheck library. Since Ampersand uses QuickCheck for testing purpose, we have explained a sample test using QuickTest below[\todo {add reference hackage}].

\begin{lstlisting}
quickCheck (\s -> length (take5 s) == 5)
Falsifiable, after 0 tests:
""
\end{lstlisting}

Here we test that the length of a list after implementing ``take 5'' should be 5 however this fails when the initial list is empty or has less than 5 elements.


\subsection{Unit Testing}
The group will be using HUnit for automated unit testing of the new source code in Ampersand. The testing tool will be critical in analyzing the effects of our project on the existing system.  In unit testing, a test case is the unit of test execution. That is, distinct test cases are executed independently and the failure of one is independent of the failure of any other test case.

\textbf{HUnit} is a library providing unit testing capabilities in Haskell. 
It is an adaption of JUnit to Haskell that allows you to easily create, name, group tests and execute them.
The idea of using HUnit is similar to that of JUnit in Java; we feed some data to the functions that we're testing 
and compare the actual results returned to the results we're expecting. 
\section{Requirements}
\subsection{Functional requirements}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\subsection{Properties testing}


\begin{description}
\item[F1] provably implement the desired algorithm.
\item[F2] accept its input in the existing ADL file format.
\item[F3] produce an output compatible with the existing pipeline. 
\item[F4] be a pure function; it should not have side effects.  
\item[F5] not introduce appreciable performance degradation. 
\item[F6] provide diagnostic information about the algorithm to
the user, if the user asks for such information.
\end{description}

\subsection{Non-Functional requirements}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[N1] produce output which will be easily understood by the typical user,
  such as a requirements engineer, and will not be misleading or confusing.  
\item[N2] be composed of easily maintainable, well documented code.
\item[N3] compile and run in the environment currently used to develop
  Ampersand.
\item[N4] annotated generated code with proofs of correctness or derivations,
  where appropriate. 
\item[N5] automatically fix database violations in the mock database of the
  prototype. 
\end{description}

\section{Data recording}
\section{Constraints}
\section{Evaluation}

%% %%%%%%%%%%%%%%%%%%%%%%%%
%% %
%% %	5.) System Test Description
%% %
%% %%%%%%%%%%%%%%%%%%%%%%%%

\chapter{System Test Descriptions}

\bibliographystyle{alpha}
\bibliography{TestPlan}

\end{document}
