\documentclass[12pt]{report}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{natbib}%Bibtex
\usepackage{float}
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{booktabs}
\usepackage{tabto}
\usepackage{tocloft} %% This package prevents table of contents from generating a page break
\usepackage{caption}
\usepackage{listings}
\input{../ltx/setupComments}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

\newcolumntype{C}[1]{>{\centering}p{#1}} %% For use with tabularx
%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
\edcommsfalse
\begin{document}

\pagenumbering{roman} %% Roman numerals before actual document starts
\begin{titlepage}\begin{center}
\thispagestyle{empty} %% No page no. on title

\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Test Plan

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill 
%% 

%% We acknowledge that this document uses material from the Volere Requirements
%% Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
%% Limited.

%% \vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 30th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history

\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 27 / 10 / 2015 & Reorganized document \\\hline
Yuriy Toporovskyy & 27 / 10 / 2015 & Initial version - template \\\hline
\end{tabular}
\end{center}\end{table}

\newpage

\tableofcontents
%% \listoffigures 
%% \listoftables 

\newpage
\pagenumbering{arabic} %% Arabic numerals in actual document

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	1.) General Information 
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{General Information}\label{ch:General}

%1.1 Purpose/Summary
\section{Purpose}\label{sec:Purpose}
This document outlines the test plan for ECA for Ampersand, including our
general approach to testing, system test cases, and a specification of
methodology and constraints. This test plan specifically targets our
contribution to Ampersand, namely ECA -- elements of Ampersand, such as design
artifact generation, will not be tested. 

%% %1.3 Objectives
\section{Objectives}\label{sec:Objectives}
\subsubsection*{Preparation for testing}
The primary objective of this test plan is to collect all relevant information
in preperation of the actual testing process, in order to facilitate this process.

\subsubsection*{Communication}
This test plan intends to clearly communicate to all developers of ECA for Ampersand 
their intended role in the testing process. 

\subsubsection*{Motivation}
The testing approach is motivated by constraints and requirements outlined in the
Software Requirements Specification. This document seeks to clearly demonstrate
this motivation.

\subsubsection*{Environment}
This test plans outlines the resources, tools, and software required for the
testing process. This includes any resources needed to perform automated testing. 

\subsubsection*{Scope}
This test plan intends to better describe the scope of our contribution, ECA,
within Ampersand. 

%% %1.3  Definitions, Acronyms, and abbreviations 
\section{Definitions}\label{sec:Abbrev}

\subsubsection*{SRS}
Software Requirements Specification. Document regarding requirements, constraints, and project objectives.

\subsubsection*{RA}
Relation algebra. The mathematical language used in ADL files to specify business rules. 

\subsubsection*{PA}
Process algebra. The mathematical language used by ECA rules to describe the
action to be taken to fix violations. A ``PA clause'' (also written as
``PAclause''), or process algebra clause, is an imperative-style language which
is taken to represent \emph{mathematical} process algebra in Ampersand. The
syntax of PA clauses, in EBNF notation, is as follows:

%% YT: this is a subset of the actual language... I don't actually understand the rest

\begin{lstlisting}[basicstyle=\ttfamily]
PAclause ::= 'One' '(' PAclause { ',' PAclause } ')' ; 
           | 'Choice' '(' GPAclause { ',' GPAclause } ')' ;  
           | 'All' '(' PAclause { ',' PAclause } ')' ;  
           | ('Ins' | 'Del') '(' RExpr ',' RAtom ')' ; 
           | 'Nop'  
           | 'Blk' 
GPAclause ::= RExpr '->' PAclause ; 
\end{lstlisting}
where ``RExpr'' represents RA expressions, and ``RAtom'' (RA atom) represents
\emph{atomic} RA expressions (that is, terms with no operators).

\begin{table}[ht!]\begin{center}\label{tab:PASemantics}
\caption{Semantics of PAclause terminals}
\begin{tabularx}{\textwidth}{lX}
One$(p_0 \ldots p_n)$ & Execute exactly one of $p_0 \ldots p_n$. \\
Choice$(g_0 \rightarrow p_0 \ldots g_n \rightarrow p_n)$ & Execute exactly
  one of $p_i$, such that $g_i$ is a non-empty RA term. \\
All$(p_0 \ldots p_n)$ & Execute all of $p_0 \ldots p_n$. \\
$<$Ins/Del$>(e,r)$ & Insert or delete the expression $e$ from the relation $r$. \\
Nop & Do nothing. \\
Blk & The null command, which blocks forever. 
\end{tabularx}
\end{center}\end{table}

The semantics of process algebra says that the ``choice'' operators (One and
Choice) execute their subclauses concurrently; if \emph{any} subclause
completes, the PA clause has restored the violation.

\subsubsection*{ECA Rule}
 Event-Condition-Action Rule. A rule which describes how to handle a constraint
 violation in a database. The syntax of ECA rules is as follows:

\begin{lstlisting}[basicstyle=\ttfamily]
ECArule ::= 'On' ('Ins' | 'Del') 
            '(' RExpr ',' RAtom ')'
            'Do' PAclause    
\end{lstlisting}

\subsubsection*{HUnit}
 A Haskell library for unit testing. See section \ref{sec:TestTools}.
\subsubsection*{QuickCheck}
 A Haskell library for running automated, randomized tests. See section \ref{sec:TestTools}.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	2.) Plan
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Plan}\label{ch:Plan}

\section{Software Description}\label{sec:SoftwareDesc}
Ampersand is a software tool which converts a formal specification of business
entities and rules, and compiles it into different design artifacts, as well as
a prototype web application.

This prototype implements the business logic in the original specification, in
the form of a relational database with a simple web-app front-end.

A particular class of relational database violations can be automatically
restored; the algorithm for computing the code to fix these violations is called
AMMBR \cite{amber}.  This class of violations is realized within Ampersand as
ECA rules -- our contribution to Ampersand will add support for ECA rules, in
both the Ampersand back-end and the generated prototype.

\edcomm{YT}{Probably should merge Test Team and Test Schedule}
\section{Test Team}\label{sec:TestTeam}

The test team which will execute the strategy outline in this document is comprised of
\begin{itemize}
\item Yuriy Toporovskyy  
\item Yash Sapra        
\item Jaeden Guo         
\end{itemize}

\section{Test Schedule}\label{sec:TestSched}

%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Methods and constraints}\label{ch:Methods}
\section{Methodology}\label{sec:Methodology}
\section{Test tools}\label{sec:TestTools}

\subsection{Static Typing}\label{subsec:Static}
Programming languages can be classified by many criteria, one of which is their
type systems. One such classification is static versus dynamic typing. Our
implementation language, Haskell, has a static type system. Types will be
checked at compile-time, allow us to catch errors even before the code is run,
reducing the errors that need to be found and fixed using testing techniques. 

\edcomm{YT}{``Static analysis'' is the analysis of a program without running it,
  ie, analysis of the program text. We won't be doing any static analysis, I
  believe... QuickCheck is absolutely unrelated to static analysis.}
\subsection{Formal verification}\label{subsec:FormalVer}
A part of our project deals with generating source code annotated with the proof
of derivation of that source code, which will act as a correctness proof for the
system. In particular, when we generate code to restore a database violation
using ECA rules, then the generated code will have a proof associated with it,
which details how that code was derived from the original specification given by
the user.

\subsection{Random Testing}\label{subsec:RandTest}
Random testing allows us to easily run a very large number of tests without
writing them by hand, and also has the advantage of not producing biased test
cases, like a programmer is likely to do.

We will be using QuickCheck \cite{hackage} for random testing. The existing 
Ampersand code base
using QuickCheck for testing, therefore, using QuickCheck has the added benefit
of easier integration with the existing Ampersand code base.

QuickCheck allows the programmers to provide a specification of the program, in
the form of properties. A property is essentially a boolean valued Haskell
function of any number of arguments. QuickCheck can test that these properties
hold in a large number of randomly generated cases. QuickCheck also takes great
care to produce a large variety of test cases, and generally produces good code
coverage. QuickCheck will be used for individualized module testing and well as 
provide a fair array of random tests for the combination of all modules 
\cite{hackage}.

\edcomm{YT}{Don't assume that this super obvious example will make sense... better to leave it out.}

%% \begin{lstlisting}
%% quickCheck (\s -> length (take5 s) == 5)
%% Falsifiable, after 0 tests:
%% ""
%% \end{lstlisting}

%% Here we test that the length of a list after implementing ``take 5'' should be 5 however this fails when the initial list is empty or has less than 5 elements.
\subsection{Unit Testing}\label{subsec:UnitTest}
Unit testing is comprised of feeding some data to the functions being tested and
compare the actual results returned to the expected resultd.
We will be using HUnit for unit testing of the new source code \edcomm{YT}{HUnit does
not do *automated* testing.}in Ampersand. HUnit is a library providing unit
testing capabilities in Haskell.  It is an adaption of JUnit to Haskell that
allows you to easily create, name, group tests, and execute them.

\section{Requirements}\label{sec:Reqs}
\subsection{Functional requirements}\label{subsec:FunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[F1] provably implement the desired algorithm.
\item[F2] accept its input in the existing PAClause format.
\item[F3] produce an output compatible with the existing pipeline. 
\item[F4] annotated generated code with proofs of correctness or derivations,
where appropriate. 
\item[F5] automatically fix database violations in the mock database of the
prototype.
\item[F6] not introduce appreciable performance degradation. 
\item[F7] provide diagnostic information about the algorithm to
the user, if the user asks for such information.
\end{description}

\subsection{Non-Functional requirements}\label{subsec:NonFunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[N1] produce output which will be easily understood by the typical user,
  such as a requirements engineer, and will not be misleading or confusing.  
\item[N2] be composed of easily maintainable, well documented code.
\item[N3] compile and run in the environment currently used to develop
  Ampersand.
\item[N4] be a pure function; it should not have side effects.  
\end{description}

\section{Data recording}\label{sec:DataRec}
\section{Constraints}\label{sec:Constraints}
\section{Evaluation}\label{sec:Evaluation}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%	5.) System Test Description
%%
%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{System Test Descriptions}\label{ch:SystemTests}
\newcommand{\us}{\textunderscore}
\newcommand{\tabb}{\hspace{35pt}}
%% Environment for system test
\newcounter{sysTestNum}
\setcounter{sysTestNum}{1}

%% Commands for making ECA rules in math environments 
\newcommand{\ECAIns}[2]{\mathbf{Ins}(#1,#2)}
\newcommand{\ECADel}[2]{\mathbf{Del}(#1,#2)}
\newcommand{\ECAInsDel}[2]{\mathbf{\{Ins/Del\}}(#1,#2)}
\newcommand{\ECAOn}{\mathbf{On~}}
\newcommand{\ECADo}{\ECASpacer\mathbf{Do~}}
\newcommand{\ECANop}{\mathbf{Nop~}}
\newcommand{\ECASpacer}{\,\,\,\,}
\newcommand{\IRel}[1]{\mathbb{I}_{#1}}
\newcommand{\VRel}[2]{\mathbb{V}_{#1\times#2}}

\newcommand{\systemTest}[5]{
\section*{T\arabic{sysTestNum}~~~ #2}\label{sec:#1}
\addcontentsline{toc}{section}{T\arabic{sysTestNum}~~~ #2}
\stepcounter{sysTestNum}
\hspace{-6pt}\begin{tabular}{p{3cm}l}
\textbf{Test type}     &   #3 \\ 
\textbf{Schedule}      &   #4 \\
\textbf{Requirements}  &   #5 \\
\end{tabular}
}


Many test cases use domain specific language to indicate inputs and outputs, for
both clarity and brevity. This includes the syntax and semantics of ECA rules
and Abstract SQL. For the full syntax and semantics of these , as well as
related definitions, see section \ref{sec:Abbrev}.

%% %% Example usage....
%% \systemTest{T1}  %% Test label, should be unique
%% {EFA Black box test}  %% Test name
%% {Black box/Functional, using dynamic analysis}  
%% {January 2016 }
%% {Functional}

%% The input shall consist of PAClauses (i.e. a data type) that is composed of 
%% ECA rules. These ECA rules consist of a condition (i.e. ecaTriggr) that 
%% initiates a set of actions to be taken (i.e. ecaAction) based on the violation 
%% (i.e. ecaDelta). Please see example below for further elaboration.

%% The functional output shall be a SQL command template generated through a 
%% Haskell script, for each type of ECA violations

%% QuickCheck  is used to test the functionality of individual functions; it is a 
%% package that provides a library for testing program properties. The programmer 
%% is able to provide properties they want tested in their program specification, 
%% and QuickCheck generates numerous random cases to test that the property 
%% holds\cite{hackage}. 

%% \edcomm{JG}{So.. I originally put the entire example 
%% in Procedure and latex got very mad at me... so if you wanna put all that in 
%% here, 
%% feel free too or add/give a brief description (or I will) for those that do not 
%% want an example cause they find this self-explanatory =) 

%% Also, there are comments, but the comments can be taken out then shown for the 
%% white box test as a walk through sorta thing, am I making sense?}


%%%%%%%%%%%%%%%%% Test 1 
\systemTest{ecaInsIntoAll}
{ECA rule executing ``All'' subclauses}  %% Test name
{Dynamic, white box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAIns{\Delta}{r_0} \ECADo \mathbf{All} ( \ECAIns{e_1}{r_1}, \ECAIns{e_2}{r_2} )$
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & r_0, r_1, r_2    & ::= \text{Atomic Relation} \\ 
             & e_1, e_2, \Delta & ::= \text{Expression} \\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is an abstract SQL function of the form:
\begin{verbatim}
f (delta, r_0):
  INSERT INTO <r_1_table> VALUES <e_1_query>;
  INSERT INTO <r_2_table> VALUES <e_2_query>;
\end{verbatim}

\vspace{-12pt}\subsubsection*{Description}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.

%%%%%%%%%%%%%%%%% Test 2
\systemTest{ecaEmptyClause}
{ECA rule with empty PA clause} 
{Dynamic, white box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAInsDel{\Delta}{r_0} \ECADo \ECANop $
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & C_0, C_1 & ::= \text{Concept} \\ 
             & r_0      & ::= \text{Atomic Relation} \\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is the empty abstract SQL statement; that is, a statement of the form:
\begin{verbatim}
f (delta, r_0): {} \\ Do nothing
\end{verbatim}

\vspace{-12pt}\subsubsection*{Input}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.


%%%%%%%%%%%%%%%%% Test 3
\systemTest{ecaIdentityRel}
{ECA rule inserting into Identity relation} 
{Dynamic, white box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAInsDel{\Delta}{r_0} \ECADo \ECAIns{e_0}{\IRel{C_0}} $
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & C_0 & ::= \text{Concept} \\ 
             & r_0 & ::= \text{Atomic Relation}\\ 
             & e_0 & ::= \text{Expression}\\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is an abstract SQL statement of the form:
\begin{verbatim}
f (delta, r_0):
  {INSERT INTO/DELETE FROM} <C_0_Population> VALUES <e_0_query>;
\end{verbatim}

\noindent where \verb|C_0_Population| is the table corresponding to $\IRel{C_0}$. 


\vspace{-12pt}\subsubsection*{Description}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.




%% Example usage....
%% \systemTest{T1}  %% Test label, should be unique
%% {EFA Black box test}  %% Test name
%% {Black box/Functional, using dynamic analysis}  
%% {January 2016 }
%% {Functional}
%% {The input shall consist of PAClauses (i.e. a data type) that is composed of 
%% ECA rules. These ECA rules consist of a condition (i.e. ecaTriggr) that 
%% initiates a set of actions to be taken (i.e. ecaAction) based on the violation 
%% (i.e. ecaDelta). Please see example below for further elaboration.}
%% {The functional output shall be a SQL command template generated through a 
%% Haskell script, for each type of ECA violations}
%% {QuickCheck  is used to test the functionality of individual functions; it is a 
%% package that provides a library for testing program properties. The programmer 
%% is able to provide properties they want tested in their program specification, 
%% and QuickCheck generates numerous random cases to test that the property 
%% holds\cite{hackage}. }
%% \edcomm{JG}{So.. I originally put the entire example 
%% in Procedure and latex got very mad at me... so if you wanna put all that in 
%% here, 
%% feel free too or add/give a brief description (or I will) for those that do not 
%% want an example cause they find this self-explanatory =) 

%% Also, there are comments, but the comments can be taken out then shown for the 
%% white box test as a walk through sorta thing, am I making sense?}

%% \underline{Example 1.}
%% \paragraph{}
%% Input ECA Rule: No action needs to be taken when a data relation is 
%% deleted because 
%% an order placed by a client has been canceled.
%% 	\begin{verbatim}
%% 	ECA { ecaTriggr = On Del rel_orderedBy_Order_Client
%% 	, ecaDelta  = vio_Delta_Order_Client
%% 	, ecaAction = Nop []
%% 	, ecaNum    = 2
%% 	} 
%% 	\end{verbatim} 	
%% \underline{Brief Explanation of Example 1:} \newline \newline \indent
%% The ecaTriggr specifies an event that takes place such as the deletion of a 
%% Client's order; the action to be taken is "Nop[]", which means no 
%% (mathematical) operations is to be performed on the data set. The ecaNum = 2, 
%% indicates the ECA rule that has been violated which is number 2. The deletion 
%% of data must be consistent and take place across all regions which it will 
%% affect, for example of c = (a,b) where a is an element in set a (a $\in$ A) and 
%% b is an element in set B (b $\in$ B), c may no longer exist. For this example, 
%% we shall call c, cost which is the tuple (a,b) where a is an item and b is the 
%% cost per weight unit of the item. Both a and b are needed to determine the cost 
%% because cost is based on the item and its weight per unit. If the weight no 
%% longer exists (i.e. it was deleted), the data table cost (c) no longer shows 
%% proper cost for the item in question. If the cost table was entirely devoted to 
%% tuples of set A and B, then the entire table needs to be adjusted for a new set 
%% of weights or the table must be deleted. EFA will output SQL commands to delete 
%% the necessary components.

%% Example 1. Possible Recursive Deletion SQL Output:
%% Please note that this is a rolled out generic example of what EFA may produce, 
%% the actual code EFA provides may be very different.
%% \begin{verbatim}
%% CREATE OR REPLACE PROCEDURE delete_cascade(
%% table_owner          VARCHAR2,
%% parent_table         VARCHAR2,
%% where_clause         VARCHAR2
%% ) IS
%% -- ex:  execute delete_cascade('MY_SCHEMA', 'MY_MASTER', 'where ID=1'); */

%% child_cons     VARCHAR2(30);
%% parent_cons    VARCHAR2(30);
%% child_table    VARCHAR2(30);
%% child_cols     VARCHAR(500);
%% parent_cols    VARCHAR(500);
%% delete_command VARCHAR(10000);
%% new_where_clause VARCHAR2(10000);

%% -- gets the foreign key constraints on other tables which depend on columns in 
%% parent_table --
%% CURSOR cons_cursor IS
%% SELECT owner, constraint_name, r_constraint_name, table_name, delete_rule
%% FROM all_constraints
%% WHERE constraint_type = 'R'
%% AND delete_rule = 'NO ACTION'
%% AND r_constraint_name IN (SELECT constraint_name
%% FROM all_constraints
%% WHERE constraint_type IN ('P', 'U')
%% AND table_name = parent_table
%% AND owner = table_owner)
%% AND NOT table_name = parent_table; -- ignore self-referencing constraints


%% -- for the current constraint, gets the child columns and corresponding parent 
%% columns
%% CURSOR columns_cursor IS
%% SELECT cc1.column_name AS child_col, cc2.column_name AS parent_col
%% FROM all_cons_columns cc1, all_cons_columns cc2
%% WHERE cc1.constraint_name = child_cons
%% AND cc1.table_name = child_table
%% AND cc2.constraint_name = parent_cons
%% AND cc1.position = cc2.position
%% ORDER BY cc1.position;
%% BEGIN
%% -- loops through all the constraints that refer to parent table
%% FOR cons IN cons_cursor LOOP
%% child_cons   := cons.constraint_name;
%% parent_cons  := cons.r_constraint_name;
%% child_table  := cons.table_name;
%% child_cols   := '';
%% parent_cols  := '';

%% -- loops through the child/parent column pairs; builds column list of del 
%% statements
%% FOR cols IN columns_cursor LOOP
%% IF child_cols IS NULL THEN
%% child_cols  := cols.child_col;
%% ELSE
%% child_cols  := child_cols || ', ' || cols.child_col;
%% END IF;

%% IF parent_cols IS NULL THEN
%% parent_cols  := cols.parent_col;
%% ELSE
%% parent_cols  := parent_cols || ', ' || cols.parent_col;
%% END IF;
%% END LOOP;

%% /* construct the WHERE clause of the delete statement, including a subquery to 
%% get the related parent rows */
%% new_where_clause  :=
%% 'where (' || child_cols || ') in (select ' || parent_cols || ' from ' || 
%% table_owner || '.' || parent_table ||
%% ' ' || where_clause || ')';

%% delete_cascade(cons.owner, child_table, new_where_clause);
%% END LOOP;

%% --makes delete statement for the current table 
%% delete_command  := 'delete from ' || table_owner || '.' || parent_table || ' ' 
%% || where_clause;

%% -- print delete command
%% DBMS_OUTPUT.put_line(delete_command || ';');

%% EXECUTE IMMEDIATE delete_command;

%% -- issue commit here
%% END;
%% \end{verbatim}


%% Example 2 Input ECA Rule: An ECA rule that specifies that all clauses must be 
%% executed based on conditions. Insertion of deletion must take place to restore 
%% invariants. 


%% \begin{verbatim}
%% ECA {	ecaTriggr = On Ins rel_orderedAt_Order_Vendor, 
%% 		ecaDelta  = vio_Delta_Order_Vendor, 
%% 		ecaAction = ALL [ Do Ins rel_I_Order (EDif 
%% 			(EIsc (ECps	(EDcD vio_Delta_Order_Vendor,EFlp(EDcD 
%% 						vio_Delta_Order_Vendor)),
%% 						EDcI cpt_Order),EDcI cpt_Order
%% 							))[], Do Ins rel_I_Vendor (EDif (EIsc (ECps (EFlp 
%% 							(EDcD 
%% 							vio_Delta_Order_Vendor),EDcD 
%% 							vio_Delta_Order_Vendor),EDcI cpt_Vendor),EDcI 
%% 							cpt_Vendor))[]][], ecaNum    = 3}
%% \end{verbatim}

%% Brief Explanation of Example 2: 

%% \systemTest{T2}  %% Test label, should be unique
%% {EFA White box test} 
%% {White Box/Non-functional, using static analysis}  
%% {January 2016}
%% {Non-functional using static analysis}
%% {N/A}
%% {The desired output depends on the specific targeted non-functional specification}
%% {The test shall be performed by an third party (Dr.Kahl), where Dr. Kahl shall perform a code walk through where he will be able to confirmed the validity of the code that is written, the correctness and the maintainability of the code. Structural testing uncovers errors during implementation of the program, and focuses on how the process occurs, and evaluates structure of the program. The white box test is also implemented by teach individual of our team and shall focus on abnormal or extreme behaviour. The white box test focuses on static program analysis which can be performed without actually executing the program. The main non-functional requirement for EFA is code maintainability and correctness, which requires heavy documentation alongside the source code. }

\systemTest
{T3}{EFA System Compatibility}
{Functional/Black box/ }
{Dec 2015}
{F3}
\vspace{-12pt}\subsubsection*{Input}
ADL File Input 1: \\
	Based on the Rule: Only members who have relevant experience may apply for 
	this 
	job \\
	Using Sets: JOBS-AVAIL, APPLICANTS, EMPLOYEES-WITH-RELEVANT-EXPERIENCE \\
	With ECA rules:\\
	ADL Files Input 2:\\
	Based on the Rule: Only members who have relevant experience may apply for 
	this 
	job \\
	Using Sets: JOBS-AVAIL, APPLICANTS, EMPLOYEES-WITH-RELEVANT-EXPERIENCE \\
	With ECA rules: APPLICANTS must be a member of both 
	EMPLOYEES-WITH-RELEVANT-EXPERIENCE AND have a relation to (i.e. applied 
	for) 
	JOBS-AVAIL \\
	
\vspace{-12pt}\subsubsection*{Output}
EFA\ User\ Output\ for\ Input\ 1: \\
	Reading $<$file$>$.adl.. \\
	Generating.. \\
	Rules Done.. \\
	Sets Done.. \\
	No Errors \\
	No Violations \\
	EFA\ User\ Output\ for\ Input\ 2: \\
	Reading $<$file$>$.adl..\\
	Generating.. \\
	Rules Done.. \\
	Sets Done.. \\
	ECA Rules Done.. \\
	No Errors \\
	No Violations \\
	
\vspace{-12pt}\subsubsection*{Description}
Two different version of the same script is given as input, the first is 
without ECA rules the second is with ECA rules that this project adds. Both of 
these scripts should pass through the Ampersand generator without causing 
errors or violations. If the second script which contains ECA rules 
successfully passes through each part of Ampersand then the new additions 
generated by EFA is compatible with the old Ampersand system.

\paragraph{}
\systemTest
{T7}
{EFA Pure Function}
{Dec 2015}
{F4}
{Two conditions must hold for a function to be considered a pure function 1. 
The function always evaluates to the same result given the same argument 
values, and 2. The evaluation of the result does not cause any semantically 
observable side effects (e.g. mutation). Since EFA in its smallest components 
uses mathematical constructs on expressions, the result is always a pure 
function. }
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:
 \begin{tabbing}
ECA = \{Condition that triggers action: Insertion of $<$new field into 
table$>$, 
\\	 \tabb \tabb Change that initiated trigger: Insertion of $<$e2$>$ into 
	current data scheme, \\
	\tabb \tabb \tabb	Action to be done : $\forall$  \\
		\tabb \tabb \tabb \tabb	\{(take the difference of the previous result 
		of the expressions \\
				\tabb \tabb \tabb \tabb \tabb(take result of intersection of 
				the returned result\\
\tabb \tabb \tabb \tabb \tabb \tabb(composition of the result \\
		\tabb \tabb \tabb \tabb \tabb \tabb \tabb	(Simple declaration of the 
		result 
		of the conversion \\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb \tabb(convert expression e2 using the 
identity relation  
							\\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb \ of e1 \\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb ) \\
\tabb \tabb \tabb \tabb \tabb \tabb )\\
\tabb \tabb \tabb \tabb \tabb  with e1) \\
\tabb \tabb \tabb \tabb	with e1) \\
\tabb \tabb \tabb  with e1 where e1 is another expression)\} \\
	
\tabb \} 
	\end{tabbing}

\vspace{-12pt}\subsubsection*{Output}

asdfasdf

\systemTest{T8}{EFA User Feed Back}
{Functional}
{January 2016}
{F6,N1}
\vspace{-12pt}\subsubsection*{Brief Explanation Concerning Context}
Only those who are qualified can be cast into roles, the actor must have 
relevant experience.
\vspace{-12pt}\subsubsection*{Input}
The input shall be ECA rules specifying invariants that must be maintained 
throughout the program.

\noindent
Example concerning how roles are cast for a theater performance:

\noindent
User Input:

\noindent
   RULE "who's cast in roles" : cast; instantiates |- qualifies;comprises~
   MEANING "an Actor may appear in a Performance of the Play only if the Actor 
   is skilled for a Role that the Play comprises "


\noindent
EFA INPUT:
\begin{tabbing}
   ECA = \{  \\ \tabb \tabb ECA Trigger: if cast member does not have relevant 
   experience or 
   enough experience \\
\tabb \tabb  ECA Violation: lack of experience \\
\tabb \tabb  ECA Action: Remove actors without enough relevant experience \\ 
\tabb \ \ \}
\end{tabbing}
\vspace{-12pt}\subsubsection*{Output}
\underline{User feed back if file has no errors:}\\
Reading file theatreCasting.adl.. \\
Done. \\
Done. \\

\noindent
\underline{User feed back if file has errors:} \\
Reading file theater.adl \\
Error(s) found:\\
Type error, cannot match:\\
the concept "Role" (Tgt of qualifies)\\
and concept "Performance" (Src of instantiates)\\
if you think there is no type error, add an order between concepts "Role" and 
"Performance".\\
Error at symbol () in file theater.adl at line 26 : 44 \\
============================== \\
No declarations match the relation: actor\\
Error at symbol () in file theater.adl at line 26 : 62\\
==============================\\
ECA Rule Violation: \\
Error at Rule declaration and structure in file theater.adl at line 33 : 41\\
Error: Structure and Meaning do not match\\

\systemTest{T9}{EFA Code Walk-through}
{Non-functional}
{January 2016}
{N2}
\vspace{-12pt}\subsubsection*{Brief Explanation}
Input and output are not available for this test, as it requires each member of 
the design team to walk through the code line by line to check if it is easy to 
understand by another programmer and well documented. If it is easy to read and 
understand but not only the individual who wrote it but those around them, then 
it should be easy to maintain. 


\systemTest{T10}{Degradation Test}
{Non-functional}
{First Week of February 2016 }
{F6}
\vspace{-12pt}\subsubsection*{Brief Explanation}
Degradation shall be measured through a comparison of Ampersand before EFA and 
Ampersand after EFA. The amount of time Ampersand takes to compile a prototype 
will measure performance degradation; if Ampersand takes substantially longer 
to compile after the addition of EFA then it is an appreciable difference. A 
Linux distribution will be used to time multiple trials of Ampersand with and 
without EFA. The test materials used will be taken off of the Ampersand-models 
github.

\systemTest{T11}{EFA Annotated Code}
{Non-functional}
{January 2016}
{N4}
\vspace{-12pt}\subsubsection*{Description}
There is no input, however there will be annotations available for output, this 
is used for debugging purposes and the user will never see this.

\end{document}
