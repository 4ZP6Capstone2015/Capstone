\documentclass[12pt]{report}
\usepackage{xcolor} % for different colour comments
\usepackage{parskip} % Space between each paragraph.
%\usepackage{hardwrap} % for text length of 80 pts
\usepackage[margin=1.2in]{geometry}
\usepackage{hyperref}
\usepackage{../ltx/edcomms}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{natbib}%Bibtex
\usepackage{float}
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{booktabs}
\usepackage{tabto}
\usepackage{tocloft} %% This package prevents table of contents from generating a page break
\usepackage{caption}
\usepackage{listings}
\input{../ltx/setupComments}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{amsbsy}
\usepackage{amssymb}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[fleqn]{amsmath}
\usepackage{graphicx}
\graphicspath{ {../figures/} }
\setlength{\parindent}{15pt} % parskip sets this to 0. 15 is default.

\newcolumntype{C}[1]{>{\centering}p{#1}} %% For use with tabularx
%%%%%%%%%%%%%%%	START OF DOCUMENT %%%%%%%%%%%%%%%%%%%%
\edcommsfalse
\begin{document}

\pagenumbering{roman} %% Roman numerals before actual document starts
\begin{titlepage}\begin{center}
\thispagestyle{empty} %% No page no. on title

\vspace*{1cm}

{\Huge\textbf{Ampersand Event-Condition-Action Rules}}

\vspace{0.5cm}
{\Large Test Plan

\vspace{1.5cm}
Yuriy Toporovskyy,\ Yash Sapra,\ Jaeden Guo}
\vfill 
%% 

%% We acknowledge that this document uses material from the Volere Requirements
%% Specification Template, copyright 1995 - 2012 the Atlantic Systems Guild
%% Limited.

%% \vspace{0.8cm}
\end{center}
CS 4ZP6 \\
October 30th, 2015 \\ 
Fall 2015 / Winter 2016 
\end{titlepage}

%% Revision history

\begin{table}[ht!]\begin{center}
\caption{Revision History}  
\begin{tabular}{|l|l|l|}\hline
\textbf{Author} & \textbf{Date} & \textbf{Comment} \\\hline 
Yuriy Toporovskyy & 27 / 10 / 2015 & Reorganized document \\\hline
Yuriy Toporovskyy & 27 / 10 / 2015 & Initial version - template \\\hline
\end{tabular}
\end{center}\end{table}

\newpage

\tableofcontents
%% \listoffigures 
%% \listoftables 

\newpage
\pagenumbering{arabic} %% Arabic numerals in actual document

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	1.) General Information 
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{General Information}\label{ch:General}

%1.1 Purpose/Summary
\section{Purpose}\label{sec:Purpose}
This document outlines the test plan for ECA for Ampersand, including our
general approach to testing, system test cases, and a specification of
methodology and constraints. This test plan is centered around our contribution 
to Ampersand and ignores other elements of the Ampersand process such as the 
artifacts that are generated.

%% %1.3 Objectives
\section{Objectives}\label{sec:Objectives}
\subsubsection*{Preparation for testing}
The primary objective of this test plan is to gather all relevant information 
that could aid in creating effective tests for EFA. EFA in this regard is 
modularized and tested as an individual component before it is tested within 
the Ampersand system. 

\subsubsection*{Communication}
This test plan intends to clearly communicate to all developers of ECA for 
Ampersand their intended role in the testing process. 

\subsubsection*{Motivation}
The testing approach is based on the constraints and requirements presented in 
the Software Requirements Specification \big( i.e. SRS\big). This document 
focuses on 
how the functional and non-functional requirements provided in the SRS will be 
tested for this project.

\subsubsection*{Environment}
This test plan outlines the resources, tools, and software required for the
testing process. This includes any resources needed to perform automated testing. 

\subsubsection*{Scope}
This test plan intends to better describe the scope of our contribution, ECA,
within the Ampersand system. 

%% %1.3  Definitions, Acronyms, and abbreviations 
\section{Definitions}\label{sec:Abbrev}

\subsubsection*{SRS}
Software Requirements Specification. Document regarding requirements, constraints, and project objectives.

\subsubsection*{EBNF}
Extended Backusâ€“Naur Form. A notation for specifying the syntax of languages, see \cite{ebnf}.

\subsubsection*{RA}
Relation algebra. The mathematical language used in ADL files to specify business rules. 

\subsubsection*{PA}
Process algebra. The mathematical language used by ECA rules to describe the
action to be taken to fix violations. A ``PA clause'' (also written as
``PAclause''), or process algebra clause, is an imperative-style language which
represents the \emph{mathematical} process which Ampersand uses. The syntax of
PA clauses, in EBNF notation, is as follows: \edcomm{JG}{What is EBNF?}
%% YT: this is a subset of the actual language... I don't actually understand the rest

\begin{lstlisting}[basicstyle=\ttfamily]
PAclause ::= 'One' '(' PAclause { ',' PAclause } ')' ; 
           | 'Choice' '(' GPAclause { ',' GPAclause } ')' ;  
           | 'All' '(' PAclause { ',' PAclause } ')' ;  
           | ('Ins' | 'Del') '(' RExpr ',' RAtom ')' ; 
           | 'Nop'  
           | 'Blk' 
GPAclause ::= RExpr '->' PAclause ; 
\end{lstlisting}
where ``RExpr'' represents RA expressions, and ``RAtom'' (RA atom) represents
\emph{atomic} RA expressions (i.e. terms with no operators).

\begin{table}[ht!]\begin{center}\label{tab:PASemantics}
\caption{Semantics of PAclause terminals}
\begin{tabularx}{\textwidth}{lX}
One$(p_0 \ldots p_n)$ & Execute exactly one of $p_0 \ldots p_n$. \\
Choice$(g_0 \rightarrow p_0 \ldots g_n \rightarrow p_n)$ & Execute exactly
  one of $p_i$, such that $g_i$ is a non-empty RA term. \\
All$(p_0 \ldots p_n)$ & Execute all of $p_0 \ldots p_n$. \\
$<$Ins/Del$>(e,r)$ & Insert or delete the expression $e$ from the relation $r$. \\
Nop & Do nothing. \\
Blk & The null command, which blocks forever. 
\end{tabularx}
\end{center}\end{table}

The semantics of process algebra says that the ``choice'' operators (e.g. One
and Choice) may execute any one of their subclauses; if \emph{any} of the
subclauses can be completed, the PA clause has restored the violation.  One
choice may be considered better in some ways, for example, different
alternatives could have vastly different execution costs. For the purpose of
this document, however, we will make the simplest ``choice'' possible, which
generally means an arbitrary choice. 

\subsubsection*{ECA Rule}
 Event-Condition-Action Rule. A rule which describes how to handle a constraint
 violation in a database. The syntax of ECA rules is as follows:

\begin{lstlisting}[basicstyle=\ttfamily]
ECArule ::= 'On' ('Ins' | 'Del') 
            '(' RExpr ',' RAtom ')'
            'Do' PAclause    
\end{lstlisting}

\subsubsection*{HUnit}
 A Haskell library for unit testing. See section \ref{sec:TestTools}.
\subsubsection*{QuickCheck}
 A Haskell library for running automated, randomized tests. See section 
 \ref{sec:TestTools}.
 
 \subsubsection*{Sentinel}
A test server accessible through the Ampersand webcite (\cite{sentinellink}) which executes a set of 
randomly generated tests on Ampersand on a daily basis, see \cite{sentinel} for details.

%%%%%%%%%%%%%%%%%%%%%%%%
%
%	2.) Plan
%
%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Plan}\label{ch:Plan}

\section{Software Description}\label{sec:SoftwareDesc}
Ampersand is a software tool that converts the formal specifications of 
business entities and rules, compiles it into various design artifacts (e.g. 
latex documents), and produces a prototype web application.

The business prototype implements business logic according to specifications 
provided by the user, it uses the entities and relationships that the user 
provides to form a relational database with a simple web application front-end.

ECA for Ampersand focuses on automatically restoring a particular class of 
database violations using an algorithm called AMMBR \cite{amber}.  This class 
of violations is realized within Ampersand as ECA rules -- our contribution to 
Ampersand will add support for ECA rules, that will affect Ampersand's back-end 
as well as the generated prototype it provides.

\edcomm{YT}{Probably should merge Test Team and Test Schedule}
\section{Test Team}\label{sec:TestTeam} \edcomm{JG}{You did a great job! could 
you explain to me what a test schedule is?}

The test team which will execute the strategy outline in this document is comprised of
\begin{itemize}
\item Yuriy Toporovskyy  
\item Yash Sapra        
\item Jaeden Guo         
\end{itemize}

\section{Test Schedule}\label{sec:TestSched}
\begin{center}
 	\begin{tabular}{| c | c| } \hline
 		Dates & Tests to be performed \\ \hline
 		12-20-2015 - 01-07-2016 & Unit testing, black box testing, \\ & white 
 		box 
 		testing with heavy use \\ & of QuickCheck  \\ \hline
 		01-08-2016 - 01-20-2016 & System testing EFA with Ampersand  \\  \hline
 	 01-20-2016-02-01-2016     & Testing for abnormality and performance. \\ 
 	 \hline     
 	\end{tabular}
 \end{center}|

 \emph{Note:} More details for specific test will be provided in the future.
\chapter{Methods and constraints}\label{ch:Methods}
\section{Methodology}\label{sec:Methodology}
A Waterfall Development methodology is used in combination with Software 
Prototyping and will likely result in something similar to the spiral model. 
The Waterfall method help translate the requirements outlines in the SRS into 
functional and non-functional requirements that the design must include. 
Furthermore, as Software Prototyping is not a standalone method, but rather an 
approach to development activities these two compliment each other well.
\begin{center}
\includegraphics[scale=0.5]{testing}
\end{center}|
\section{Test tools}\label{sec:TestTools}

Various tools are used by the existing Ampersand developers to test
Ampersand. In order to integrate best with Ampersand, our code will adopt their
test tools. 

%% This doesn't make grammatical sense?
%% See section \ref{subsec:RandTest} for QuickCheck.

%% In addition to QuickCheck, Sentinel Test will be used for the completed 
%% Ampersand system test. Since EFA will be incorporated into Ampersand, it must 
%% pass all sets of randomly generated tests. 

\subsection{Static Typing}\label{subsec:Static}
Programming languages can be classified by many criteria, one of which is their
type systems. One such classification is static versus dynamic typing. Our
implementation language, Haskell, has a static type system. Types will be
checked at compile-time, allow us to catch errors even before the code is run,
reducing the errors that need to be found and fixed using testing techniques. 

\edcomm{YT}{``Static analysis'' is the analysis of a program without running it,
  ie, analysis of the program text. We won't be doing any static analysis, I
  believe... QuickCheck is absolutely unrelated to static analysis.}
\subsection{Formal verification}\label{subsec:FormalVer}
A part of our project deals with generating source code annotated with the proof
of derivation of that source code, which will act as a correctness proof for the
system. In particular, when we generate code to restore a database violation
using ECA rules, then the generated code will have a RA proof associated with it,
which details how that code was derived from the original specification given by
the user.

\subsection{Random Testing}\label{subsec:RandTest}
Random testing allows us to easily run a very large number of tests without
writing them by hand, and also has the advantage of not producing biased test
cases, like a programmer is likely to do.

We will be using QuickCheck \cite{hackage} for random testing. The existing 
Ampersand code base
using QuickCheck for testing, therefore, using QuickCheck has the added benefit
of easier integration with the existing Ampersand code base.

QuickCheck allows the programmers to provide a specification of the program, in
the form of properties. A property is essentially a boolean valued Haskell
function of any number of arguments. QuickCheck can test that these properties
hold in a large number of randomly generated cases. QuickCheck also takes great
care to produce a large variety of test cases, and generally produces good code
coverage. QuickCheck will be used for individualized module testing and well as 
provide a fair array of random tests for the combination of all modules 
\cite{hackage}.

\edcomm{YT}{Don't assume that this super obvious example will make sense... better to leave it out.}

%% \begin{lstlisting}
%% quickCheck (\s -> length (take5 s) == 5)
%% Falsifiable, after 0 tests:
%% ""
%% \end{lstlisting}

%% Here we test that the length of a list after implementing ``take 5'' should be 5 however this fails when the initial list is empty or has less than 5 elements.
\subsection{Unit Testing}\label{subsec:UnitTest}
Unit testing is comprised of feeding some data to the functions being tested and
compare the actual results returned to the expected results.
We will be using HUnit for unit testing of the new source code 
\edcomm{YT}{HUnit does not do *automated* testing.}in Ampersand. HUnit is a 
library providing unit testing capabilities in Haskell.  It is an adaption of 
JUnit to Haskell that allows you to easily create, name, group tests, and 
execute them.

\section{Requirements}\label{sec:Reqs}
Requirements are the main motivator for tests and test methodoloy -- testing
should help ensure that requirements are met. To this end, our requirements are
briefly summarized and labelled below.

\subsection{Functional requirements}\label{subsec:FunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[F1] provably implement the desired algorithm.
\item[F2] accept its input in the existing ECArule format.
\item[F3] produce an output compatible with the existing pipeline. 
\item[F4] annotated generated code with proofs of correctness or derivations,
where appropriate. 
\item[F5] automatically fix database violations in the mock database of the
prototype.
\item[F6] not introduce appreciable performance degradation. 
\item[F7] provide diagnostic information about the algorithm to
the user, if the user asks for such information.
\end{description}

\subsection{Non-Functional requirements}\label{subsec:NonFunReqs}
The functional requirements for ECA for Ampersand are detailed in the SRS; they
are also briefly summarized here. Our implementation must

\begin{description}
\item[N1] produce output which will be easily understood by the typical user,
  such as a requirements engineer, and will not be misleading or confusing.  
\item[N2] be composed of easily maintainable, well documented code.
\item[N3] compile and run in the environment currently used to develop
  Ampersand.
\item[N4] be a pure function; it should not have side effects.  
\end{description}

\section{Data recording}\label{sec:DataRec}
Not Available at this time.
\section{Constraints}\label{sec:Constraints}
Not applicable at this time.
\section{Evaluation}\label{sec:Evaluation}
Due to the early stage of development, this is not available at this time.
%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%	5.) System Test Description
%%
%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{System Test Descriptions}\label{ch:SystemTests}
\newcommand{\us}{\textunderscore}
\newcommand{\tabb}{\hspace{35pt}}
%% Environment for system test
\newcounter{sysTestNum}
\setcounter{sysTestNum}{1}

%% Commands for making ECA rules in math environments 
\newcommand{\ECAIns}[2]{\mathbf{Ins}(#1,#2)}
\newcommand{\ECADel}[2]{\mathbf{Del}(#1,#2)}
\newcommand{\ECAInsDel}[2]{\mathbf{\{Ins/Del\}}(#1,#2)}
\newcommand{\ECADelIns}[2]{\mathbf{\{Del/Ins\}}(#1,#2)}
\newcommand{\ECAOn}{\mathbf{On~}}
\newcommand{\ECADo}{\ECASpacer\mathbf{Do~}}
\newcommand{\ECANop}{\mathbf{Nop~}}
\newcommand{\ECASpacer}{\,\,\,\,}
\newcommand{\IRel}[1]{\mathbb{I}_{#1}}
\newcommand{\VRel}[2]{\mathbb{V}_{#1\times#2}}

\newcommand{\systemTest}[5]{
\section*{T\arabic{sysTestNum}~~~ #2}\label{sec:#1}
\addcontentsline{toc}{section}{T\arabic{sysTestNum}~~~ #2}
\stepcounter{sysTestNum}
\hspace{-6pt}\begin{tabular}{p{3cm}l}
\textbf{Test type}     &   #3 \\ 
\textbf{Schedule}      &   #4 \\
\textbf{Requirements}  &   #5 \\
\end{tabular}
}


Many test cases use domain specific language to indicate inputs and outputs, for
both clarity and brevity. This includes the syntax and semantics of ECA rules
and Abstract SQL. For the full syntax and semantics of these, as well as
related definitions, see section \ref{sec:Abbrev}.

%% %% Example usage....
%% \systemTest{T1}  %% Test label, should be unique
%% {EFA Black box test}  %% Test name
%% {Black box/Functional, using dynamic analysis}  
%% {January 2016 }
%% {Functional}

%% The input shall consist of PAClauses (i.e. a data type) that is composed of 
%% ECA rules. These ECA rules consist of a condition (i.e. ecaTriggr) that 
%% initiates a set of actions to be taken (i.e. ecaAction) based on the violation 
%% (i.e. ecaDelta). Please see example below for further elaboration.

%% The functional output shall be a SQL command template generated through a 
%% Haskell script, for each type of ECA violations

%% QuickCheck  is used to test the functionality of individual functions; it is a 
%% package that provides a library for testing program properties. The programmer 
%% is able to provide properties they want tested in their program specification, 
%% and QuickCheck generates numerous random cases to test that the property 
%% holds\cite{hackage}. 

%% \edcomm{JG}{So.. I originally put the entire example 
%% in Procedure and latex got very mad at me... so if you wanna put all that in 
%% here, 
%% feel free too or add/give a brief description (or I will) for those that do not 
%% want an example cause they find this self-explanatory =) 

%% Also, there are comments, but the comments can be taken out then shown for the 
%% white box test as a walk through sorta thing, am I making sense?}


%%%%%%%%%%%%%%%%% Test 1 
\systemTest{ecaInsIntoAll}
{ECA rule executing ``All'' subclauses}  %% Test name
{Dynamic, black box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAIns{\Delta}{r_0} \ECADo \mathbf{All} ( \ECAIns{e_1}{r_1}, \ECAIns{e_2}{r_2} )$
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & r_0, r_1, r_2    & := \text{Atomic Relation} \\ 
             & e_1, e_2, \Delta & := \text{Expression} \\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is an abstract SQL function of the form:
\begin{verbatim}
f (delta, r_0):
  INSERT INTO <r_1_table> VALUES <e_1_query>;
  INSERT INTO <r_2_table> VALUES <e_2_query>;
\end{verbatim}

\vspace{-12pt}\subsubsection*{Description}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.

%%%%%%%%%%%%%%%%% Test 1 
\systemTest{ecaInsIntoChoice}
{ECA rule executing ``Choice'' subclauses}  %% Test name
{Dynamic, black box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAIns{\Delta}{r_0} \ECADo \mathbf{Choice} ( p_0, p_1 )$
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & r_0   & := \text{Atomic Relation} \\ 
             & \Delta & := \text{Expression} \\ 
             & p_0, p_1 & := \text{PA Clause} \\
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is an abstract SQL function of the form:
\begin{verbatim}
f (delta, r_0):
  <p_i_statement>
\end{verbatim}
where $i \in \{ 0, 1 \}$. 

\vspace{-12pt}\subsubsection*{Description}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.

%%%%%%%%%%%%%%%%% Test 2
\systemTest{ecaEmptyClause}
{ECA rule with empty PA clause} 
{Dynamic, black box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAInsDel{\Delta}{r_0} \ECADo \ECANop $
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & C_0, C_1 & := \text{Concept} \\ 
             & r_0      & := \text{Atomic Relation} \\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is the empty abstract SQL statement; that is, a statement of the form:
\begin{verbatim}
f (delta, r_0): {} \\ Do nothing
\end{verbatim}

\vspace{-12pt}\subsubsection*{Input}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.


%%%%%%%%%%%%%%%%% Test 3
\systemTest{ecaIdentityRel}
{ECA rule inserting into Identity relation} 
{Dynamic, black box, automated}  
{Term 2}
{F1}
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:

$\ECAOn \ECAInsDel{\Delta}{r_0} \ECADo \ECADelIns{e_0}{\IRel{C_0}} $
\vspace{-10pt}\[\hspace{-20pt}\begin{array}{lll}
\text{where} & C_0 & := \text{Concept} \\ 
             & r_0 & := \text{Atomic Relation}\\ 
             & e_0 & := \text{Expression}\\ 
\end{array}\]

\vspace{-12pt}\subsubsection*{Output}

The output is an abstract SQL statement of the form:
\begin{verbatim}
f (delta, r_0):
  {INSERT INTO/DELETE FROM} <C_0_Population> VALUES <e_0_query>;
\end{verbatim}

\noindent where \verb|C_0_Population| is the table corresponding to $\IRel{C_0}$. 

\vspace{-12pt}\subsubsection*{Description}

ECA rules of the input format are generated using QuickCheck, converted to
  abstract SQL, then compared against the expected output format using HUnit.


%%%%%%%%%%%%%%%%% Test 3
\systemTest{compat}
{ASQL is valid} 
{Dynamic, black box, manual}  
{Term 2}
{F3, F1}
\vspace{-12pt}\subsubsection*{Input} 

The input is an ADL file which contains various entities, among them business
process rules which produce ECA rules.

\vspace{-12pt}\subsubsection*{Output}

The prototype generated by Ampersand, which should be syntactically and
semantically valid, as determined by the software which runs the prototype.

\vspace{-12pt}\subsubsection*{Description}

Ampersand generates a prototype from the input ADL file, which a developer will
open on a web server running on their machine. If the file compiles (or more
likely, is interpreted) successfully, this is an indication that the generated
ASQL inside the prototype is correct, in the context of the entire prototype. 


%% Example usage....
%% \systemTest{T1}  %% Test label, should be unique
%% {EFA Black box test}  %% Test name
%% {Black box/Functional, using dynamic analysis}  
%% {January 2016 }
%% {Functional}
%% {The input shall consist of PAClauses (i.e. a data type) that is composed of 
%% ECA rules. These ECA rules consist of a condition (i.e. ecaTriggr) that 
%% initiates a set of actions to be taken (i.e. ecaAction) based on the violation 
%% (i.e. ecaDelta). Please see example below for further elaboration.}
%% {The functional output shall be a SQL command template generated through a 
%% Haskell script, for each type of ECA violations}
%% {QuickCheck  is used to test the functionality of individual functions; it is a 
%% package that provides a library for testing program properties. The programmer 
%% is able to provide properties they want tested in their program specification, 
%% and QuickCheck generates numerous random cases to test that the property 
%% holds\cite{hackage}. }
%% \edcomm{JG}{So.. I originally put the entire example 
%% in Procedure and latex got very mad at me... so if you wanna put all that in 
%% here, 
%% feel free too or add/give a brief description (or I will) for those that do not 
%% want an example cause they find this self-explanatory =) 

%% Also, there are comments, but the comments can be taken out then shown for the 
%% white box test as a walk through sorta thing, am I making sense?}

%% \underline{Example 1.}
%% \paragraph{}
%% Input ECA Rule: No action needs to be taken when a data relation is 
%% deleted because 
%% an order placed by a client has been canceled.
%% 	\begin{verbatim}
%% 	ECA { ecaTriggr = On Del rel_orderedBy_Order_Client
%% 	, ecaDelta  = vio_Delta_Order_Client
%% 	, ecaAction = Nop []
%% 	, ecaNum    = 2
%% 	} 
%% 	\end{verbatim} 	
%% \underline{Brief Explanation of Example 1:} \newline \newline \indent
%% The ecaTriggr specifies an event that takes place such as the deletion of a 
%% Client's order; the action to be taken is "Nop[]", which means no 
%% (mathematical) operations is to be performed on the data set. The ecaNum = 2, 
%% indicates the ECA rule that has been violated which is number 2. The deletion 
%% of data must be consistent and take place across all regions which it will 
%% affect, for example of c = (a,b) where a is an element in set a (a $\in$ A) and 
%% b is an element in set B (b $\in$ B), c may no longer exist. For this example, 
%% we shall call c, cost which is the tuple (a,b) where a is an item and b is the 
%% cost per weight unit of the item. Both a and b are needed to determine the cost 
%% because cost is based on the item and its weight per unit. If the weight no 
%% longer exists (i.e. it was deleted), the data table cost (c) no longer shows 
%% proper cost for the item in question. If the cost table was entirely devoted to 
%% tuples of set A and B, then the entire table needs to be adjusted for a new set 
%% of weights or the table must be deleted. EFA will output SQL commands to delete 
%% the necessary components.

%% Example 1. Possible Recursive Deletion SQL Output:
%% Please note that this is a rolled out generic example of what EFA may produce, 
%% the actual code EFA provides may be very different.
%% \begin{verbatim}
%% CREATE OR REPLACE PROCEDURE delete_cascade(
%% table_owner          VARCHAR2,
%% parent_table         VARCHAR2,
%% where_clause         VARCHAR2
%% ) IS
%% -- ex:  execute delete_cascade('MY_SCHEMA', 'MY_MASTER', 'where ID=1'); */

%% child_cons     VARCHAR2(30);
%% parent_cons    VARCHAR2(30);
%% child_table    VARCHAR2(30);
%% child_cols     VARCHAR(500);
%% parent_cols    VARCHAR(500);
%% delete_command VARCHAR(10000);
%% new_where_clause VARCHAR2(10000);

%% -- gets the foreign key constraints on other tables which depend on columns in 
%% parent_table --
%% CURSOR cons_cursor IS
%% SELECT owner, constraint_name, r_constraint_name, table_name, delete_rule
%% FROM all_constraints
%% WHERE constraint_type = 'R'
%% AND delete_rule = 'NO ACTION'
%% AND r_constraint_name IN (SELECT constraint_name
%% FROM all_constraints
%% WHERE constraint_type IN ('P', 'U')
%% AND table_name = parent_table
%% AND owner = table_owner)
%% AND NOT table_name = parent_table; -- ignore self-referencing constraints


%% -- for the current constraint, gets the child columns and corresponding parent 
%% columns
%% CURSOR columns_cursor IS
%% SELECT cc1.column_name AS child_col, cc2.column_name AS parent_col
%% FROM all_cons_columns cc1, all_cons_columns cc2
%% WHERE cc1.constraint_name = child_cons
%% AND cc1.table_name = child_table
%% AND cc2.constraint_name = parent_cons
%% AND cc1.position = cc2.position
%% ORDER BY cc1.position;
%% BEGIN
%% -- loops through all the constraints that refer to parent table
%% FOR cons IN cons_cursor LOOP
%% child_cons   := cons.constraint_name;
%% parent_cons  := cons.r_constraint_name;
%% child_table  := cons.table_name;
%% child_cols   := '';
%% parent_cols  := '';

%% -- loops through the child/parent column pairs; builds column list of del 
%% statements
%% FOR cols IN columns_cursor LOOP
%% IF child_cols IS NULL THEN
%% child_cols  := cols.child_col;
%% ELSE
%% child_cols  := child_cols || ', ' || cols.child_col;
%% END IF;

%% IF parent_cols IS NULL THEN
%% parent_cols  := cols.parent_col;
%% ELSE
%% parent_cols  := parent_cols || ', ' || cols.parent_col;
%% END IF;
%% END LOOP;

%% /* construct the WHERE clause of the delete statement, including a subquery to 
%% get the related parent rows */
%% new_where_clause  :=
%% 'where (' || child_cols || ') in (select ' || parent_cols || ' from ' || 
%% table_owner || '.' || parent_table ||
%% ' ' || where_clause || ')';

%% delete_cascade(cons.owner, child_table, new_where_clause);
%% END LOOP;

%% --makes delete statement for the current table 
%% delete_command  := 'delete from ' || table_owner || '.' || parent_table || ' ' 
%% || where_clause;

%% -- print delete command
%% DBMS_OUTPUT.put_line(delete_command || ';');

%% EXECUTE IMMEDIATE delete_command;

%% -- issue commit here
%% END;
%% \end{verbatim}


%% Example 2 Input ECA Rule: An ECA rule that specifies that all clauses must be 
%% executed based on conditions. Insertion of deletion must take place to restore 
%% invariants. 


%% \begin{verbatim}
%% ECA {	ecaTriggr = On Ins rel_orderedAt_Order_Vendor, 
%% 		ecaDelta  = vio_Delta_Order_Vendor, 
%% 		ecaAction = ALL [ Do Ins rel_I_Order (EDif 
%% 			(EIsc (ECps	(EDcD vio_Delta_Order_Vendor,EFlp(EDcD 
%% 						vio_Delta_Order_Vendor)),
%% 						EDcI cpt_Order),EDcI cpt_Order
%% 							))[], Do Ins rel_I_Vendor (EDif (EIsc (ECps (EFlp 
%% 							(EDcD 
%% 							vio_Delta_Order_Vendor),EDcD 
%% 							vio_Delta_Order_Vendor),EDcI cpt_Vendor),EDcI 
%% 							cpt_Vendor))[]][], ecaNum    = 3}
%% \end{verbatim}

%% Brief Explanation of Example 2: 

%% \systemTest{T2}  %% Test label, should be unique
%% {EFA White box test} 
%% {White Box/Non-functional, using static analysis}  
%% {January 2016}
%% {Non-functional using static analysis}
%% {N/A}
%% {The desired output depends on the specific targeted non-functional specification}
%% {The test shall be performed by an third party (Dr.Kahl), where Dr. Kahl shall perform a code walk through where he will be able to confirmed the validity of the code that is written, the correctness and the maintainability of the code. Structural testing uncovers errors during implementation of the program, and focuses on how the process occurs, and evaluates structure of the program. The white box test is also implemented by teach individual of our team and shall focus on abnormal or extreme behaviour. The white box test focuses on static program analysis which can be performed without actually executing the program. The main non-functional requirement for EFA is code maintainability and correctness, which requires heavy documentation alongside the source code. }

\systemTest
{T3}{EFA System Compatibility}
{Functional/Black box/ }
{Dec 2015}
{F3}
\vspace{-12pt}\subsubsection*{Input}
ADL File Input 1: \\
	Based on the Rule: Only members who have relevant experience may apply for 
	this 
	job \\
	Using Sets: JOBS-AVAIL, APPLICANTS, EMPLOYEES-WITH-RELEVANT-EXPERIENCE \\
	With ECA rules:\\
	ADL Files Input 2:\\
	Based on the Rule: Only members who have relevant experience may apply for 
	this 
	job \\
	Using Sets: JOBS-AVAIL, APPLICANTS, EMPLOYEES-WITH-RELEVANT-EXPERIENCE \\
	With ECA rules: APPLICANTS must be a member of both 
	EMPLOYEES-WITH-RELEVANT-EXPERIENCE AND have a relation to (i.e. applied 
	for) 
	JOBS-AVAIL \\
	
\vspace{-12pt}\subsubsection*{Output}
EFA\ User\ Output\ for\ Input\ 1: \\
	Reading $<$file$>$.adl.. \\
	Generating.. \\
	Rules Done.. \\
	Sets Done.. \\
	No Errors \\
	No Violations \\
	EFA\ User\ Output\ for\ Input\ 2: \\
	Reading $<$file$>$.adl..\\
	Generating.. \\
	Rules Done.. \\
	Sets Done.. \\
	ECA Rules Done.. \\
	No Errors \\
	No Violations \\
	
\vspace{-12pt}\subsubsection*{Description}
Two different version of the same script is given as input, the first is 
without ECA rules the second is with ECA rules that this project adds. Both of 
these scripts should pass through the Ampersand generator without causing 
errors or violations. If the second script which contains ECA rules 
successfully passes through each part of Ampersand then the new additions 
generated by EFA is compatible with the old Ampersand system.

\paragraph{}
\systemTest
{T7}
{EFA Pure Function}
{Dec 2015}
{F4}
{Two conditions must hold for a function to be considered a pure function 1. 
The function always evaluates to the same result given the same argument 
values, and 2. The evaluation of the result does not cause any semantically 
observable side effects (e.g. mutation). Since EFA in its smallest components 
uses mathematical constructs on expressions, the result is always a pure 
function. }
\vspace{-12pt}\subsubsection*{Input}
The input is an ECA rule of the form:
 \begin{tabbing}
ECA = \{Condition that triggers action: Insertion of $<$new field into 
table$>$, 
\\	 \tabb \tabb Change that initiated trigger: Insertion of $<$e2$>$ into 
	current data scheme, \\
	\tabb \tabb \tabb	Action to be done : $\forall$  \\
		\tabb \tabb \tabb \tabb	\{(take the difference of the previous result 
		of the expressions \\
				\tabb \tabb \tabb \tabb \tabb(take result of intersection of 
				the returned result\\
\tabb \tabb \tabb \tabb \tabb \tabb(composition of the result \\
		\tabb \tabb \tabb \tabb \tabb \tabb \tabb	(Simple declaration of the 
		result 
		of the conversion \\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb \tabb(convert expression e2 using the 
identity relation  
							\\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb \ of e1 \\
\tabb \tabb \tabb \tabb \tabb \tabb \tabb ) \\
\tabb \tabb \tabb \tabb \tabb \tabb )\\
\tabb \tabb \tabb \tabb \tabb  with e1) \\
\tabb \tabb \tabb \tabb	with e1) \\
\tabb \tabb \tabb  with e1 where e1 is another expression)\} \\
	
\tabb \} 
	\end{tabbing}

\vspace{-12pt}\subsubsection*{Output}

asdfasdf

\systemTest{T8}{EFA User Feed Back}
{Functional}
{January 2016}
{F6,N1}
\vspace{-12pt}\subsubsection*{Brief Explanation Concerning Context}
Only those who are qualified can be cast into roles, the actor must have 
relevant experience.
\vspace{-12pt}\subsubsection*{Input}
The input shall be ECA rules specifying invariants that must be maintained 
throughout the program.

\noindent
Example concerning how roles are cast for a theater performance:

\noindent
User Input:

\noindent
   RULE "who's cast in roles" : cast; instantiates |- qualifies;comprises~
   MEANING "an Actor may appear in a Performance of the Play only if the Actor 
   is skilled for a Role that the Play comprises "


\noindent
EFA INPUT:
\begin{tabbing}
   ECA = \{  \\ \tabb \tabb ECA Trigger: if cast member does not have relevant 
   experience or 
   enough experience \\
\tabb \tabb  ECA Violation: lack of experience \\
\tabb \tabb  ECA Action: Remove actors without enough relevant experience \\ 
\tabb \ \ \}
\end{tabbing}
\vspace{-12pt}\subsubsection*{Output}
\underline{User feed back if file has no errors:}\\
Reading file theatreCasting.adl.. \\
Done. \\
Done. \\

\noindent
\underline{User feed back if file has errors:} \\
Reading file theater.adl \\
Error(s) found:\\
Type error, cannot match:\\
the concept "Role" (Tgt of qualifies)\\
and concept "Performance" (Src of instantiates)\\
if you think there is no type error, add an order between concepts "Role" and 
"Performance".\\
Error at symbol () in file theater.adl at line 26 : 44 \\
============================== \\
No declarations match the relation: actor\\
Error at symbol () in file theater.adl at line 26 : 62\\
==============================\\
ECA Rule Violation: \\
Error at Rule declaration and structure in file theater.adl at line 33 : 41\\
Error: Structure and Meaning do not match\\

\systemTest{T9}{EFA Code Walk-through}
{Non-functional}
{January 2016}
{N2}
\vspace{-12pt}\subsubsection*{Brief Explanation}
Input and output are not available for this test, as it requires each member of 
the design team to walk through the code line by line to check if it is easy to 
understand by another programmer and well documented. If it is easy to read and 
understand but not only the individual who wrote it but those around them, then 
it should be easy to maintain. 


\systemTest{T10}{Degradation Test}
{Dynamic, black box, partially automated}
{First Week of February 2016 }
{F6}
\vspace{-12pt}\subsubsection*{Input}
The Ampersand test suite. 

\vspace{-12pt}\subsubsection*{Output}
The time taken to run the test suite, both with EFA enabled and EFA disabled.

\vspace{-12pt}\subsubsection*{Description}

The amount of time Ampersand takes to compile a prototype will measure
performance degradation; if Ampersand takes substantially longer to compile
after the addition of EFA then it is an appreciable difference.  The comparison
will be made between \verb|time ampersand-test-suite| and
\verb|ampersand-test-suite --noEFA| for enabled and disabled, respectively.

\systemTest{T11}{EFA Annotated Code}
{Non-functional}
{January 2016}
{N4}
\vspace{-12pt}\subsubsection*{Description}
There is no input, however there will be annotations available for output, this 
is used for debugging purposes and the user will never see this.



\systemTest{T12}{EFA domain}
{Static, white box, manual}
{Term 2}
{T2}
\vspace{-12pt}\subsubsection*{Description}
Our contribution will take as an input the internal representation of the entire
ADL file, which is essentially a large record, called \verb|FSpec|. For the most
part, the majority of components will not be used -- we will mainly focus on one
or two components of dozens. However, potentially the entire structure may be
useful, so we say that our domain is this structure.

Therefore, the entry point to our code should be a function with type
\verb|FSpec -> a -> ASQL| for some \verb|a| (representing optional or auxillary
arguments), where \verb|ASQL| is the type representing abstract SQL. If this
code type checks, then the compiler has verified that our domain of input is
indeed exactly \verb|FSpec|.
		
\bibliographystyle{alpha}		
\bibliography{TestPlan}

\end{document}
