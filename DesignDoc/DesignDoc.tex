\documentclass[12pt, svgnames]{article}

\usepackage{fullpage}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{../ltx/edcomms}
\usepackage{../ltx/setupComments}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{glossaries}
\usepackage{listings}
\usepackage{calc}
\usepackage{../ltx/pgf-umlcd/pgf-umlcd}

\usetikzlibrary{arrows.meta}



%\usepackage{amssymb}
\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
\makeglossary


% math things
\newcommand{\ra}{$\rightarrow$}

% 
\definecolor{grey}{RGB}{185,185,185}
\lstset{ %
  language=Haskell, morekeywords = {family, kind, pattern, expression},
  literate=
  {+}{{$+$}}1
  {/}{{$/$}}1 
  {*}{{$*$}}1 
  {=}{{$=\,\,\,$}}1
  {==}{{$==$}}2 
  %{/=}{{$\not\equiv$}}2
  {==}{{$\equiv$}}2 
  {/=}{{$\not\equiv$}}2
  {>}{{$>$}}1 
  {<}{{$<$}}1 
  {\\}{{$\lambda$}}1
  {\\\\}{{\char`\\\char`\\}}1
  {>>}{$>>$}2 
  {:>>=}{{$:>>=$}}2
  %% {>>=}{{\hspace{6pt}\texttt{$>>=$}\hspace{6pt}}}2
  {->}{{$\rightarrow$} }2 
  {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
  {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$} }2
  {|}{{$\mid$}}1 
  {forall}{{$\forall$}}1
  {exists}{{$\exists$}}1 
  {Nat}{{$\mathbb{N}$}}3
  {:\~:}{{$\equiv$\,\,}}3
  {\~}{{$\equiv$\,\,}}1
  {`In`}{{$\in$}}1
  {`.`}{{$\circ$\,\,}}1
  ,
  escapeinside={\%*}{*)},
  deletekeywords={>>,>>=,mapM,mapM_,putStrLn,putStr,toInt,show,and,sequence,String,Bool,True,False,Maybe,id},
  morekeywords={forall, ::, :},
  postbreak={},
  breaklines=true,                
  breakatwhitespace=true,
  %postbreak={  \mbox{\textcolor{grey}{$\rightarrow$}} },
  breakindent = 0pt,
  breakautoindent = true,
  %moredelim=[is][\itshape]{"}{"},
  morestring=[b]" 
}

\newcommand{\hstype}[2][0pt]{\attribute{\hspace*{#1}\lstinline{#2}}}

\newcommand{\hstypectr}[1]{\attribute{\hspace*{10pt}\lstinline{#1}}}

\newcommand{\hsfunc}[2][0pt]{\operation{\hspace*{#1}\lstinline{#2}}}

%% \tikzset{>=latex}

\begin{document}

\title{\vspace*{3cm} Module Guide for ECA Rules for Ampersand} 
\author{Yuriy Toporovskyy (toporoy)\\ Yash Sapra (sapray) \\ Jaeden Guo (guoy34)}
%%Yuriy Toporovskyy (toporoy) \\ Yash Sapra (sapray) \\ Jaeden Guo (guoy34)}
\date{February 24th,\ 2016} 


\maketitle
\newpage
\vspace*{1cm}
\begin{table}[ht!]\begin{center}
        \caption{Revision History}  
        \begin{tabular}{|c|c|c|}\hline
            \textbf{Author} & \textbf{Date} & \textbf{Comments} \\\hline 
            Yash Sapra & 24 / 02 / 2016 & Initial draft\\\hline
	 Jaeden Guo & 27/ 02 / 2016 & Update and merge \\\hline
        \end{tabular}
    \end{center}\end{table}
\newpage

\tableofcontents

\newpage

\section{Introduction}
%TODO: edit for grammar, spelling, context, flow, watch for contractions
\subsection{Description}
The document outlines the design decision for the EFA project. 
EFA is responsible for generating SQL Statements from ECA rules that will 
be used to fixed any data inconsistencies in the Ampersand Database.

This document follows the principle set by Parnas and Clements\citep{fakeIt}. 
EFA is currently in development where changes occur frequently, a 
commonly accepted practice for this situation is to decompose modules based on 
the principle of abstraction, where unnecessary information in hidden for the 
benefit of designers and maintainers\citep{modStruct,Parnas1972}.
 
%% TODO: fix this

Our design follows the principles laid out by \citep{modStruct}, as follows:
\begin{itemize}
\item Unnecessary design details are omitted for simplicity
\item Each data structure is only in one module
\item Any other program that requires information stored in a module's data
  structures must obtain it by calling access programs belonging to that module.
Additionally: 
\item Each module is broken down based on hierarchy
\item Reference material are provided for external libraries but details of its 
use will not be provided within the module break-down
\end{itemize}

\subsection{Scope}

This project aims to improve upon the current Ampersand system by providing a 
permanent replacement for the exec-engine. EFA automatically restores system 
invariants according to ECA rules with no manual maintenance required.

\subsubsection{Intended Audience}
This document is designed for:
\paragraph{New project members:}
This document designed to be a guide to introduce new Ampersand users to EFA 
(ECA rules for Ampersand). It provides a basic structure that allows 
individuals to quickly access what they are looking for.
   
\paragraph{Maintainers \& Designers:} The structure of this module guide will 
help maintainers rationalize where changes should be made in order to 
accomplish their intended purpose. Furthermore, the design document will act as 
a guide to EFA for future designers of Ampersand.

\section{Anticipated and Unlikely Changes}
\subsection{Anticipated Changes}
It is likely that EFA will require changes to the front-end interface and an 
addition that will connect the front-end interface to back-end functions, which 
will give the user more control. In addition, ECA rules are not static and may 
change over time, if changes do take place those changes will need to be 
incorporated into EFA's future versions. 

Thus far anticipated changes include:

\begin{description}
    \item[AC1:] New front-end interface.
    \item[AC2:] Addition or elimination of ECA rules.
    \item[AC3:] The algorithm used for EFA.
    \item[AC4:] The format of output.
    \item[AC5:] The format of input parameters.
    \item[AC6:] The format of initial input data and associated markers for 
    data association.
    \item[AC7:] Integration of front-end interface to back-end modules.
    \item[AC8:] Implementation of SQL data structure
    \item[AC9:] Testing for individual modules and internal systems
    \item[AC10:] Software requirements for running Ampersand and by extension 
    EFA
    
\end{description}

\subsection{Unlikely Changes} 

These unlikely changes include the things that will remain unchanged in the 
system, and also changes that would not affect EFA. 

\begin{description}
    \item[UC1:] There will always be a source of input data external to the 
    software. 
    \item[UC2:] Results will always be provably correct. 
    \item[UC3:] The goal of EFA is to automatically correct system invariants
    \item[UC4:] Output data must exist
    \item[UC5:] The implementation language must be the same as that which is 
    used for building the Ampersand system
    \item[UC6:] The format of initial input data and associated markers for 
    data association. 
    \item[UC7:] Type of output data will always be SQL.
\end{description}

\section{Module Hierarchy}
This section provides an overview of the module design. Modules are decomposed 
based on their hierarchy from top to bottom. The modules are broken down into 
three sections, the first section consists of the main module used for EFA, 
the second section contains support modules and finally the last section
contains external libraries.

\begin{description}
    \item[M1:] eca2SQL
    \item[M2:] TypedSQL
    \item[M3:] Equality
    \item[M4:] Singletons
    \item[M5:] Utils
    \item[M6:] Trace
    \item[M7:] Combinators
    \item[M8:] Pretty
\end{description}

\makebox[\textwidth][c]{
\scalebox{0.5}{
\begin{tikzpicture}

  %% \begin{class}[text width=13cm]{ECA2SQL}{0,0}
  %%   \hsfunc{eca2SQL :: Options -> FSpec -> ECArule -> SQLMethod [] SQLBool}
  %%   \hsfunc{eca2PrettySQL :: Options -> FSpec -> ECArule -> Doc}
  %% \end{class}

  \begin{package}{TypedSQL}


  \begin{class}[text width=30cm]{TypedSQLStatement}{10,20}
    \hstype{SQLMethod : [SQLType] -> SQLType -> Type where}
    \hstypectr{MkSQLMethod : (ts : [SQLType]) (o : SQLType)}
    \hstype[20pt]{-> (Prod (SQLValSem `.` SQLRef) ts -> SQLMthd o) -> SQLMethod ts o}
     
    \hstype{SQLSem : Kind where}
    \hstypectr{Stmt, Mthd : SQLSem}

    \hstype{SQLStatement : SQLRefType -> Type = SQLSt Stmt}
    \hstype{SQLMthd : SQLRefType -> Type = SQLSt Mthd}

    \hstype{SQLSt : SQLSem -> SQLRefType -> Type where} 
    \hstypectr{Insert :: TableSpec ts -> SQLVal (SQLRel (SQLRow ts)) -> SQLStatement SQLUnit}
    \hstypectr{Delete :: TableSpec ts -> (SQLVal (SQLRow ts) -> SQLVal SQLBool)}
    \hstype[20pt]{-> SQLStatement SQLUnit}
    \hstypectr{Update :: TableSpec ts -> (SQLVal (SQLRow ts) -> SQLVal SQLBool)}
    \hstype[20pt]{ -> (SQLVal (SQLRow ts) -> SQLVal (SQLRow ts)) -> SQLStatement SQLUnit}
    \hstypectr{SetRef :: SQLValRef x -> SQLVal x -> SQLStatement SQLUnit}
    \hstypectr{NewRef :: IsScalarType a \~ True -> SQLTypeS a -> Maybe String}
    \hstype[20pt]{ -> Maybe (SQLVal a) -> SQLStatement (SQLRef a)}
    \hstypectr{MakeTable :: SQLTypeS (SQLRow t) -> SQLStatement (SQLRef (SQLRel (SQLRow t)))}
    \hstypectr{DropTable :: TableSpec t -> SQLStatement SQLUnit}
    \hstypectr{IfSQL :: SQLVal SQLBool -> SQLSt t0 a -> SQLSt t1 b -> SQLStatement SQLUnit}
    \hstypectr{(:>>=) :: SQLStatement a -> (SQLValSem a -> SQLSt x b) -> SQLSt x b}
    \hstypectr{SQLNoop :: SQLStatement SQLUnit}
    \hstypectr{SQLRet :: SQLVal a -> SQLSt Mthd (Ty a)}
    \hstypectr{SQLFunCall :: SQLMethodRef ts out -> Prod SQLVal ts -> SQLStatement (Ty out)}
    \hstypectr{SQLDefunMethod :: SQLMethod ts out -> SQLStatement (SQLMethod ts out)}
  \end{class}


  \begin{class}[text width=11cm]{TypedSQLLanguage}{0,5}   
    \hstype{SQLSizeVariant : Kind where}
    \hstypectr{SQLSmall, SQLMedium, SQLNormal, SQLBig : SQLSizeVariant}

    \hstype{SQLSign : Kind where}
    \hstypectr{SQLSigned, SQLUnsigned : SQLSign}

    \hstype{SQLNumeric : Kind where}
    \hstypectr{SQLFloat, SQLDouble : SQLSign -> SQLNumeric}
    \hstypectr{SQLInt : SQLSizeVariant -> SQLSign -> SQLNumeric}

    \hstype{SQLRecLabel : Kind where}
    \hstypectr{(:::) : Symbol -> SQLType -> SQLRecLabel}

    \hstype{SQLType : Kind where}
    \hstypectr{SQLBool, SQLDate, SQLDateTime, SQLSerial : SQLType}
    \hstypectr{SQLNumericTy : SQLNumeric -> SQLType}
    \hstypectr{SQLBlob : SQLSign -> SQLType}
    \hstypectr{SQLVarChar : Nat -> SQLType}
    \hstypectr{SQLRel : SQLType -> SQLType}
    \hstypectr{SQLRow : [SQLRecLabel] -> SQLType}
    \hstypectr{SQLVec : [SQLType] -> SQLType}

    \hstype{SQLRefType : Kind where}
    \hstypectr{Ty : SQLType -> SQLRefType}
    \hstypectr{SQLRef, SQLUnit : SQLType}
    \hstypectr{SQLMethod : [SQLType] -> SQLType -> SQLRefType}

    \hstype{instance SingKind SQLType where ...}
    \hstype{instance SingKind SQLRefType where ...}

    \hstype{IsScalarType : SQLType -> Bool where ...}
    \hstype{IsScalarTypes : [SQLType] -> Bool where ...}

    \hsfunc{isScalarType : (x : SQLType) -> IsScalarType x}
    \hsfunc{isScalarTypes : (x : [SQLType]) -> IsScalarTypes x}
  \end{class}


  \begin{class}[text width=17.5cm]{TypedSQLExpr}{16,-0.5}
    \hstype{SQLVal : SQLType -> Type where}
    \hstypectr{SQLScalarVal : IsScalarType a :\~: True -> ValueExpr -> SQLVal a}
    \hstypectr{SQLQueryVal  : IsScalarType a :\~: False -> QueryExpr -> SQLVal a}

    \hsfunc{typeOf : SQLVal a -> a}
    \hsfunc{argOfRel : SQLRel a -> a} 

    \hstype{SQLValSem : SQLRefType -> Type where}
    \hstypectr{Unit : SQLValSem SQLUnit}
    \hstypectr{Val : (x : SQLType) -> SQLVal x -> SQLValSem (Ty x)}
    \hstypectr{pattern Method : Name -> SQLValSem (SQLMethod args out)}
    \hstypectr{pattern Ref : (x : SQLType) -> Name -> SQLValSem (SQLRef x)}

    \hsfunc{typeOfSem : f `In` [SQLRef, Ty] -> SQLValSem (f x) -> x}
 
    \hsfunc{colsOf : SQLRow xs -> xs}

    \hsfunc{unsafeSqlValFromName : (x : SQLType) -> Name -> SQLVal x}
    \hsfunc{unsafeSQLValFromQuery : (xs : [SQLRecLabel]) -> NonEmpty xs -> IsSetRec xs -> SQLVal xs}
    \hsfunc{unsafeRefFromName : (x : SQLType) -> Name -> SQLValRef x}

    \hsfunc{deref : SQLValRef x -> SQLVal x}   
  \end{class}


  \begin{class}[text width=15.6cm]{TypedSQLTable}{17,5}
    \hstype{TableSpec : [SQLRecLabel] -> Type where}
    \hstypectr{MkTableSpec : SQLValRef (SQLRel (SQLRow t))  -> TableSpec t}
    \hstypectr{TableAlias : IsSetRec ns -> TableSpec t -> TableSpec (ZipRec ns (RecAssocs t))}
    
    \hsfunc{typeOfTableSpec : TableSpec t -> SQLRow t}
    \hsfunc{typeOfTableSpec : TableSpec t -> t}

    \hsfunc{tableSpec : Name -> Prod (K String :*: id) tys}
    \hsfunc[10pt]{ -> exists (ks : [SQLRecLabel]) (Maybe (RecAssocs ks :\~: tys, TableSpec ks))}

  \end{class}

  %% \unidirectionalAssociation{TypedSQLStatement}{}{}{TypedSQLLanguage}
  %% \unidirectionalAssociation{TypedSQLExpr}{}{}{TypedSQLLanguage}
  %% \unidirectionalAssociation{TypedSQLTable}{}{}{TypedSQLLanguage}

  %% %% \unidirectionalAssociation{TypedSQLStatement}{}{}{TypedSQLExpr}
  %% \unidirectionalAssociation{TypedSQLStatement}{}{}{TypedSQLTable}


  \draw [umlcd style, ->] ([xshift=-60pt]TypedSQLStatement.south) -- ([xshift=-60pt]TypedSQLStatement |- TypedSQLExpr.north); 
  \draw [umlcd style, ->] ([xshift=10pt]TypedSQLStatement.south) -- ([xshift=10pt]TypedSQLStatement |- TypedSQLTable.north); 
  \draw [umlcd style, ->] ([xshift=-180pt]TypedSQLStatement.south) -- ([xshift=-180pt]TypedSQLStatement |- TypedSQLLanguage.north); 
  
  %% \node[inner sep=0,minimum size=0,right of=TypedSQLStatement] (k) {}; % invisible node
  
%% \draw[umlcd style ,->] (TypedSQLStatement) node[above , sloped ,
%%   black]{} (TypedSQLExpr);

  \end{package}

\end{tikzpicture}
}}


%% \begin{figure}
%%     \centering
%%     \includegraphics[width=0.95\textwidth]{../DesignDoc/depent_tree}
%%     \caption{Dependency graph of EFA modules}~\label{fig:figure1}
%% \end{figure}

\section{Connection Between Requirements and Design} \label{SecConnection}

\section{Module Decomposition} \label{SecMD}
Modules are located in their respective subsections (i.e. main module, support 
modules and external library modules). Each module is decomposed based on their 
use while hiding implementation details. 
\\ \newline
\textit{Please see glossary for math references and clarification of uncommon 
terms}

\subsection{Main Module}

%% ------------------------------M1: ECA2SQL -------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
        M1 & eca2SQL \\ 
        \midrule 
        Main function & eca2SQL
        \\  Input & Options, FSpec, ECARule
        \\  Output & Doc
        \\	Secrets & The algorithm and data structures used to implement ECA 
        Rules.
        \\	Services & Produces the final product by using supporting modules 
        as tools in translating ECA rules to SQL statements which can be 
        applied to a database.
        \\     
         \vspace{12pt}
     \end{tabularx}
\\
\underline{Internal Description}\\ \\
eca2SQL :: Options $\rightarrow$ FSpec $\rightarrow$ ECArule $\rightarrow$ Doc

%% ------------------------------M2: TypedSQL -------------------------------%%
\subsection{Support Modules}

{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
        M2 & eca2SQL \\ 
        \midrule       
        \\  Requires Modules & ProofUtils, Trace, Singleton
        \\	Secrets & Implements a type language for SQL through pattern 
        matches where the representation of SQL references types which can 
        appear in SQL statements.
        \\	Services & Contains Base which implements a typed SQL query 
        language and a type SQL statement.
        \\         
        \vspace{12pt}
    \end{tabularx} 


\setlength{\parindent}{0pt}
\underline{Internal Description}\\

Read as: \textit{function: input $\rightarrow$ input2 $\rightarrow$ 
output}\newline

Where a function may require multiple inputs of different types to produce the 
necessary output type.\\

\textit{function (type and value level): (x:A) $\rightarrow$ output}
This indicates the function of a certain type and its value level, this is seen 
on SQL types. (x:A) is used to indicate a variable x of type A (e.g. x=9, (x:A) 
is a type of integer). (function::) is used to define a function and its input 
types 



\newglossaryentry{N}{name=N, description= $\mathbb{N}$ represents 
    the 
    set of natural numbers}

 (:::) : Symbol $\rightarrow$ SQLType $\rightarrow$ SQLRecLabel \\
 
 SQLSizeVariant : Kind \\
 SQLSmall, SQLMedium, SQLNormal, SQLBig :SQLSizeVariant \\ \\
 
 SQLSign : Kind \\
 SQLSigned, SQLUnsigned : SQLSign  \\
 
 SQLNumeric : Kind \\
 SQLFloat, SQLDouble : SQLSign $\rightarrow$ SQLNumeric \\
 
 SQLInt : SQLSizeVariant $\rightarrow$ SQLSign $\rightarrow$ SQLNumeric \\
 SQLRecLabel : Kind \\

 SQLType : Kind \\
 SQLBool, SQLDate, SQLDateTime, SQLSerial : SQLType \\
 
 SQLNumericTy : SQLNumeric $\rightarrow$ SQLType  \\
 SQLBlob : SQLSign $\rightarrow$ SQLType \\
 
 SQLVarChar : \Gls{N} $\rightarrow$ SQLType 
 SQLRel : SQLType $\rightarrow$ SQLType \\
 
 SQLRow : [SQLRecLabel] $\rightarrow$ SQLType 
 SQLVec : [SQLType]$\rightarrow$ SQLType \\
 
 SQLRef, SQLUnit: SQLType \\
 SQLRefType: Kind\\
 
 SQLMethod: [SQLType] $\rightarrow$ SQLType $\rightarrow$ SQLRefType \\
 SQLVal: SQLType $\rightarrow$ Type \\
 
 SQLScalarVal: IsScalarType a $\equiv$ True $\rightarrow$ Sm.ValueExpr 
 $\rightarrow$ SQLVal a \\
 SQLQueryVal: IsScalarType a $\equiv$ False $\rightarrow$ Sm.QueryExpr 
 $\rightarrow$ SQLVal a \\
 
 SQLValSem: SQLRefType $\rightarrow$ Type\\

 
 Ty: SQLType $\rightarrow$ SQLRefType \\

 IsScalarType: SQLType $\rightarrow$ Bool \\
 isScalarType: (x:SQLType) $\rightarrow$ IsScalarType x \\
 IsScalarTypes: [SQLType] $\rightarrow$ Bool \\
 isScalarTypes: (X:[SQLType]) $\rightarrow$ IsScalarTypes x \\
 
 typeOf: SQLVal a $\rightarrow$ a \\
 argOfRel: SQLRel a $\rightarrow$ a\\
 
 Unit: SQLValSem SQLUnit\\
 Val:: SQLVal x $\rightarrow$ SQLValSem ('Ty x)
 
 

%% ------------------------------M3: Equality -------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
        M3 & Equality \\ 
        \midrule
        
        Contains functions  &  not, cong, elimNeg and more
        \\	Secrets & Various utilities functions
        \\	Services &  The module contains utility functions that are being used in the Singletons and Utils module to provide type level security for the TypedSQL with an aim to make it total.
        \\       
        \vspace{12pt}
    \end{tabularx}
    \vspace{3em}
%% ------------------------------M4: Singleton -------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
        M4 & Singleton \\ 
        \midrule
        
        Main function  &  No functions exported
        \\	Secrets & Extension to the Haskell Singleton Library Singleton Types and promoted functions
        \\	Services &  
        \\       
        \vspace{12pt}
    \end{tabularx}\vspace{3em}
%% ------------------------------M5: Utils -------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
        M5 & Utils \\ 
        \midrule
        
        Main function  & 
        \\	Secrets & Varies Utilities Functions
        \\	Services &  The module also contains some utility functions used by the ECA2SQL module
        \\       
        \vspace{12pt}
    \end{tabularx}\vspace{3em}
%% ------------------------------M6: Trace -------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
        M6 & Trace \\ 
        \midrule
        
        Main function  &  getTraceInfo 
        \\	Secrets & Creates a function for tracing the output
        \\	Services &  The modules contains support for tracing back the ECA rule. Tracing is used for development and debugging purpose
        \\       
        \vspace{12pt}
    \end{tabularx}\vspace{3em}
%% ------------------------------M7: Combinators------------------------------%%
{\setlength{\tabcolsep}{6pt} 
    \begin{tabularx}{\textwidth}{>{\bfseries}m{5cm}X}
        M7 & Combinators \\ 
        \midrule
        
        Main function  & No functions exported
        \\	Secrets &  Combinator Logic for TypedSQL
        \\	Services &  This module contains Combinatory Logic for our TypedSQL module. The module defines SQL primitives such as AND, OR, NOT and the primitive SQL functions such as the EXISTS, GROUP BY, SORT BY.
        \\       
        \vspace{12pt}
    \end{tabularx}\vspace{3em}
%% ----------------------------- M8: Pretty    ------------------------------%%
    {\setlength{\tabcolsep}{6pt} 
        \begin{tabularx}{\textwidth}{>{\bfseries}m{5cm}X}
            M8 & Pretty \\ 
            \midrule
            
            Main function  & eca2PrettySQL
            \\	Secrets & Pretty prints the generated SQL
            \\	Services &  The function takes in the FSpec as an input with an ECA rule and runs the eca2SQL function to generate SQLSt(SQL Statements). The generated SQL statement are pretty printed using a Pretty Printer Library.
            \\       
            \vspace{12pt}
        \end{tabularx}\vspace{3em}
\underline{Internal Description}\\ \\
eca2PrettySQL :: Options $\rightarrow$ FSpec $\rightarrow$ ECArule $\rightarrow$ Doc
        
\subsection{External Libraries}
\begin{tabular}{ | m{4cm} | m{11cm} |}
    \hline
    \bfseries{Library} & \bfseries{Reference}  \\
    \hline
    item 21  & item 22   \\
    item 21  & item 22   \\
    item 21  & item 22   \\
    item 21  & item 22   \\
    \hline
    \end{tabular}

\section{Traceability Matrix} \label{SecTM}

\section{Use Hierarchy Between Modules} \label{SecUse}





%\section*{References}
\clearpage
\printglossaries
\bibliographystyle {plainnat}
\bibliography {DesignDoc}

\end{document}
