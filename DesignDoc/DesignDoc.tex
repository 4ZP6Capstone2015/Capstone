\documentclass[12pt, svgnames]{article}

\usepackage{fullpage}
\usepackage[round,numbers]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}
\usepackage{../ltx/edcomms}
\usepackage{../ltx/setupComments}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{glossaries}
\usepackage{multirow} %% Used for Traceability matrix
\usepackage{listings}
\usepackage{calc}
\usepackage[simplified]{../ltx/pgf-umlcd/pgf-umlcd}
\usepackage[section]{placeins}

\usetikzlibrary{arrows.meta}

\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}
\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

%\usepackage{amssymb}
\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
\makeglossary


% math things
\newcommand{\ra}{$\rightarrow$}

% 
\definecolor{grey}{RGB}{185,185,185}
\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}
\lstset{ %
  language=Haskell, morekeywords = {family, kind, pattern, expression},
  literate=
  {+}{{$+$}}1
  {/}{{$/$}}1 
  {*}{{$*$}}1 
  {=}{{$=\,\,\,$}}1
  {==}{{$==$}}2 
  %{/=}{{$\not\equiv$}}2
  {==}{{$\equiv$}}2 
  {/=}{{$\not\equiv$}}2
  {>}{{$>$}}1 
  {<}{{$<$}}1 
  {\\}{{$\lambda$}}1
  {\\\\}{{\char`\\\char`\\}}1
  {>>}{$>>$}2 
  {:>>=}{{$:>>=$}}2
  %% {>>=}{{\hspace{6pt}\texttt{$>>=$}\hspace{6pt}}}2
  {->}{{$\rightarrow$} }2 
  {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
  {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$} }2
  {|}{{$\mid$}}1 
  {forall}{{$\forall$}}1
  {exists}{{$\exists$}}1 
  {Nat}{{$\mathbb{N}$}}3
  {:\~:}{{$\equiv$\,\,}}3
  {\~}{{$\equiv$\,\,}}1
  {`In`}{{$\in$}}1
  {.}{{$\circ$\,\,}}1
  ,
  escapeinside={\%*}{*)},
  deletekeywords={>>,>>=,mapM,mapM_,putStrLn,putStr,toInt,show,and,sequence,String,Bool,True,False,Maybe,id,Show},
  morekeywords={forall, ::, :},
  postbreak={},
  breaklines=true,                
  breakatwhitespace=true,
  %postbreak={  \mbox{\textcolor{grey}{$\rightarrow$}} },
  breakindent = 0pt,
  breakautoindent = true,
  %moredelim=[is][\itshape]{"}{"},
  morestring=[b]",
  mathescape
}

\newcommand{\hstype}[2][0pt]{\attribute{\hspace*{#1}\lstinline[mathescape]!#2!}}

\newcommand{\hstypectr}[1]{\attribute{\hspace*{10pt}\lstinline[mathescape]!#1!}}

\newcommand{\hsfunc}[2][0pt]{\operation{\hspace*{#1}\lstinline[mathescape]!#2!}}

%% \tikzset{>=latex}

\begin{document}

\title{\vspace*{3cm} Module Guide for ECA Rules for Ampersand} 
\author{Yuriy Toporovskyy (toporoy)\\ Yash Sapra (sapray) \\ Jaeden Guo (guoy34)}
%%Yuriy Toporovskyy (toporoy) \\ Yash Sapra (sapray) \\ Jaeden Guo (guoy34)}
\date{February 24th,\ 2016} 


\maketitle
\newpage
\vspace*{1cm}
\begin{table}[ht!]\begin{center}
        \caption{Revision History}  
        \begin{tabular}{|c|c|c|}\hline
            \textbf{Author} & \textbf{Date} & \textbf{Comments} \\\hline 
            Yash Sapra & 24 / 02 / 2016 & Initial draft\\\hline
	 Jaeden Guo & 27/ 02 / 2016 & Update and merge \\\hline
	 Yash Sapra & 28/ 02 / 2016 & Modifications to several sections \\\hline
	 Yuriy Toporovskyy & 28/ 02 / 2016 & Addition of UML diagrams \\\hline
        \end{tabular}
    \end{center}\end{table}
\newpage

\tableofcontents

\newpage

\section{Introduction}
%TODO: edit for grammar, spelling, context, flow, watch for contractions
\subsection{Description}

This document details the module system of EFA, as well as the design principles
which guided said module system. EFA, as well as the core Ampersand system, is
currently in active development where changes occur frequently.  commonly
accepted practice for this situation is to decompose modules based on the
principle of abstraction, where unnecessary information in hidden for the
benefit of designers and maintainers\citep{modStruct,Parnas1972}.

Our design follows the principles laid out by \citep{modStruct}, which can be summarized as follows:
\begin{itemize}
\item Unnecessary design details are omitted for simplicity.
\item Each module is broken down based on hierarchy with no overlap of functionality.
\item All our modules are \emph{Open Modules}, that is, they are available for extension in the future.
\item Reference materials are provided for external libraries but details of
  their implementation are not included here. 
\end{itemize}

The language of implementation is Haskell. The primary reason for using Haskell
is the existing Ampersand system is largely written in Haskell. However, we
leverage the full power of the Haskell type system in order to encode as many
invariants in Haskell as possible. In particular, we use many modern features of
the Glasgow Haskell Compiler (GHC) in order to do so. However, the particular
features, as well as how and where they are used, are considered an
implementation detail that is not relevant to the design of EFA.

\subsection{Scope}
The purpose of this document is to outline the implementation details of the 
EFA project described in the Problem Statement.
EFA is responsible for generating SQL Statements from ECA rules that will 
be used to fixed any violated invariants in the Ampersand prototype. 
The document will serve as a referral document for future software development in the Ampersand project.

\subsubsection{Intended Audience}
This document is designed for:
\paragraph{New project members:}
This document designed to be a guide to introduce new Ampersand users to EFA 
(ECA rules for Ampersand). It provides a basic structure that allows 
individuals to quickly access the information they seek.
\edcomm{JG}{In modern English, is it more acceptable to end sentences in 
prepositions? -- Would it count as a grammar mistake or not?}
   
\paragraph{Maintainers \& Designers:} The structure of this module guide will 
help maintainers rationalize where changes should be made in order to 
accomplish their intended purpose. Furthermore, the design document will act as 
a guide to EFA for future designers of Ampersand.

\section{Anticipated and Unlikely Changes}
\subsection{Anticipated Changes}
It is likely that EFA will require changes to the front-end interface. This 
addition may include a protocol that will connect the front-end interface to 
back-end functions, which will give the user more control. In addition, ECA 
rules are not static and may change over time, if changes do take place those 
changes will need to be incorporated into EFA's future versions. 

Thus far anticipated changes include:

\begin{description}
    \item[AC1:] New front-end interface.
    \item[AC2:] Addition or elimination of ECA rules.
    \item[AC3:] The algorithm used for EFA.
    \item[AC4:] The format of output.
    \item[AC5:] The format of input parameters.
    \item[AC6:] Integration of front-end interface to back-end modules.
    \item[AC7:] Testing for individual modules and internal systems.
    
\end{description}

\subsection{Unlikely Changes} 

These unlikely changes include the things that will remain unchanged in the 
system, and also changes that would not affect EFA. 

\begin{description}
    \item[UC1:] There will always be a source of input data external to the 
    software.
    \item[UC2:] Results will always be provably correct.
    \item[UC3:] Output data must exist.
    \item[UC4:] The implementation language must be the same as that which is 
    used for building the Ampersand system.
    \item[UC5:] The format of initial input data and associated markers for 
    data association.
    \item[UC6:] Type of output data will always be a SQL query.
\end{description}


%%%%%%%%%%%%%%%%%%%%%
%%% Section - System Architecture %%%%%
%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{System Architecture} \label{SystemArch}

This section provides an overview of the module design. The module design is
detailed with UML-like class diagrams. However, UML class diagrams are typically
used to describe the module systems of object-oriented programs, as opposed to
functional programs. Many of the components of the traditional UML class
diagram are inapplicable to functional programs; therefore, we detail our
modifications to the UML class diagram syntax in section~\ref{subsec:ModuleSyntax}. 

Furthermore, the syntax used to describe types and data declarations is not
actual Haskell syntax. The syntax shares many similarities, but several changes
to the syntax are made in this document in order to present the module hierarchy
in a clearer manner. These changes are also detailed, in section~\ref{subsec:HaskellSyntax}. 


\subsection{Haskell-like Syntax Description}\label{subsec:HaskellSyntax}

This section details the syntax used to describe the module system of
Ampersand. This syntax largely borrows from actual Haskell syntax, and from the
Agda programming language \cite{agda}. Agda is a dependantly typed functional
language, and since a large part of our work deals with ``faking'' dependant
types, the syntax of Agda is conducive to easy communication of our module system. The
principle of faking dependant types in Haskell is detailed in
Hasochism~\cite{hasochism} (a portmanteau of Haskell and masochism, because
purportedly wanting to fake dependant types in Haskell is masochism). While the
implementation has since been refined many times over, the general approach is still the
same, and will not be detailed here.

While the changes made to the Haskell syntax are reasonably complex, the ensuing 
module description becomes vastly simplified. This section is meant to be used
as a reference - in many cases, the meaning of a type is self-evident. 

\subsubsection*{Types and kinds}
In the way that a type classifies a set of values, a kind classifies a set of
types. Haskell permits one to define algebraic data types, which are then ``promoted''
to the kind level. This permits the type constructor of the datatype to be used
as a kind constructor, and for the value constructors to be used as type constructors. 
In every case in our system, when we define a datatype and use the promoted version,
we never use the \emph{unpromoted} version. That is, we define types which are never
used as types, only as kinds, and constructors which are never used as value constructors,
only type constructors. We write \,\,\,\lstinline!X : A -> B -> $\ldots$ -> Type!\,\,\, to denote
a regular data type, and \,\,\,\lstinline!Y : A -> B -> $\ldots$ -> Kind!\,\,\, to denote a datatype
which is used exclusively as a kind. 

\subsubsection*{Dependant types}
The syntax used to denote a ``fake'' dependant type in our model is the same 
as used to denote a real dependant type in Agda. \lstinline!(x : A) -> B! is the function
from $x$ to some value of type $B$, where $B$ can mention $x$. This nearly looks like a 
real Haskell type - in Haskell, the syntax would be \texttt{forall (x :: A) . B}. However, 
the semantics of these two types are vastly different - one can pattern match
on the value of $x$ in the former case, while this is impossible in the latter case. 

In certain cases, it may be elucidating to see the \emph{real} Haskell type of
an entity (function, datatype, etc.). To differentiate the two, they are typeset
differently, as in this example.

The real type of a function whose type is given as \lstinline!(x : A) -> B! in
our model is \texttt{forall (x :: A) . SingT x -> B}. \texttt{SingT :: A -> Type}
denotes the singleton type for the kind $A$, which is inhabitted by precisely
one value for each type which inhabits $A$. The role and use of singleton types
is detailed further on, in section~\ref{subsec:Singletons}. 

The syntax \lstinline!forall (x : A) -> B! is used to denote the regular
Haskell type \texttt{forall (x :: A) . B}. As is customary in Haskell, the quantification
may be dropped when the kind $A$ is clear from the context: \lstinline!forall (x : A) -> P x! and
\lstinline!forall x -> P x! denote the type \texttt{forall (x :: A) . P x}.

\subsubsection*{Constraints}
The Haskell syntax \texttt{A -> B} denotes a function from $A$ to $B$. However,
we use the arrow to additionally denote constraints. For example, the function
\texttt{Show a => a -> String} would be written simply as \lstinline!Show a -> a -> String!.

\subsubsection*{Overloading}
Haskell supports overloaded function names through type classes. When we use a type 
class to simply overload a function name, we simply write the function name
multiple times with different types. The motivation for this is that often the 
real type will be exceeding complex, because it must be so to get good type inference. 

\subsubsection*{Types, kinds, and type synonyms}
Type synonyms are written in the model as \lstinline!Ty : K = X!, where $Ty$ is the name
of the type synonym, $K$ is its kind, and $X$ its implementation. This is to differentiate
from type families, which are written as \lstinline!Ty : K where Ty $\ldots$ = $\ldots$!. 

\subsubsection*{Omitted implementations}
When the implementation of a type synonym, or any other entity, is omitted, it
is replaced by ``$\ldots$''. This is to differentiate from a declaration of the form
\lstinline!Ty : Type!, which is an abstract type whose constructors cannot be
accessed. Furthermore, types may have pattern-match-only constructors; that is,
constructors which can only be used in the context of a pattern match, and not
to construct a value of that type. This is denoted by the syntax
``\lstinline!pattern Ctr : Ty!''. Furthermore, it is not a simple matter of
convention - the use of this constructor in expressions will be strictly
forbidden by Haskell.

\subsubsection*{Existential quantification}
The type \lstinline!exists (x : A) (P x)! indicates that there exists some $x$
of kind $A$ which satisfies the predicate $P$. Unfortunately, Haskell does not
have first class existential quantification. It must be encoded in one of
two ways:

\begin{itemize}
\item With a function (by DeMorgan's law): \\ \texttt{(forall (x :: A) . P x -> r) -> r}
\item With a datatype: \\ \texttt{data Exists p where Exists :: p x -> Exists p}
\end{itemize} 

Which form is used is chosen based on the circumstances in which the function
will most likely be used, since whether one form is more convenient than the
other depends largely on the intended use. However, these two forms are
completely interchangeable (albiet with some syntactic noise) so the syntax
presented here does not distinguish between the two. 

\subsection{Module Diagram Syntax Description}\label{subsec:ModuleSyntax}

The module hierarchy is broken down into multiple levels to better describe the
system.  A coarse module hierarchy is given, and each module is further broken
into submodules.  A dependency between two modules $A$ and $B$ indicates that
each submodule in $A$ depends on all of $B$. There is no necessity to break
down modules into submodule, if they do not have any interesting submodule 
structure. 

External dependencies, which are modules which come from an external pacakge,
are indicated in {\color{grey}grey}. System modules, which are modules part of
Ampersand, but not written specifically for EFA (or, on which EFA depends, but
few or no changes have been made from the original module before the existance
of EFA), are indicated in {\color{applegreen}green}. The module heirarchy of
these modules is not described here; they are included simply to indicate which
symbols are imported from these modules. An example of the syntax is found in
figure~\ref{fig:ModExample}.

\begin{figure}[!ht]
\makebox[\textwidth][c]{
\scalebox{0.6}{
\begin{tikzpicture}

  \begin{package}{Module}

    \begin{class}[text width=10cm]{Submodule$_0$}{0,0}
      \hstype{Data$_0$ : Type where}
      \hstypectr{Ctr$_0$ : A -> Data$_0$}
      \hstypectr{pattern Ctr$_1$ : B -> Data$_0$}
      \hsfunc{func$_0$ : B -> C -> D} 
      \hstype{Data$_1$ : Kind where}
      \hstypectr{Ctr$_2$ : E -> Data$_1$}
    \end{class}

    \begin{class}[text width=10cm]{Submodule$_1$}{0,-5}
      \attribute{\emph{Type level namespace}}
      \operation{\emph{Value level namespace}}
    \end{class}
    
    \draw [umlcd style, ->] (Submodule$_0$.south) -- (Submodule$_0$ |- Submodule$_1$.north); 
  \end{package}

  \begin{class}[text width=3cm]{Module$_0$}{10,-3.5}
  \end{class}

  \begin{class}[text width=3cm]{Module$_1$}{10,-5.5}
  \end{class}

  \begin{class}[text width=3cm]{Module$_2$}{15,-5.5}
  \end{class}

  \draw [umlcd style, ->] (Module$_0$.south) -- (Module$_0$ |- Module$_1$.north); 
  \draw [umlcd style, ->] (Module$_1$.east) -- (Module$_1$ -| Module$_2$.west); 

  \renewcommand{\umlfillcolor}{grey}
    \begin{class}[text width=10cm]{Dependency}{12,0.5}
      \hstype{$\ldots$}
      \hsfunc{$\ldots$}
    \end{class}


  \renewcommand{\umlfillcolor}{applegreen}
    \begin{class}[text width=10cm]{System Module}{12,-1.5}
      \hstype{$\ldots$}
      \hsfunc{$\ldots$}
    \end{class}

\end{tikzpicture}
}}\caption{Example of module diagram syntax}\label{fig:ModExample}
\end{figure}



\subsection{Module Hierarchy}

\begin{figure}[!ht]
\makebox[\textwidth][c]{
\scalebox{0.6}{
\begin{tikzpicture}

  \begin{package}{TypedSQL}

  \begin{class}[text width=30cm]{TypedSQLStatement}{10,18}
    \hstype{SQLMethod : [SQLType] -> SQLType -> Type where}
    \hstypectr{MkSQLMethod : (ts : [SQLType]) (o : SQLType) -> (Prod (SQLValSem . SQLRef) ts -> SQLMthd o) -> SQLMethod ts o}
    %% \hstype[20pt]{-> (Prod (SQLValSem . SQLRef) ts -> SQLMthd o) -> SQLMethod ts o}
     
    \hstype{SQLSem : Kind where}
    \hstypectr{Stmt, Mthd : SQLSem}

    \hstype{SQLStatement : SQLRefType -> Type = SQLSt Stmt}
    \hstype{SQLMthd : SQLRefType -> Type = SQLSt Mthd}

    \hstype{SQLSt : SQLSem -> SQLRefType -> Type where} 
    \hstypectr{Insert : TableSpec ts -> SQLVal (SQLRel (SQLRow ts)) -> SQLStatement SQLUnit}
    \hstypectr{Delete : TableSpec ts -> (SQLVal (SQLRow ts) -> SQLVal SQLBool) -> SQLStatement SQLUnit}
    \hstypectr{Update : TableSpec ts -> (SQLVal (SQLRow ts) -> SQLVal SQLBool) -> (SQLVal (SQLRow ts) -> SQLVal (SQLRow ts)) -> SQLStatement SQLUnit}
    \hstypectr{SetRef : SQLValRef x -> SQLVal x -> SQLStatement SQLUnit}
    \hstypectr{NewRef : (a : SQLType) -> IsScalarType a \~ True -> Maybe String -> Maybe (SQLVal a) -> SQLStatement (SQLRef a)}
    \hstypectr{MakeTable : SQLRow t -> SQLStatement (SQLRef (SQLRel (SQLRow t)))}
    \hstypectr{DropTable : TableSpec t -> SQLStatement SQLUnit}
    \hstypectr{IfSQL : SQLVal SQLBool -> SQLSt t0 a -> SQLSt t1 b -> SQLStatement SQLUnit}
    \hstypectr{(:>>=) : SQLStatement a -> (SQLValSem a -> SQLSt x b) -> SQLSt x b}
    \hstypectr{SQLNoop : SQLStatement SQLUnit}
    \hstypectr{SQLRet : SQLVal a -> SQLSt Mthd (Ty a)}
    \hstypectr{SQLFunCall : SQLMethodRef ts out -> Prod SQLVal ts -> SQLStatement (Ty out)}
    \hstypectr{SQLDefunMethod : SQLMethod ts out -> SQLStatement (SQLMethod ts out)}
  \end{class}


  \begin{class}[text width=11cm]{TypedSQLLanguage}{0,5}   
    \hstype{SQLSizeVariant : Kind where}
    \hstypectr{SQLSmall, SQLMedium, SQLNormal, SQLBig : SQLSizeVariant}

    \hstype{SQLSign : Kind where}
    \hstypectr{SQLSigned, SQLUnsigned : SQLSign}

    \hstype{SQLNumeric : Kind where}
    \hstypectr{SQLFloat, SQLDouble : SQLSign -> SQLNumeric}
    \hstypectr{SQLInt : SQLSizeVariant -> SQLSign -> SQLNumeric}

    \hstype{SQLRecLabel : Kind where}
    \hstypectr{(:::) : Symbol -> SQLType -> SQLRecLabel}

    \hstype{SQLType : Kind where}
    \hstypectr{SQLBool, SQLDate, SQLDateTime, SQLSerial : SQLType}
    \hstypectr{SQLNumericTy : SQLNumeric -> SQLType}
    \hstypectr{SQLBlob : SQLSign -> SQLType}
    \hstypectr{SQLVarChar : Nat -> SQLType}
    \hstypectr{SQLRel : SQLType -> SQLType}
    \hstypectr{SQLRow : [SQLRecLabel] -> SQLType}
    \hstypectr{SQLVec : [SQLType] -> SQLType}

    \hstype{SQLRefType : Kind where}
    \hstypectr{Ty : SQLType -> SQLRefType}
    \hstypectr{SQLRef, SQLUnit : SQLType}
    \hstypectr{SQLMethod : [SQLType] -> SQLType -> SQLRefType}

    \hstype{instance SingKind SQLType where $\ldots$}
    \hstype{instance SingKind SQLRefType where $\ldots$}

    \hstype{IsScalarType : SQLType -> Bool where $\ldots$}
    \hstype{IsScalarTypes : [SQLType] -> Bool where $\ldots$}

    \hsfunc{isScalarType : (x : SQLType) -> IsScalarType x}
    \hsfunc{isScalarTypes : (x : [SQLType]) -> IsScalarTypes x}
  \end{class}


  \begin{class}[text width=17.5cm]{TypedSQLExpr}{16,-0.5}
    \hstype{SQLVal : SQLType -> Type where}
    \hstypectr{SQLScalarVal : IsScalarType a :\~: True -> ValueExpr -> SQLVal a}
    \hstypectr{SQLQueryVal  : IsScalarType a :\~: False -> QueryExpr -> SQLVal a}

    \hsfunc{typeOf : SQLVal a -> a}
    \hsfunc{argOfRel : SQLRel a -> a} 

    \hstype{SQLValSem : SQLRefType -> Type where}
    \hstypectr{Unit : SQLValSem SQLUnit}
    \hstypectr{Val : (x : SQLType) -> SQLVal x -> SQLValSem (Ty x)}
    \hstypectr{pattern Method : Name -> SQLValSem (SQLMethod args out)}
    \hstypectr{pattern Ref : (x : SQLType) -> Name -> SQLValSem (SQLRef x)}

    \hsfunc{typeOfSem : f `In` [SQLRef, Ty] -> SQLValSem (f x) -> x}
 
    \hsfunc{colsOf : SQLRow xs -> xs}

    \hsfunc{unsafeSQLValFromName : (x : SQLType) -> Name -> SQLVal x}
    \hsfunc{unsafeSQLValFromQuery : (xs : [SQLRecLabel]) -> NonEmpty xs}
    \hsfunc[10pt]{ -> IsSetRec xs -> SQLVal (SQLRel (SQLRow xs))}
    \hsfunc{unsafeRefFromName : (x : SQLType) -> Name -> SQLValRef x}

    \hsfunc{deref : SQLValRef x -> SQLVal x}   
  \end{class}


  \begin{class}[text width=15.6cm]{TypedSQLTable}{17,5}
    \hstype{TableSpec : [SQLRecLabel] -> Type where}
    \hstypectr{MkTableSpec : SQLValRef (SQLRel (SQLRow t))  -> TableSpec t}
    \hstypectr{TableAlias : (ns : [Symbol]) -> IsSetRec ns }
    \hstype[20pt]{-> TableSpec t -> TableSpec (ZipRec ns (RecAssocs t))}

    \hsfunc{typeOfTableSpec : TableSpec t -> SQLRow t}
    \hsfunc{typeOfTableSpec : TableSpec t -> t}

    \hsfunc{tableSpec : Name -> Prod (K String :*: Id) tys}
    \hsfunc[10pt]{ -> exists (ks : [SQLRecLabel]) (Maybe (RecAssocs ks :\~: tys, TableSpec ks))}

  \end{class}

  \draw [umlcd style, ->] ([xshift=-60pt]TypedSQLStatement.south) -- ([xshift=-60pt]TypedSQLStatement |- TypedSQLExpr.north); 
  \draw [umlcd style, ->] ([xshift=60pt]TypedSQLStatement.south) -- ([xshift=60pt]TypedSQLStatement |- TypedSQLTable.north); 
  \draw [umlcd style, ->] ([xshift=-180pt]TypedSQLStatement.south) -- ([xshift=-180pt]TypedSQLStatement |- TypedSQLLanguage.north); 
  

  \draw [umlcd style, ->] (TypedSQLTable.south) -- (TypedSQLTable |- TypedSQLExpr.north); 
  \draw [umlcd style, ->] (TypedSQLTable.west) -- (TypedSQLTable -| TypedSQLLanguage.east); 
  \draw [umlcd style, ->] (TypedSQLExpr.west) -- (TypedSQLExpr -| TypedSQLLanguage.east);

  \end{package}

\end{tikzpicture}
}}\caption{Module diagram for TypedSQL} \label{fig:typedSQL}
\end{figure}


\subsection{Key Algorithm}
The key Algorithm for the EFA project is AMMBR \cite{AMMBR}. AMMBR is a method 
that allow organizations to build information systems that comply to their 
business requirements in a provable manner. This Algorithm is implemented in 
Ampersand and is responsible for translating the business requirements into ECA 
rules. These ECA rules contain information on how to fix any data violation and 
are translated into SQL queries in our EFA project.

\subsection{Communication Protocol}
The EFA implementation needs to communicate with the front end to be able to 
run the generated SQL queries when a violation occurs. 
	\begin{itemize}
		\item \textbf{Old communication protocol -  PHP engine} \newline
			In the existing version, Ampersand depends on PHP code to run the 
			generated SQL on the database. However, this comes at the cost of 
			human intervention, which results in manual maintenance when 
			changes occur during development. 
		\item \textbf{New Communication protocol - Stored Procedures} \newline
			The developments teams of EFA has come to a conclusion that the 
			best way of communicating with the front-end will be to use Stored 
			Procedures\cite{SP}. These Stored Procedures provide the extra 
			benefit of query optimization at compile time which results in 
			better performance. While this is a suggested change, it will 
			require changes to the existing Ampersand software in order for 
			this idea to be successfully implement. This anticipated 
			change will be implemented in the near future.
			
	\end{itemize}

\subsection{Error handling}
Most of the error handling is done by the underlying Ampersand software. Any 
human errors (syntactic or semantical) in the input ADL file are handled during 
the generation of ECA rules. These resulting ECA rules are fed into the EFA 
project and are determined to be provably correct. \edcomm{JG}{The sentence 
before this comment, starting with "These resulting ECA rules", there might be 
a sentence structure problem? It makes sense, but doesnt quite read right?} The 
language of implementation (i.e. Haskell), 
guarantees type level correctness of the EFA project at compile time. 
\newline
If any error occurs during runtime, the state of the database is checked 
before and after the SQL statement has ran. In case of an inconsistency found 
in the data, the SQL \textbf{rollback} command is issued and that will change 
the database to its previous state. In such a scenario, the user will be 
notified about the event and can take the necessary action to fix the issue. 

%% \subsection{Main Module}

%% %% ------------------------------M1: ECA2SQL -------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{3cm}X}
%%         M1 & eca2SQL \\ 
%%         \midrule 
%%         Main function & eca2SQL
%%         \\  Input & Options, FSpec, ECARule
%%         \\  Output & Doc
%%         \\	Services & Produces the final product by using supporting modules 
%%         as tools in translating ECA rules to SQL statements which can be 
%%         applied to a database.
%%         \\     
%%          \vspace{12pt}
%%      \end{tabularx}
%% \\
%% \underline{Internal Description}\\ \\
%% eca2SQL :: Options $\rightarrow$ FSpec $\rightarrow$ ECArule $\rightarrow$ Doc

%% %% ------------------------------M2: TypedSQL -------------------------------%%
%% \subsection{Support Modules}

%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
%%         M2 & eca2SQL \\ 
%%         \midrule       
%%         \\  Requires Modules & ProofUtils, Trace, Singleton
%%         \\	Services & Implements a type language for SQL through pattern 
%%         matches where the representation of SQL references types which can 
%%         appear in SQL statements. Contains Base which implements a typed SQL query 
%%         language and a type SQL statement.
%%         \\         
%%         \vspace{12pt}
%%     \end{tabularx} 


%% \setlength{\parindent}{0pt}
%% \underline{Internal Description}\\

%% Read as: \textit{function: input $\rightarrow$ input2 $\rightarrow$ 
%% output}\newline

%% Where a function may require multiple inputs of different types to produce the 
%% necessary output type.\\

%% \textit{function (type and value level): (x:A) $\rightarrow$ output}
%% This indicates the function of a certain type and its value level, this is seen 
%% on SQL types. (x:A) is used to indicate a variable x of type A (e.g. x=9, (x:A) 
%% is a type of integer). (function::) is used to define a function and its input 
%% types 



%% \newglossaryentry{N}{name=N, description= $\mathbb{N}$ represents 
%%     the 
%%     set of natural numbers}

%%  (:::) : Symbol $\rightarrow$ SQLType $\rightarrow$ SQLRecLabel \\
 
%%  SQLSizeVariant : Kind \\
%%  SQLSmall, SQLMedium, SQLNormal, SQLBig :SQLSizeVariant \\ \\
 
%%  SQLSign : Kind \\
%%  SQLSigned, SQLUnsigned : SQLSign  \\
 
%%  SQLNumeric : Kind \\
%%  SQLFloat, SQLDouble : SQLSign $\rightarrow$ SQLNumeric \\
 
%%  SQLInt : SQLSizeVariant $\rightarrow$ SQLSign $\rightarrow$ SQLNumeric \\
%%  SQLRecLabel : Kind \\

%%  SQLType : Kind \\
%%  SQLBool, SQLDate, SQLDateTime, SQLSerial : SQLType \\
 
%%  SQLNumericTy : SQLNumeric $\rightarrow$ SQLType  \\
%%  SQLBlob : SQLSign $\rightarrow$ SQLType \\
 
%%  SQLVarChar : N $\rightarrow$ SQLType 
%%  SQLRel : SQLType $\rightarrow$ SQLType \\
 
%%  SQLRow : [SQLRecLabel] $\rightarrow$ SQLType 
%%  SQLVec : [SQLType]$\rightarrow$ SQLType \\
 
%%  SQLRef, SQLUnit: SQLType \\
%%  SQLRefType: Kind\\
 
%%  SQLMethod: [SQLType] $\rightarrow$ SQLType $\rightarrow$ SQLRefType \\
%%  SQLVal: SQLType $\rightarrow$ Type \\
 
%%  SQLScalarVal: IsScalarType a $\equiv$ True $\rightarrow$ Sm.ValueExpr 
%%  $\rightarrow$ SQLVal a \\
%%  SQLQueryVal: IsScalarType a $\equiv$ False $\rightarrow$ Sm.QueryExpr 
%%  $\rightarrow$ SQLVal a \\
 
%%  SQLValSem: SQLRefType $\rightarrow$ Type\\

 
%%  Ty: SQLType $\rightarrow$ SQLRefType \\

%%  IsScalarType: SQLType $\rightarrow$ Bool \\
%%  isScalarType: (x:SQLType) $\rightarrow$ IsScalarType x \\
%%  IsScalarTypes: [SQLType] $\rightarrow$ Bool \\
%%  isScalarTypes: (X:[SQLType]) $\rightarrow$ IsScalarTypes x \\
 
%%  typeOf: SQLVal a $\rightarrow$ a \\
%%  argOfRel: SQLRel a $\rightarrow$ a\\
 
%%  Unit: SQLValSem SQLUnit\\
%%  Val:: SQLVal x $\rightarrow$ SQLValSem ('Ty x)
 
 

%% %% ------------------------------M3: Equality -------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
%%         M3 & Equality \\ 
%%         \midrule
        
%%         Contains functions  &  not, cong, elimNeg and more
%%         \\	Services &  The module contains utility functions that are being used in the Singletons and Utils module to provide type 		level security for the TypedSQL with an aim to make it total. It implements a primitive strict negation type, a strict decidable equality type,  and various equality proof function
%%         \\       
%%         \vspace{12pt}
%%     \end{tabularx}
%%     \vspace{3em}
%% %% ------------------------------M4: Singleton -------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
%%         M4 & Singleton \\ 
%%         \midrule
        
%%         Main function  &  No functions exported
%%         \\	Services &  Singletons contains an implementation of singletons (types which are inhabited by precisely one value)
%%   in a kind-generic way. This is used in contrast to the `singletons' package which makes heavy use of 
%%   Template Haskell. To avoid this massive pitfall, we have reimplemented singletons without Template Haskell.
%%         \\       
%%         \vspace{12pt}
%%     \end{tabularx}\vspace{3em}
%% %% ------------------------------M5: Utils -------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
%%         M5 & Utils \\ 
%%         \midrule
        
%%         Main function  & 
%%         \\	Services &  The module also contains some utility functions used by the ECA2SQL module
%%         \\       
%%         \vspace{12pt}
%%     \end{tabularx}\vspace{3em}
%% %% ------------------------------M6: Trace -------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{4cm}X}
%%         M6 & Trace \\ 
%%         \midrule
        
%%         Main function  &  getTraceInfo 
%%         \\	Services &  The modules contains support for tracing back the ECA rule. It implements a proper error message (with line numbers and function name). Tracing is used for development and debugging purpose
%%         \\       
%%         \vspace{12pt}
%%     \end{tabularx}\vspace{3em}
%% %% ------------------------------M7: Combinators------------------------------%%
%% {\setlength{\tabcolsep}{6pt} 
%%     \begin{tabularx}{\textwidth}{>{\bfseries}m{5cm}X}
%%         M7 & Combinators \\ 
%%         \midrule
        
%%         Main function  & No functions exported
%%         \\	Services &  This module contains Combinatory Logic for our TypedSQL module. The module defines SQL primitives such as AND, OR, NOT and the primitive SQL functions such as the EXISTS, GROUP BY, SORT BY.
%%         \\       
%%         \vspace{12pt}
%%     \end{tabularx}\vspace{3em}
%% %% ----------------------------- M8: Pretty    ------------------------------%%
%%     {\setlength{\tabcolsep}{6pt} 
%%         \begin{tabularx}{\textwidth}{>{\bfseries}m{5cm}X}
%%             M8 & Pretty \\ 
%%             \midrule
            
%%             Main function  & eca2PrettySQL
%%             \\	Services &  The module contains a pretty printer for the Typed SQL types. The intended purpose of this pretty printer is to produce human-readable SQL Statements.
%%             \\       
%%             \vspace{12pt}
%%         \end{tabularx}\vspace{3em}
%% \underline{Internal Description}\\ \\
%% eca2PrettySQL :: Options $\rightarrow$ FSpec $\rightarrow$ ECArule $\rightarrow$ Doc

%% \section{Module Decomposition} \label{SecMD}
%% Modules are located in their respective subsections (i.e. main module, support 
%% modules and external library modules). Each module is decomposed based on their 
%% use while hiding implementation details. 
%% \\ \newline
%% \textit{Please see glossary for math references and clarification of uncommon 
%% terms}

        
\subsection{External Libraries}
The EFA project depends on the following Libraries 
\begin{description}
	\item \textbf{Ampersand Core Libraries} \newline
		The EFA project depends on the Ampersand software for the definition of 
		core Data Structures, (i.e. FSpec, which contains the definition ofo 
		the underlying ECA rules). EFA also maintains the relational schema of 
		the input, and hence, imports Ampersand's existing functions to fetch 
		the table declarations while generating SQL Statements for the ECA 
		rules. AMMBR \cite{AMMBR}, which is the key algorithm responsible for 
		translating business requirements into ECA rules is an integral part of 
		Ampersand.
	\item \textbf{Simple-sql-parser} \newline
		EFA's pretty printer depends directly on this library for formatting 
		and printing SQL statements to console. This is important from a 
		development and debugging perspective.\cite{simple-sql}
	\item \textbf{wl-pprint} \newline
		The wl-pprint library\cite{wl-pprint} is a pretty printer based on the pretty printing combinators described by Philip Wadler (1997). EFA uses this library in combination with the simple-sql-pretty to output the SQL statements in a human readable format.
	\item 
\end{description}

\section{Traceability Matrix} \label{SecTM}

%% TODO : Fix position
Note : The traceability matrix is based on test plan submitted by the EFA team. Removing test cases 11,12,13 which are not feasible at this point. These test cases will be removed from the Test plan in the next update.

\begin{table}[]
\caption{Traceability Matrix for the EFA Project}
\label{traceMatrixl}
\begin{tabular}{l|l|llllll}
\multicolumn{1}{c}{}                                                   & \multicolumn{7}{l}{Requirements}  \\
\hline
\multirow{11}{*}{\begin{tabular}[c]{@{}l@{}}Test\\ Cases\end{tabular}} &     & F1 & F3 & F4 & F6 & N1 & N2 \\
\hline
                                                                       & T1  & *  &    &    &    &    &    \\
                                                                       & T2  & *  &    &    &    &    &    \\
                                                                       & T3  & *  &    &    &    &    &    \\
                                                                       & T4  & *  &    &    &    &    &    \\
                                                                       & T5  & *  & *  &    &    &    &    \\
                                                                       & T6  &    & *  &    &    &    &    \\
                                                                       & T7  &    &    & *  &    &    &    \\
                                                                       & T8  &    &    &    & *  & *  &    \\
                                                                       & T9  &    &    &    &    &    & *  \\
                                                                       & T10 &    &    &    & *  &    &   
\end{tabular}
\end{table}


%%%\section{Use Hierarchy Between Modules} \label{SecUse}





%\section*{References}
\clearpage
\printglossaries
\bibliographystyle{alpha}
\bibliography{DesignDoc}

\end{document}

%%  LocalWords:  UML
