1.  What is the meaning of the Declaration type (AbstractSyntaxTree, line 214)?
What is the meaning of each constructor?
List was mentioned quickly yesterday, java doc means to mimic natural language, put things in java doc
Meaninging is meant to carry natural language meaning; urges user to give meaning (for ampersand user)
-	Hooks into tracability
-	showsPrec _g = showString (readable if the user does a good job in filling in the pieces)


decMean :: AMeaning, but this type is just a list of [A_Markup], which is just
Pandoc markup? How does this represent the meaning? 
-	Concepts is just a name; one concept needs to be there (concept 1 ; means something like  --- something exists, really need it); init object in c (something needs be here for life)
-	Name identifies the concept 
-	decMean is not just a string, but dec markup – like latex mark up; everthing pan doc we allow too 
-	we use pandoc parsers to parse that mark up 
SKIP THIS STUFF YOU WILL NOT NEED TO TOUCH THAT. ITS FOR DOCUMENTATION
-----------------------------------------------------------------------------------------

2.  What is the meaning of PlainConcept (AbstractSyntaxTree, line 782)? What
does `the set of instances Cs by name Nm' mean?

----------------------------------------------------------------------------------

3. What are 'properties' and 'identities'? (AbstractSyntaxTree, line 149)?  In
the context of ' This rule follows implicitly from the Ampersand script (Because
of a property/identity) ' ?

Rule origin: line and col number; reference number to location of data (cell)
Identity rfers to identity relation
Property to subset of identity relation
Dfined by annotation declaration; 
	Ex. Relation works for [ t of E] means the relation is total; user did not write it down himself; rule origin multiplicity because of a property; Cardinality annotations; 

-------------------------------------------------------------------------------------------

4. What is PairView? 

data PairViewSegment a = 
    PairViewText{ pvsOrg :: Origin
                , pvsStr :: String
                }
  | PairViewExp { pvsOrg :: Origin
                , pvsSoT :: SrcOrTgt
                , pvsExp :: a
                } deriving (Show, Typeable, Eq, Generic)

data PairView a = PairView { ppv_segs :: [PairViewSegment a] } 
	ppv_segs (field label technically, constructur pairview segment takes pairview segment and makes it; single record field; only one record field (same thing as the thing in the record); isomorphisms between new types and old types.
Part of P structure; used to show what violations would look like on your screen; that’s part of the rule syntax, give nice error messages; normally a vilation would show up as a pair – can decorate that pair with text to assemble an error message. 

---------------------------------------------------------------------------------------------------

5. Algebra; What is 'POP' (relation elements)?

Ampersand script contains:
  - RUL: rule statements (relational algebra) 
  - REL: relations 
  - POP: ????



------------------------------------
-	P to A is fairly straight forward but A to F is fairly straight forward
-	F spec is very redundant because of the complications that are necessary, done so that the generated prototype and analysis can work afterwards on the same data structure without discrepancies 
-	Rendering is done behind f spec. such as generating documents and such 
-	Suppose to be robust, Haskell that is generated is very readable
Compile ampersand with –haskell to get the source code of that structure; can be used for debugging purposes
Consolidated into the F structure
Meat grinder ?? largely ignore it, might run into it in the source code, takes ampersand script and putts it into the relational structure; data table relation and compiled into data table rules; dropped into the database tables; can use – meta for meat grinder; written in ampersand so it can be
RAP compiles ampersand in ampersand; quasy higher order; atlas used (like GUI). Predecessor to Ampesand + meat grinder

From expression to ECA rules (different data structure), not translating back into expression
SQL generator already – generate SQL syntax from expression; process algebra = PA Claus; all clauses need to be generated
PAClaus, end and middle will be fixed; from a relation expression we can generate the corresponding – via intermediate data structure ? null algebra -? translated to SQL; 
PAClaus (partially imperative code) and need to be translated to the front end (LOOK INTO); front end has transaction mechanism (edit stuff a transaction gets opened); 
1. rules generated by PA Clauses; restore invariance
2. run PA clauses that compute default things
3. ex. If you filled in security number so the system knows name and address – ECA rules can fill in the form for you. Push save button that saves the transaction (can only be saved if all invariant rules are tested); rules/subset of rules need to be checked. 
4. fit ECA rules operationally into the main code, 

PA Claus; flavor of language, not too far away from the way it is expressed; one type of imperative programming language; data structure, no need to compile it; 

Module CALC which does the generation of PA rules from relation expressions
Only repository is Atlas. Patterns are a set of rules. Patterns stored in Tarski are only in text format.

Switch called – proofs (attempts to omit textual proofs as we go along), debugging code and testing without the entire system; proofs 
Translate RA expressions – from a C like specification language; generate understanding; 

All steps need to be correctness preserving; by equality or preservation
----------------------------------------------------
When type –proto <directory>; 

Buttons: generate proto
-	Yellow violations (process rule violations, for exec engine – reinstall until removed)
-	Look at database (phpMyadmin)
-	Exec engine; a hack; fake the ECA rules
-	SRS 
