\documentclass[journal,12pt,onecolumn,draftclsnofoot]{article}
%for 
%double spacing
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[sectionbib]{chapterbib}
\usepackage{subfiles}
\usepackage[noadjust]{cite}
\usepackage[round,numbers]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}
\usepackage{../ltx/edcomms}
\usepackage{../ltx/setupComments}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{glossaries}
\usepackage{multirow} %% Used for Traceability matrix
\usepackage{listings}
\usepackage{calc}
\usepackage[simplified]{pgf-umlcd}
\usepackage[section]{placeins}
\usepackage{enumitem}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}


% \input{filename.tex}      %will format input document according to base doc, 
%%can nest
% \include{filename.tex} % cant nest
% \subfile{filename.tex} % used to load child docs
% \usepackage{standalone} %used for importing preamble of child docs
% \usepackage[final]{pdfpages.pdf} %used to insert pdf files; final 
%%format[pages=3-6]
%---------------------------
\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}
\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
\makeglossary


% math things
\newcommand{\ra}{$\rightarrow$}



% 
\definecolor{grey}{RGB}{192,192,192}
\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}
\lstset{ %
  language=Haskell, morekeywords = {family, kind, pattern, expression},
  literate=
  {+}{{$+$}}1
  {/}{{$/$}}1 
  {*}{{$*$}}1 
  {=}{{$=\,\,\,$}}1
  {==}{{$==$}}1 
  %{/=}{{$\not\equiv$}}2
  {==}{{$\equiv$}}2
  {/=}{{$\not\equiv$}}2
  {>}{{$>$}}1 
  {<}{{$<$}}1 
  {\\}{{$\lambda$}}1
  {\\\\}{{\char`\\\char`\\}}1
  {>>}{$>>$}2 
  {:>>=}{{$:>>=$}}2
  %% {>>=}{{\hspace{6pt}\texttt{$>>=$}\hspace{6pt}}}2
  {->}{{$\rightarrow$} }2 
  {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
  {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$} }2
  {|}{{$\mid$}}1 
  {forall}{{$\forall$}}1
  {exists}{{$\exists$}}1 
  {Nat}{{$\mathbb{N}$}}1
  {:\~:}{{$\equiv$}}2
  {\~}{{$\equiv$}}2
  {`In`}{{$\in$}}1
  {.}{{$\circ$\,\,}}1
  ,
  escapeinside={\%*}{*)},
  deletekeywords={>>,>>=,mapM,mapM_,putStrLn,putStr,toInt,show,and,sequence,String,Bool
    ,True,False,Maybe,id,Show,Ordering,Void,Just,Nothing,Int},
  morekeywords={forall, ::, :},
  postbreak={},
  breaklines=true,                
  breakatwhitespace=true,
  %postbreak={  \mbox{\textcolor{grey}{$\rightarrow$}} },
  breakindent = 0pt,
  breakautoindent = true,
  %moredelim=[is][\itshape]{"}{"},
  morestring=[b]",
  mathescape
}

\newcommand{\hstype}[2][0pt]{\attribute{\hspace*{#1}\lstinline[mathescape]|#2|}}

\newcommand{\hstypectr}[1]{\attribute{\hspace*{10pt}\lstinline[mathescape]|#1|}}

\newcommand{\hsfunc}[2][0pt]{\operation{\hspace*{#1}\lstinline[mathescape]|#2|}}


%\newcommand{\@supervisor}{}
\newcommand{\supervisor}[1]{\renewcommand{\@supervisor}{#1}}


%%\end{filecontents*}
\makeindex

\begin{document}
%\maketitle %% Title page included from Title.tex
\input{title}
\newpage


\begin{abstract}
%light description
Ampersand Tarski is a tool used to produce functional software documents based 
on business process requirements. At times, logical 
discrepancies arise when system changes occur which violate the 
restrictions set forth by the user. When a system violation occurs, one of two 
things can happen: the change that is meant to take place is adjusted so it no 
longer violates the restrictions or the changes are discarded. The purpose of 
Event condition action rules for Ampersand (EFA) was to replace the exec-engine 
that is currently used to deal with violations; unlike the exec-engine, EFA is 
automated and provides proof of correctness embedded in the code, it able to 
type SQL statements and assure no "dead-ends" occur when queries are executed.
\end{abstract}
\newpage
\tableofcontents
\newpage
\newpage
\section{Introduction}\label{Intro}

This document is a meant as a guide for EFA that includes the motivations taken 
from a business perspective, the mathematical and software foundations that 
resulted in the logical flow of EFA's design, and the testing that took place 
to assure EFA's functionality and correctness.

Currently, Ampersand is readily accessible to the public through Github and it 
is equipped with the ability to assess logical 
discrepancies on sets of data based on user-specified restrictions. Logical 
discrepancies arise when system changes occur which violate the 
restrictions set forth by the user. When a system violation occurs, one of two 
things can happen: the change that is meant to take place is adjusted so it no 
longer violates the restrictions or the changes are discarded. Ampersand is 
used to manipulate data and generate prototypes, although there is a debugger, 
certain errors still slip through. When the system rules are changed by the 
user, all data which are inconsistent with the new system must be eliminated or 
rehabilitated so it can be returned back into the system. Data inconsistencies 
are persistent bugs that can distort the product that Ampersand seeks to 
provide. 

These data inconsistencies are corrected through ECA rules which use process 
algebra (PA) to correct or discard data using violations. EFA is used to 
translate these ECA rules, execute SQL queries to correct violations and 
safeguards the database from illegal transactions.

\subsection{Ampersand}

A large part of designing software systems is requirements engineering. One
of the greatest challenges of requirements engineering is translating from
business requirements to a functional specification. Business requirements are
informal, with the intention of being easily understood by humans; however,
functional specifications are written in a formal language that is unambiguous 
and precise. It is meant to capture attributes of the information system that 
is desired by multiple parties. Typically, this translation
of business requirements to a formal specification is done by a requirements
engineer, which can be prone to human error.

Ampersand offers an alternative solution which translates the natural language 
used in business process into requirement specifications \edcomm{JG:}{cite 
ampersand book}. Ampersand is a 
software system which offers many tools that aid their clients in the 
translation process from business requirement to formal requirement 
specifications. EFA is implemented as an internal component of Ampersand that 
is meant to automate the correction of system invariants. EFA aids by reducing 
the manual labour required to fix invariants and assures that the database is 
free of errors.  


Ampersand is a software tool that translates natural language into 
\subsubsection*{Ampersand in practice}
\indent The correct installation and usage of the Ampersand tools and the 
additional tools requires
some IT awareness, especially in case some unexpected errors occur when the 
Ampersand tool
uses the additional tools.
To get used to the specific syntax of how business rules are defined in the ADL 
language
requires some training. Besides the base syntax, a specific patterns hub is 
available, to support
new and seasoned ADL users, which can be used for training, inspiration and 
re-usage.

\edcomm{YS}{Merging in my section here}
\subsection{Purpose of the project}
\edcomm{JG}{Need an overview on what EFA is, what it does}
\edinsert{YS}{Based on today's meeting. Merging in the 	purpose of the project here}
\subsection{Document Guide}
This document acts as a comprehensive guide to EFA, the first section covers 
the basics of Ampersand and the purpose of the project. The second section 
provides an overview of EFA's requirements specifications and various naming 
conventions and terminology used throughout the course of this guide. The third 
section focuses on design implementation and provides information on modules 
from a top down basis. It also explains the key algorithm used to translate 
businesses process into eca rules which EFA then uses to produce SQL queries. 
Much of the proof of correctness is embedded in the code that is explained in 
this section. Lastly, section four mostly focuses on testing. 

\input{bus-section}


\subsection{Naming Conventions and Terminology}\label{sec:Naming} 
\begin{description}
    \item[ECA] Stands for Event-Condition Action. The rule structure used for 
    data
    bases and commonly used in market ready business rule engines. ECA rules are
    used in Ampersand to describe how a database should be modified in response 
    to
    a system constraint becoming untrue. 
    
    \item [ADL] Stands for ``Abstract Data Language'' (\cite[13]{derFun}). From 
    a
    given set of formally defined business requirements, Ampersand generates a
    functional specification consisting of a data model, a service catalog, a
    formal specification of the services, and a function point analysis. An ADL
    script acts as an input for Ampersand. An ADL file consists of a plain ASCII
    text file.
    
    \item [Ampersand] Ampersand is the name of this project. It is used to 
    refer to
    both the method of generating functional specification from formalized
    business requirements, and the software tool which implements this method.
    
    \item [Business requirements] Requirements which exist due to some real 
    world 
    constraints (i.e. financial, logistic, physical or safety constraints). 
    
    \item [Business rules] See \emph{Business Requirements}.
    
    \item [EFA] Stands for ``ECA (see above) for Ampersand''. This term is used 
    to 
    refer to the contribution of this project. 
    
    \item [Functional specification] A \emph{formal} document which details the 
    operation,
    capabilities, and appearance of a software system. 
    
    \item [Natural language] Language written in a manner similar to that of 
    human 
    communication; language intended to be interpreted and understood by 
    humans, as 
    opposed to machines. 
    
    \item [Requirements engineering] The process of translating business
    requirements into a functional specification. 
    
    \item [Prototype] Ampersand generates a prototype for the user that 
    provides a 
    front-end interface that connects to a back-end database.
    
\end{description}

\subsection{Implementation Issues}

This section contains a detailed list of concerns that came to light during the 
course of software implementation, though some issues were addressed, others 
are left unresolved as there is no known solution for them. The list is 
provided as a comprehensive overview of the thought process that went into the 
implementation of EFA, and the reasoning behind the design decisions which were 
made.

\begin{itemize}
    \item \textbf{No kind equality.} Singletons cannot be implemented as widely 
    as we would like them to be; essentially such a type is impossible:
    \begin{lstlisting}
    data X (a::k) where
    XF :: X a $\rightarrow$ X f $\rightarrow$ X (f a)
    \end{lstlisting}
    \item \textbf{Non-injective type families.} Specifically, lack of 
    injectivity in type functions means that GHC cannot infer an instantiation 
    of a type variable that appears only under type families. Recently, 
    Microsoft researchers have implemented a GHC modification that allows type 
    functions to be annotated as injective and plan to make it available with 
    the next stable release of the compiler \cite{microsoft}.
    \item \textbf{Functional dependencies are \textit{NOT} equivalent to type 
        families.} For example, given:
    \begin{lstlisting}
    class ... $\Rightarrow$ C a b c| a $\rightarrow$ b
    
    you cannot write
    
    injec :: (C a b, C a b') $\Rightarrow$ b :~: b' 
    \end{lstlisting}
    This is because it is simply not true, no solution for this is 
    currently known \cite{sof}. 
    \item \textbf{Types as propositions.} This is assuming that one exists; 
    simply put, it describes a correspondence between a given logic and a given 
    programming language, where we have "simplification of proofs as evaluation 
    of programs" \cite{props}.
    \item \textbf{Certain invariants are difficult to state and prove.} The 
    solution implemented for this problem was to vastly simply term language 
    and to use informal correctness reasoning. %TTODO: not sure this is 
    %correct, theres a paper on informal corrnectess reasoning that applies to 
    %concurrency in kernels
    \item \textbf{Singletons have a lot of boilerplate code.} Each model 
    requires a constant amount of boilerplate code for each constructor. 
    %TODO: write the boilerplate -- does this mean write the boilerplate code 
    %yourself and adapt it to your specific needs?
    \item \textbf{Defining a typed term from untyped ones.} This had to be done 
    in a semi-safe way; the solution taken was to use abstraction barriers 
    cautiously to construct unsafe data types. %TODO: unsafe datatypes? it just 
    %says unsafe =(
    \item \textbf{The complex relationship between SQL schemata and 
        declarations.} This is specific to the long tables used in Ampersand's 
    database. Database schemata must be converted into a type level 
    representations along with all necessary proofs. The solution implemented 
    for this was to under specify the result type of the existentially 
    quantified function. Rather than fabricating a proof using a function $P$ 
    and a valid input $x$, a decision procedure for $P$ is written and the 
    functions which require such a proof will check that it is true, or throw 
    an error. These functions are only used internally -- they are not part of 
    the interface; such functions would only be called when the input is known 
    to satisfy $P$. This is something that the programmer is able to reason 
    about but not the compiler. %--to the programmer but not the compiler, find 
    %out what this means
\end{itemize} 







%%%%%%%%%%%%%%%%%
% Inlcudes sections about 		%
% 1) Purpose of the Project		%
% 2) The stake holder	s 		%
% 	and the intended audience	%
% 3) Implementation Environment %
%%%%%%%%%%%%%%%%%
%%\input{bus-section}


\input{design-section}
\input{testing-section}
\newpage

\bibliographystyle{alpha}
\bibliography{references}
\end{document}


