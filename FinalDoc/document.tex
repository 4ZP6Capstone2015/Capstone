\documentclass[journal,12pt,onecolumn,draftclsnofoot]{article}
%for 
%double spacing
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[sectionbib]{chapterbib}
\usepackage{subfiles}
\usepackage[noadjust]{cite}
\usepackage[round,numbers]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{float}
\usepackage{../ltx/edcomms}
\usepackage{../ltx/setupComments}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{changepage}
\usepackage{adjustbox}
\usepackage{graphicx}
\usepackage[section]{placeins} % Prevents floats from floating across sections
\usepackage{tabularx}
\usepackage{ltablex} %% Multi page tables 
\usepackage{amsfonts}
\usepackage{glossaries}
\usepackage{multirow} %% Used for Traceability matrix
\usepackage{listings}
\usepackage{calc}
\usepackage[simplified]{pgf-umlcd}
\usepackage[section]{placeins}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{longtable}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usetikzlibrary{positioning}
\usepackage{indentfirst}
\newcolumntype{C}[1]{>{\centering}p{#1}} %% For use with tabularx


% \input{filename.tex}      %will format input document according to base doc, 
%%can nest
% \include{filename.tex} % cant nest
% \subfile{filename.tex} % used to load child docs
% \usepackage{standalone} %used for importing preamble of child docs
% \usepackage[final]{pdfpages.pdf} %used to insert pdf files; final 
%%format[pages=3-6]
%---------------------------
\let\Oldsubsection\subsection
\renewcommand{\subsection}{\FloatBarrier\Oldsubsection}
\let\Oldsubsubsection\subsubsection
\renewcommand{\subsubsection}{\FloatBarrier\Oldsubsubsection}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}
\makeglossary

\setlength\parindent{24pt}
% math things
\newcommand{\ra}{$\rightarrow$}



% 
\definecolor{grey}{RGB}{192,192,192}
\definecolor{applegreen}{rgb}{0.55, 0.71, 0.0}
\lstset{ %
  language=Haskell, morekeywords = {family, kind, pattern, expression},
  literate=
  {+}{{$+$}}1
  {/}{{$/$}}1 
  {*}{{$*$}}1 
  {=}{{$=\,\,\,$}}1
  {==}{{$==$}}1 
  %{/=}{{$\not\equiv$}}2
  {==}{{$\equiv$}}2
  {/=}{{$\not\equiv$}}2
  {>}{{$>$}}1 
  {<}{{$<$}}1 
  {\\}{{$\lambda$}}1
  {\\\\}{{\char`\\\char`\\}}1
  {>>}{$>>$}2 
  {:>>=}{{$:>>=$}}2
  %% {>>=}{{\hspace{6pt}\texttt{$>>=$}\hspace{6pt}}}2
  {->}{{$\rightarrow$} }2 
  {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
  {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$} }2
  {|}{{$\mid$}}1 
  {forall}{{$\forall$}}1
  {exists}{{$\exists$}}1 
  {Nat}{{$\mathbb{N}$}}1
  {:\~:}{{$\equiv$}}2
  {\~}{{$\equiv$}}2
  {`In`}{{$\in$}}1
  {.}{{$\circ$\,\,}}1
  ,
  escapeinside={\%*}{*)},
  deletekeywords={>>,>>=,mapM,mapM_,putStrLn,putStr,toInt,show,and,sequence,String,Bool
    ,True,False,Maybe,id,Show,Ordering,Void,Just,Nothing,Int},
  morekeywords={forall, ::, :},
  postbreak={},
  breaklines=true,                
  breakatwhitespace=true,
  %postbreak={  \mbox{\textcolor{grey}{$\rightarrow$}} },
  breakindent = 0pt,
  breakautoindent = true,
  %moredelim=[is][\itshape]{"}{"},
  morestring=[b]",
  mathescape
}

\newcommand{\hstype}[2][0pt]{\attribute{\hspace*{#1}\lstinline[mathescape]|#2|}}

\newcommand{\hstypectr}[1]{\attribute{\hspace*{10pt}\lstinline[mathescape]|#1|}}

\newcommand{\hsfunc}[2][0pt]{\operation{\hspace*{#1}\lstinline[mathescape]|#2|}}


%\newcommand{\@supervisor}{}
\newcommand{\supervisor}[1]{\renewcommand{\@supervisor}{#1}}


%%\end{filecontents*}
\makeindex

\begin{document}
%\maketitle %% Title page included from Title.tex
\input{title}
\newpage


\begin{abstract}
%light description
Ampersand Tarski is a tool used to produce functional software documents based 
on business process requirements.
At times, atomic state changes cannot be accepted as transactions
since they violate system invariants specified in the requirements.
When a system invariant violation occurs, one of two 
things can happen: the change that is meant to take place is adjusted (where it 
no longer violates the rules of the system) or the change is
discarded. The ultimate purpose of Event-Condition-Action rules for Ampersand 
(EFA) is to replace Ampersand's ``Exec-engine''
which is currently used to fix system violations. However, the Exec-engine 
relies on manual formulation of repair actions in an error-prone setup that 
creates PHP-embedded SQL commands from string fragments, as opposed to using 
the automatically-generated Event-Condition-Action (ECA) rules that Ampersand 
already produces. The EFA project aims to ultimately make the Exec-engine 
superfluous by correctly translating the ECA rules and implementing them as SQL 
queries so that system violations may be automatically corrected. EFA is 
automated and requires no additional work from the user. In addition, the 
generated SQL produced by EFA is by construction syntax- and type-correct. 
Furthermore, EFA has a high degree of modularity as it only relies on 
Ampersand's essential components.
\end{abstract}
\newpage
\tableofcontents
\newpage
\newpage
\section{Introduction}\label{Intro}

This document is a guide for the EFA project and includes an brief 
introduction 
to Ampersand, the software requirements used to implement EFA, a section on 
software development, which describes what each module of EFA contains, and 
lastly, a section on software testing.

\subsection{Document Guide}

This document acts as a comprehensive guide to EFA, the first chapter covers 
the basics of Ampersand, the purpose of the project, the intended audience 
(i.e. our stakeholders), tools used to run Ampersand and terminology which will 
be used throughout this guide. 

The second chapter provides an overview of EFA's requirements specifications; 
it is divided into Ampersand system requirements and the EFA project 
requirements.The third section focuses on design implementation and provides 
key information 
on EFA modules. In addition, it provides an outline of the AMMBR algorithm, 
which is used to generate ECA rules and communication protocols which explains 
how EFA communicates with Ampersand's front end. A lot of the proof written to 
verify EFA's correctness is embedded within each module which is covered in 
this section. 

The fourth section covers testing, specifically, it covers property testing 
using QuickCheck and testing MySQL queries using WorkBench. Lastly, the 
Appendix 
covers a variety of information such as tips for setting up 
Ampersand and notes on issues that came up during the course of EFA's 
implementation. 

\subsection{Ampersand}

\indent
The motivation behind Ampersand comes from requirements engineering, which is a 
large part of designing software systems. One of the greatest challenges of 
requirements engineering is translating informal business requirements into 
formal functional specification. Business requirements contain ambiguity 
because they are written in a natural language with the intention of being 
easily understood by humans; however,
functional specifications must be written in a formal language that is 
unambiguous and precise. Typically, this translation of business requirements 
to a formal specification is done by a requirements
engineer, which can be prone to human error.

Ampersand offers an alternative solution which translates the natural language 
used in business process into requirement specifications \cite{ruledesign}. 
Ampersand is a 
software system which offers many tools that aid their clients in the 
translation process from business requirement to formal requirement 
specifications. EFA is implemented as an internal component of Ampersand that 
is meant to automate the correction of system invariants. EFA helps reduce the 
amount of manual labour required by the user by executing SQL queries to fix 
data violations. %---- edit here 

Given a set of data and a set of rules used to operate on the data, Ampersand 
is able to determine if there are discrepancies between the two sets. 
Discrepancies often occur when changes are made to the set of data Ampersand is 
given or to the set of rules that as associated with them. Data discrepancies 
are violations or illegal transactions that occur in the Ampersand system when 
a set of data fails to follow the rules given by the user. When a system 
violation occurs, one of two things can happen: the change that is meant to 
take place is adjusted (where it no longer violates the rules the user 
provides) or the change is discarded. EFA enhances the Ampersand system by 
translating ECA rules and executing them as SQL queries to correct system 
violations and safeguard the database from wrongful transactions.

\subsubsection{Ampersand In Practice}

The Ampersand system is implemented in Haskell and relies on external software 
tools to help generate a prototype and its supporting documents. On windows, 
there is an executable available, but on Linux and Mac operating systems it 
requires installing stack (The Haskell Tool Stack) to build Ampersand from 
source. 
Instructions on how to install the tools and components listed in this section 
can be found in the appendix.

\subsubsection*{The Haskell Platform}
\noindent
Ampersand's most current version requires 
\href{https://www.haskell.org/platform/}{the Haskell Platform 7.10 }. It is 
used to compile Ampersand source code.


\subsubsection*{Ampersand's GitHub}\label{Github}
\noindent
Github hosts the most current version of the Ampersand system. Github is used 
to maintain consistency between the main Ampersand branch and this project. The 
most recent version of Ampersand can be found at 
\href{https://github.com/AmpersandTarski}{Ampersand Tarski's Github }


\subsubsection*{Graphviz}
\noindent
\href{http://www.softpedia.com/get/Others/Miscellaneous/Graphviz.shtml}{Graphviz}
 is an open source graph visualization software that Ampersand uses to generate 
 artifacts, specifically it is used to create graphics for the prototype's 
 requirement documentation. Graphviz is able to take descriptions of graphs in 
 simple text and create diagrams from them. 

\subsubsection*{The Cabal System}
\noindent
\href{https://www.haskell.org/cabal/}{The Cabal System} is used for building 
and packaging Haskell libraries and programs. 
Cabal describes what a Haskell package is, how these packages interact with the 
language, and what must be implemented to support the packages that are used. 
It is part of a larger infrastructure used to distribute, organize, and catalog 
Haskell programs and their associated libraries. \cite{hackage}

\subsubsection*{The Haskell Tool Stack}
\noindent
\href{https://www.haskell.org/cabal/}{The Haskell Tool Stack} is used to 
install the most recent version of Ampersand from source code, and various 
Haskell packages (e.g., QuickCheck).

\subsubsection*{QuickCheck}
\noindent
\href{https://hackage.haskell.org/package/QuickCheck}{QuickCheck} is used to 
test properties of functions used in EFA's modules. QuickCheck is a library for 
random testing of program properties; a programmer simply provides a 
specification of properties which functions should satisfy and QuickCheck 
generates a large number of random cases to test these properties. QuickCheck 
comes with a
\href{http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html}{manual} on how 
properties can be defined and used. 

\subsubsection*{MySQL WorkBench}
\noindent
\href{https://dev.mysql.com/doc/workbench/en/}{MySQL WorkBench} is used to test 
the SQL queries generated by EFA. MySQL WorkBench is a graphical tool for MySQL 
databases and comes with a build-in editor, in this project it is used to 
manually test queries. Through various stages in development it is used for 
data modeling.

\subsection{Naming Conventions and Terminology}\label{sec:Naming} 
\begin{description}
    \item[ECA] Stands for Event-Condition Action. The rule structure used for 
    data
    bases and commonly used in market ready business rule engines. ECA rules are
    used in Ampersand to describe how a database should be modified in response 
    to
    a system constraint becoming untrue. 
    
    \item [ADL] Stands for ``Abstract Data Language'' (\cite[13]{derFun}). From 
    a
    given set of formally defined business requirements, Ampersand generates a
    functional specification consisting of a data model, a service catalog, a
    formal specification of the services, and a function point analysis. An ADL
    script acts as an input for Ampersand. An ADL file consists of a plain ASCII
    text file.
    
    \item [Ampersand] Ampersand is the name of this project. It is used to 
    refer to
    both the method of generating functional specification from formalized
    business requirements, and the software tool which implements this method.
    
    \item [Business requirements] Requirements which exist due to some real 
    world 
    constraints (i.e. financial, logistic, physical or safety constraints). 
    
    \item [Business rules] See \emph{Business Requirements}.
    
    \item [EFA] Stands for ``ECA (see above) for Ampersand''. This term is used 
    to 
    refer to the contribution of this project. 
    
    \item [Functional specification] A \emph{formal} document which details the 
    operation,
    capabilities, and appearance of a software system. 
    
    \item [Natural language] Language written in a manner similar to that of 
    human 
    communication; language intended to be interpreted and understood by 
    humans, as 
    opposed to machines. 
    
    \item [Requirements engineering] The process of translating business
    requirements into a functional specification. 
    
    \item [Prototype] Ampersand generates a prototype for the user that 
    provides a 
    front-end interface that connects to a back-end database.
    
\end{description}
\input{bus-section}
\input {requirements-section}


%%%%%%%%%%%%%%%%%
% Inlcudes sections about 		%
% 1) Purpose of the Project		%
% 2) The stake holder	s 		%
% 	and the intended audience	%
% 3) Implementation Environment %
%%%%%%%%%%%%%%%%%
%%\input{bus-section}


\input{design-section}
\input{testing-section}
\newpage

\bibliographystyle{alpha}
\bibliography{references}
\newpage
\input{appendix}
\end{document}


